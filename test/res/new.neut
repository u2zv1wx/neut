(include "notation.neut")

(include "enum.neut")

(include "top.neut")

(include "bottom.neut")

(include "constant.neut")

(include "state.neut")

(include "io.neut")

(enum choice left right)

(enum three three-0 three-1 three-2)

(constant admit-explicit
  (pi ((A type)) A))

(keyword admit)

(notation admit (admit-explicit _))

;; 「あ」のutf8-encoding
(definition str ()
  (u8-array-introduction
    (n3-0 227)
    (n3-1 129)
    (n3-2 130)))

;; 文字列をunicode encodingされたu8 arrayへと変換して保持
(definition test ()
  "あ")

;; (notation (sigma (xt+) t)
;;   (pi
;;     ((c tau)
;;      (_ (pi (xt+ (_ t)) c)))
;;     c))
(definition string
  (sigma ((A type) (prf (is-enum A)))
    (u8-array A)))

;; 長さがn15になるのがポイントで、ここでunicodeの複雜性が出てくる
;; n15の部分をsigmaで包めばどうにかなりそうな雰囲気はある。
(write n3 stdout (test) enum.n3)

;; (write n15 stdout (test) enum.n15)

;; (write n15 stdout (test) enum.n15)

(definition coproduct ((A tau) (B tau))
  (sigma ((x choice))
    (case x
      (left A)
      (right B))))

(ascription coproduct
  (arrow (tau tau) tau))

(enum nat-enum zero-inner succ-inner)

;; nat = mu x. 1 + x = mu x. Sigma (p : choice). case p of left -> 1 | right -> x
;; これさー、CBVで考えると普通に無限ループなんだよね？
;; (definition nat-inner ()
;;   (coproduct top (nat-inner)))
;; 無限ループですね。coproductの部分をインライン展開しても、まだiterの適用だから無限ループ。
;; そのiterをpi-introに展開しても、まだnat-innerがpureかどうかはわからないから……いや、そこをreduceしろ、って話なのでは？
;; 型がpureであることをつかって。
;; coproductの適用部分は、しかし、CBVだと無限ループになっている。
;; coproductが引数として() -> tauを受け取れるようになっていれば、ここは抑えられる。
;;   (definition nat-inner ()
;;     (coproduct (thunk top) nat-inner))
;; みたいにするわけ。このときはcoproductのreduceができて、んでcoproductはsigmaになっていて、それのおかげで
;; nat-innerがclosureとして普通に処理できるようになる。

;; 無限ループしないように修正していく
(definition nat-inner ()
  (sigma ((x choice))
    (case x
      (left top)
      (right (nat-inner)))))
;; こっちなら、sigmaの中身が消えることによって無限ループは生じないはず。……実際、うまくいった。
;; (coproduct top (nat-inner)))
;; sigmaの中でのrecursive callは問題なし、ということでね。

(write n3 stdout (test) enum.n3)
;; 0 = (left unit)
;; 1 = (right (left unit))
;; 2 = (right (right (left unit)))
;; 3 = (right (right (right (left unit))))
;;  ...
;; という感じ。

;; (definition nat-inner ()
;;   (sigma ((x nat-enum))
;;     (enum-elimination x
;;       (zero-inner top)
;;       (succ-inner (nat-inner)))))

(let (nat tau) (nat-inner))

(write n3 stdout (test) enum.n3)

(definition nat-helper ((x choice))
  (enum-elimination x
    (left top)
    (right nat)))

;; (write n15 stdout (test) enum.n15)

(let (foo (nat-inner))
  (sigma-introduction left unit))

(keyword zero)

(notation (zero)
  (sigma-introduction left unit))

(ascription (zero) nat)

(keyword succ)

(notation (succ x)
  (sigma-introduction right x))

;; こうするとあたかもsuccがコンストラクタであるかのようにつかえる。
(let (bar (nat-inner))
  (succ foo))

;; ここより前でセグフォ
;; (write n15 stdout (test) enum.n15)

;; ちゃんと推論できてる。えらい。
(let (buz nat)
  (succ bar))

(ascription bar nat)

(ascription buz nat)

;; natの上の関数とかってかけるかな？
;; この引数xについてのパターンマッチをしたい。
;; (definition my-succ ((x nat))
;;   (sigma-elimination
;;     ((selector nat-enum)
;;      (value
;;       (enum-elimination selector
;;         (zero-inner top)
;;         (succ-inner nat))))
;;     x
;;     (enum-elimination selector
;;       (zero-inner top)
;;       (succ-inner bottom))))
(definition top-or-bottom ((x nat))
  (sigma-elimination
    ((cons choice)
     (value (nat-helper cons)))
    x
    (enum-elimination cons
      (left top)
      (right bottom))))
;; こうか。第1成分を取り出してその値がどうなっているかをみて、それに応じた処理を書く。

;; zero-innerのときtopに、そうでないときbottomになる関数。
(ascription top-or-bottom (hom nat tau))

;; (definition my-dec ((x nat))
;;   (sigma-elimination
;;     ((selector nat-enum)
;;      (value (nat-helper selector)))
;;     x
;;     (enum-elimination selector
;;       (zero-inner (zero))
;;       (succ-inner (zero)))))

(definition my-dec ((num nat))
  (sigma-elimination
    ((selector choice)
     (value (nat-helper selector)))
    num
    (enum-elimination selector
      (left (zero))
      ;; 型システムはrightの中身がnatであることを知らないわけだ。だから
      ;; valueを返そうとしても「それtopかもしれないよ！」とエラーを返すことになる。
      ;; これってどう解決すればいいんだ？enum-elimの中ではselectorがrightであるってことの証明が
      ;; 手に入る、みたいな話だろうか？それっぽい？
      ;; enum-elimが変数で分岐してるときを特別扱いする感じ？
      ;; 分岐の中ではselector == rightっていう等式が成立しているわけですが。このselectorの部分は通常は一般の式だからな〜。
      ;; foo @ (bar, buz)とかで分岐されてたら詰むわけじゃん？fooが具体的な関数ならともかく、fooの部分まで引数にとってたりすると、これはもう
      ;; どうにもならないわけじゃん？
      ;; とりあえず等式だけ保持しておいて、で、推論が無理っぽくなったら等式をみてみる、みたいな？
      (right (succ (succ (succ (zero))))))))

(ascription my-dec (hom nat nat))

;; (ascription my-dec
;;   (pi
;;     ((x nat))
;;     nat))

(definition x 10)

(i64.add (i64.add 3 x) x)

;; new.neut ends here
