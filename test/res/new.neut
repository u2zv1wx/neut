(include "notation.neut")

(include "enum.neut")

(include "top.neut")

(include "bottom.neut")

(include "constant.neut")

;; このstateの中でtop-unitが書き換えられてしまう。
;; これは挙動として妥当だろうか？
;; まあ、state.neutがtop-unitをexportしてるって考えれば妥当か。
;; 特定のモジュールがexportしてるものはリストアップされてるはずで。
;; exportしない、みたいなのも指定できるとうれしいかな。
(include "state.neut")

(include "io.neut")

;; もちろん、もう一回includeすれば書き換えの問題は解消される。
(include "top.neut")

(enum choice left right)

(enum three three-0 three-1 three-2)

(constant admit-explicit
  (pi ((A type)) A))

;; (definition foo top-unit)

;; (ascription foo top)

(keyword admit)

(notation admit (admit-explicit hole))

;; 「あ」のutf8-encoding
(definition str ()
  (array-introduction u8
    227
    129
    130))

;; 文字列をunicode encodingされたu8 arrayへと変換して保持
(definition test ()
  "あ")

;; (notation (sigma (xt+) t)
;;   (pi
;;     ((c tau)
;;      (_ (pi (xt+ (_ t)) c)))
;;     c))
(definition utf8-code
  (sigma ((A type) (prf (is-enum A)))
    (array A u8)))

;; 長さがn15になるのがポイントで、ここでunicodeの複雜性が出てくる
;; n15の部分をsigmaで包めばどうにかなりそうな雰囲気はある。
;; string := sigma (A : Univ, prf : is-enum A, str : u8-array A)とかってしておく感じ。
;; で、出力するときはsigma-elimで中身をとりだしてそれぞれをwriteの引数に与える。
;; こうすれば、長さが不明の文字列を扱うことができる。まあ、いけそう。
;; ところで、
;;   (sigma
;;     (A type)
;;     (prf (is-enum A))
;;     (content (u8-array A)))
;; みたいに書けるとうれしいだろうか？案外うれしいかも。

;; out-1
;; (write n3 stdout (test) enum.n3)
(write hole stdout (test) 3)

;; 過剰にwriteするとどうなる？たんに0が入るだけっぽい？
;; 負の数だと？そもそも何も書かれない。
;; (write n3 stdout (test) -3)

;; redefinition of enum-type is disallowed
;; (enum top red blue yellow)

;; redefinition of enum-value is also disallowed
;; (enum yay top)
;; (enum unit yay)
;; (enum yay unit)

;; (definition ひらがなの変数 unit)

;; ひらがなもふつうにつかえる。
(keyword 定義)

(notation 定義 definition)

(定義 ひらがなの変数 unit)

;; (write n15 stdout (test) enum.n15)

;; (write n15 stdout (test) enum.n15)

(definition coproduct ((A tau) (B tau))
  (sigma ((x choice))
    (case x
      (left A)
      (right B))))

(ascription coproduct
  (arrow (tau tau) tau))

(enum nat-enum zero-inner succ-inner)

;; 無限ループしないように修正していく
(definition nat-inner ()
  (sigma ((p choice))
    (case p
      (left top)
      (right (nat-inner)))))
;; こっちなら、sigmaの中身が消えることによって無限ループは生じないはず。……実際、うまくいった。
;; (coproduct top (nat-inner)))
;; sigmaの中でのrecursive callは問題なし、ということでね。

;; out-2
;; (write n3 stdout (test) enum.n3)
;; 0 = (left unit)
;; 1 = (right (left unit))
;; 2 = (right (right (left unit)))
;; 3 = (right (right (right (left unit))))
;;  ...
;; という感じ。

(let (nat tau) (nat-inner))

;; out-3
;; (write n3 stdout (test) enum.n3)

(definition nat-helper ((x choice))
  (enum-elimination x
    (left top)
    (right nat)))

;; (write n15 stdout (test) enum.n15)

(let (foo (nat-inner))
  (sigma-introduction left unit))

(keyword zero)

(notation (zero)
  (sigma-introduction left unit))

(ascription (zero) nat)

(keyword succ)

(notation (succ x)
  (sigma-introduction right x))

;; こうするとあたかもsuccがコンストラクタであるかのようにつかえる。
(let (bar (nat-inner))
  (succ foo))

;; ちゃんと推論できてる。えらい。
(let (buz nat)
  (succ bar))

(ascription bar nat)

(ascription buz nat)

;; natの上の関数とかってかけるかな？
;; この引数xについてのパターンマッチをしたい。
;; (definition my-succ ((x nat))
;;   (sigma-elimination
;;     ((selector nat-enum)
;;      (value
;;       (enum-elimination selector
;;         (zero-inner top)
;;         (succ-inner nat))))
;;     x
;;     (enum-elimination selector
;;       (zero-inner top)
;;       (succ-inner bottom))))
;; (definition top-or-bottom ((x nat))
;;   (sigma-elimination
;;     ((cons choice)
;;      (value (nat-helper cons)))
;;     x
;;     (enum-elimination cons
;;       (left top)
;;       (right bottom))))
;; こうか。第1成分を取り出してその値がどうなっているかをみて、それに応じた処理を書く。

;; zero-innerのときtopに、そうでないときbottomになる関数。
;; (ascription top-or-bottom (hom nat tau))

;; (definition my-dec ((x nat))
;;   (sigma-elimination
;;     ((selector nat-enum)
;;      (value (nat-helper selector)))
;;     x
;;     (enum-elimination selector
;;       (zero-inner (zero))
;;       (succ-inner (zero)))))

(definition my-dec ((num nat))
  (sigma-elimination
    ((selector choice)
     (value (nat-helper selector)))
    num
    (case selector
      (left (zero))
      (right (succ (succ (succ (zero))))))))

(ascription my-dec (hom nat nat))

;; これがパターンマッチの基本をあたえている
;; こっちで与えるべきヒントって何？
;; valueの型がnatであるって書いても、それはselector = rightの情報がないから解けないよね？
(definition my-item ((num nat))
  (sigma-elimination
    ((selector choice)
     (value (nat-helper selector)))
    num
    (case selector
      (left (zero))
      (right value))))

;; こういうmatchのコードはもうふつうにsigma-elimに書き換えることができる。
;; まさに上のように書き換えればいいだけなので。
;; (definition foo ((num nat))
;;   (match num
;;     ((nat.zero _) (zero))
;;     ((nat.succ n) n)))
;; value部分についてのmatchがあったら、という話はあるけど。「atomだったらそこで止めて、nodeだったらcaseで展開」みたいな。

;; こういうのがあっても便利かも：
;;   (enum-with-prefix nat zero succ)
;;   ~> nat = {nat.zero, nat.succ}

(ascription my-item
  (hom nat nat))

;; (constant read
;;   (pi
;;     ((A type)
;;      (in file-descriptor)
;;      (len (is-enum A)))
;;     (product (u8-array A) i64)))

(let bar (str))

;; (write n3 stdout bar enum.n3)

;; (definition buf
;;   (u8-array-introduction
;;     (n12-0 10)
;;     (n12-1 20)
;;     (n12-2 30)
;;     (n12-3 40)
;;     (n12-4 50)
;;     (n12-5 60)
;;     (n12-6 70)
;;     (n12-7 80)
;;     (n12-8 90)
;;     (n12-9 100)
;;     (n12-10 110)
;;     (n12-11 120)))

(definition some-struct
  (struct-introduction
    (3 u8) (10 u8) (100 u16) (3222 u32) (10 i64)))

;; malloc(15)に相当する操作だと言えるかも。initは余計だけどね。
(definition buf
  (struct-elimination
    ((p u8) (q u8) (r u16) (s u32) (t i64))
    some-struct
  (array-introduction u8
    0
    0
    p
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0)))


(write hole stdout buf 3)
;; (write n15 stdout buf enum.n15)

;; (definition a
;;   (read n15 stdin buf enum.n15))

;; (let foo
;;   (sigma-elimination
;;     ((read-content (u8-array n15))
;;      (read-size i64))
;;     a
;;     read-content))

;; こう書けたほうがうれしい？
;; (sigma-elimination a
;;   ((read-content (u8-array n15))
;;    (read-size i64))
;;   (foo)
;;   (let p some-computation)
;;   (let q (pohe p f1 f2 f3))
;;   (bar)
;;   (buz)
;;   (qux)
;;   read-content)

;; (let bar foo)

;; writeは(product (u8-array A) i64)を返している。
;; これはどこでも使用されていないのでfreeされる、という感じ。
;; (write n15 stdout foo enum.n15)

;; (let size
;;   (sigma-elimination
;;     ((p (u8-array n15))
;;      (q i64))
;;     a
;;     q))
;; aのコピーが通ってない？
;; 修正できたっぽい？できた。

;; (write 10 stdout foo 3)とかって書けたほうがラクかな〜？
;; (write n3 stdout foo enum.n3)

;; (write n12 stdout foo enum.n12)

;; (write n20 stdout foo enum.n20)

;; (write n3 stdout (test) enum.n3)

;; (constant open
;;   (pi
;;     ((A type)
;;      (path (u8-array A))
;;      (flags i64)
;;      (mode i64))
;;     (product (u8-array A) file-descriptor)))

;; 0 = rdonly
;; (let file-and-str
;;   (open n32 "/Users/u2zv1wx/Downloads/sample.txt" 0 0))

;; (let file
;;   (sigma-elimination
;;     ((p (array n32 u8))
;;      (q file-descriptor))
;;     file-and-str
;;     q))

;; (let item-and-len
;;   (read n15 file buf enum.n15))

;; (let item
;;   (sigma-elimination
;;     ((read-content (array n15 u8))
;;      (read-size i64))
;;     item-and-len
;;     read-content))

;; マジでファイルを読み書きできるようになってしまった。えらすぎる。
;; writeのバイト数のところはi64で指定するようにしたほうがいいかもしれない。
;; itemの型がわかってるんだから、(write _ stdout item enum.n15)とかでもいけるね。
;; printをこれで定義できるわけだ。
;; (write n15 stdout item enum.n15)

;; (close file)

;; (definition x 10)

;; (i64.add (i64.add 3 x) x)

;; ;; このsizeをみるかぎり、なんかreadじたいはできてるっぽい。byte数がちゃんと得られてる。
;; size

;; (exit 10)

;; ここでもmallocの処理がある。
;; forkしたあとでmallocしたらなんでダメなの？
;; forkはリソースを完全にコピーするんだよね？
;; (i64.add 3 3)
(let pid (fork))

;; ((lambda (pid) pid) (fork))

;; (exit 20)

;; letはクロージャになるから、たしかに、mallocの処理はここで入る。
(fork)

(fork)

;; こうしてu1の配列をつくっても、[u1, u1, u1]とかは結局1byte単位でalignされてしまうから目的の配列を得ることはできない。
;; むしろ[u8, u8, u8]などとする必要がでてくる。
(definition bits ((A type))
  (array A u1))

;; 3が返ってるってことは、0 = stdin, 1 = stdout, 2 = stderrだから、ちゃんとファイルが開けてるはず。
;; file

(definition pohe
  (struct-elimination
    ((p u8) (q u8) (r u16) (s u32) (t i64))
    some-struct
    t))

;; (let result-pair
;;   (array-access-u8 hole buf n15-2))

(let result
  (sigma-elimination
    ((new-buf hole) (value hole))
    (array-access-u8 hole buf n15-2)
    value))

;; (let result
;;   (sigma-elimination
;;     ((new-buf hole) (value hole))
;;     (array-access-u8 hole buf n15-2)
;;     new-buf))

;; statementがあればborrowもいい感じに定義できそう。
;;   (let-borrow result
;;     (array-access-u8 hole buf n15-2))
;; ~>
;;   (let sig (array-access-u8 hole buf n15-2))
;;   (sigma-elimination (buf result) (cont))
;; みたいな。letの代わりにトップレベルのsigma-elimみたいなものが必要になるが。まあ、それはともかく。

;; (exit 100)

;; pidはあくまでparent processのものが返ってくる？
;; pid

(i64.add pid pohe)

;; 変数がenum-elimされてるから依存ありのほうで推論が起こる
;; enum-elimを依存なしにすると普通に推論できる

(definition fact ((n i64))
  (enum-elimination n
    ((i64 1) 1)
    (default (i64.mul n (fact (i64.sub n 1))))))

;; こっちなら推論できる。これはつまり、なんというか、情報を与えればenum-elimをいじらなくても推論可能ってこと？
;; でもさ、defaultのほうの結果がi64で確定してるんだから、1のほうがi64であることも本来はわかるはずじゃない？
;; (definition fact ((n i64))
;;   (enum-elimination n
;;     ((i64 1)
;;       (begin
;;         (let (x i64) 1)
;;         x))
;;     (default (i64.mul n (fact (i64.sub n 1))))))

;; (ascription fact
;;   (pi
;;     ((n i64))
;;     i64))

;; (write hole stdout result 15)

;; 3になるはずなんですけど。実行のたびに異なる結果が返ってくる。
;; たぶんmallocしたどっかのアドレスを間違って参照してるんだけど。なんでだ？
;; わかった。取得した3みたいなのをポインタとして理解してしまってるからおかしいんだ、これ。
;; 修正できた。いいね。
;; result

n15-4

(fact 5)

;; new.neut ends here
