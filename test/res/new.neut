(include "notation.neut")

;; (include "enum.neut")

(include "top.neut")

(include "bottom.neut")

(enum bool true false)

(include "constant.neut")

;; このstateの中でtop-unitが書き換えられてしまう。
;; これは挙動として妥当だろうか？
;; まあ、state.neutがtop-unitをexportしてるって考えれば妥当か。
;; 特定のモジュールがexportしてるものはリストアップされてるはずで。
;; exportしない、みたいなのも指定できるとうれしいかな。
(include "state.neut")

(include "io.neut")

;; もちろん、もう一回includeすれば書き換えの問題は解消される。
(include "top.neut")


(enum choice left right)

(enum three three-0 three-1 three-2)

;; (mode choice (left right))

;; (mode X (a b c))

;; (mode blood (blood-A blood-B blood-O blood-AB))

;; (mode weather (sunny rainy cloudy))

;; こういうのはあまりmodeじゃないよな。
;; (mode fruit (apple banana orange melon))

;; こっちのほうが素直か〜〜。

;; (enum fruit (apple banana orange melon))

;;--
;; collectionはけっこういい気がする？でも内部に構造がない点のあつまりであるっていうニュアンスが出ない。……そしてそれは "set" っていう言葉に対しても同じことが言えるだろう。そう考えるとやっぱりenumかなあという気がしてくる。ところで「--」方式のコメントも許可したいところではある。
;;
;; そのほうがこんなふうに改行をいい感じにとりあつかえたりして嬉しい。こっちのほうが書いていてラクというか。普通のテキストファイルのときと同じように言葉を書くことができるってのがどれだけ快適なことであるのか、人類はまだ知らないのである。論文を書くようにしてプログラムを書くことができる、ということ。
;;
;; parserのほうの処理自体はたぶんカンタンなんだけど。シンタックスハイライトをどう定義すればいいのかがわからない。emacsの話ね。……regexpでよさそう。
;;--

;; (collection fruit (apple banana orange melon))

;; セマンティクスになるべく対応させたsyntax、みたいな。
;; (enum choice
;;   ((left 0)
;;    (right 1)))
;; まあenumになるのか〜〜〜。

;; --
;; まあ、じゃあそういう感じでやっていくことになるのかなあ。enumでやっていくということになるのかしら。まあ標準的であるってことの強さだよな〜。
;;
;; --
;; (constant admit-explicit
;;   (pi ((A type)) A))

;; (definition foo top-unit)

;; (ascription foo top)

;; (keyword admit)

;; (notation admit (admit-explicit hole))

;; 「あ」のutf8-encoding
(definition str ()
  (array-introduction u8
    227
    129
    130))


;; 文字列をunicode encodingされたu8 arrayへと変換して保持
;; なんかこのtestがn3に推論されてるんですが？？
(definition test ()
  "あ")

;; (notation (sigma (xt+) t)
;;   (pi
;;     ((c tau)
;;      (_ (pi (xt+ (_ t)) c)))
;;     c))

;; このときはたしかに、is-enumによってutf8-codeは長さの情報を保持することができている。
;; (definition utf8-code
;;   (sigma
;;     ((A type)
;;      (prf (is-enum A)))
;;     (array A u8)))

;; (definition utf8-code
;;   (sigma
;;     (A type)
;;     (prf (is-enum A))
;;     (_ (array A u8))))

;; 長さがn15になるのがポイントで、ここでunicodeの複雜性が出てくる
;; n15の部分をsigmaで包めばどうにかなりそうな雰囲気はある。
;; string := sigma (A : Univ, prf : is-enum A, str : u8-array A)とかってしておく感じ。
;; で、出力するときはsigma-elimで中身をとりだしてそれぞれをwriteの引数に与える。
;; こうすれば、長さが不明の文字列を扱うことができる。まあ、いけそう。
;; ところで、
;;   (sigma
;;     (A type)
;;     (prf (is-enum A))
;;     (content (u8-array A)))
;; みたいに書けるとうれしいだろうか？案外うれしいかも。

;; out-1
;; (write n3 stdout (test) enum.n3)
(write hole stdout (test) 3)

(definition string
  (sigma
    ((A type))
    (array A u8)))

(let (str-with-len string)
  (sigma-introduction n3 (test)))

;; (let str-with-len
;;   (with-type string (sigma-introduction n3 (test))))

;; (definition string
;;   (sigma
;;     (index type)
;;     (content (array index u8))))

;; test : Pi (). stringとの一致が問題になってる？


;; こっちでは、(n3, [p, q, r])みたいな感じで。
;; 型としては長さの情報があるけど、termとしては長さの情報がない、という状況。
;; 別にwriteだってできてるんだしこれでよくね、という感じが……？

(ascription str-with-len string)
  ;; (sigma
  ;;   ((A type))
  ;;   (array A u8))

;; これで長さ不明の文字列を出力することができる
;; (sigma-elimination
;;   ((n type) (content (array n u8)))
;;   str-with-len
;;   (write n stdout content 3)
;;   unit)

;; dependent sigma elimができるってのは、この結果のwriteを「返せる」っていうこと。それはまあ、ヤバそう。
;; strをそのまま返す、みたいなことをしてもよいのかも？
;; それにはwrite-stringを定数として定義する必要があるけどね。
(definition write-string ((str string))
  (sigma-elimination
    ((n type) (content (array n u8)))
    str
    (begin
      (write n stdout content 3)
      unit)))

(ascription write-string
  (hom string top))

(write-string str-with-len)

(write-string str-with-len)

;; 過剰にwriteするとどうなる？たんに0が入るだけっぽい？
;; 負の数だと？そもそも何も書かれない。
;; (write n3 stdout (test) -3)

;; redefinition of enum-type is disallowed
;; (enum top red blue yellow)

;; redefinition of enum-value is also disallowed
;; (enum yay top)
;; (enum unit yay)
;; (enum yay unit)

;; (definition ひらがなの変数 unit)

;; ひらがなもふつうにつかえる。
(keyword 定義)

(notation 定義 definition)

(定義 ひらがなの変数 unit)

;; (write n15 stdout (test) enum.n15)

;; (write n15 stdout (test) enum.n15)

;; (definition coproduct ((A tau) (B tau))
;;   (sigma
;;     (selector choice)
;;     (content
;;      (case selector
;;        (left A)
;;        (right B)))))

(definition coproduct ((A tau) (B tau))
  (sigma
    ((x choice))
    (case x
      (left A)
      (right B))))

;; (ascription coproduct
;;   (arrow (tau tau) tau))

(ascription coproduct
  (pi ((_ tau) (_ tau)) tau))

(enum nat-enum zero-inner succ-inner)

;; (mode nat-mode
;;   nat-mode.zero
;;   nat-mode.succ)

;; --
;; なんかしらの文章。

;; --
;; (mode top unit)
;; --
;; ここにまたなんかしらの文章。topはただひとつのmode-valueからなるmodeである、みたいな。


;; --

;; 無限ループしないように修正していく
;; こういうときはsigmaが(sigma ((x1 A1) ... (xn An)) B)って形式になってるほうがうれしい。
;; 他方、stringのときとかは(sigma (x1 A1) ... (xn An))のほうがうれしい。
;; 型理論的に正気なのはSigma (x1 : A1, ..., xn : An). Bだろうしこっちを基本にするか〜。
;; (definition nat-inner ()
;;   (sigma
;;     (selector choice)
;;     (content
;;       (case selector
;;         (left top)
;;         (right (nat-inner))))))

(definition nat-inner ()
  (sigma
    ((p choice))
    (case p
      (left top)
      (right (nat-inner)))))


;; こっちなら、sigmaの中身が消えることによって無限ループは生じないはず。……実際、うまくいった。
;; (coproduct top (nat-inner))
;; sigmaの中でのrecursive callは問題なし、ということでね。

;; out-2
;; (write n3 stdout (test) enum.n3)
;; 0 = (left unit)
;; 1 = (right (left unit))
;; 2 = (right (right (left unit)))
;; 3 = (right (right (right (left unit))))
;;  ...
;; という感じ。

;; (mode color red blue yellow)

;; (mode suit
;;   club diamond heart spade)

(let (local-nat tau) (nat-inner))

;; (definition nat)

;; out-3
;; (write n3 stdout (test) enum.n3)

(definition nat-helper ((x choice))
  (enum-elimination x
    (left top)
    (right local-nat)))

;; (write n15 stdout (test) enum.n15)

(let (foo (nat-inner))
  (sigma-introduction left unit))

;; (definition zero
;;   (sigma-introduction left unit))
;; (keyword zero)

;; (notation (zero)
;;   (sigma-introduction left unit))

;; (ascription zero nat)

;; (keyword succ)

;; (notation (succ x)
;;   (sigma-introduction right x))

;; 関数として定義したほうがよくね。
;; (definition succ ((x nat))
;;   (sigma-introduction right x))

;; (ascription succ
;;   (hom nat nat))

;; こうするとあたかもsuccがコンストラクタであるかのようにつかえる。
;; (let (bar (nat-inner))
;;   (succ foo))

;; ちゃんと推論できてる。えらい。
;; (let (buz nat)
;;   (succ bar))

;; (ascription bar nat)

;; (ascription buz nat)

;; natの上の関数とかってかけるかな？
;; この引数xについてのパターンマッチをしたい。
;; (definition my-succ ((x nat))
;;   (sigma-elimination
;;     ((selector nat-enum)
;;      (value
;;       (enum-elimination selector
;;         (zero-inner top)
;;         (succ-inner nat))))
;;     x
;;     (enum-elimination selector
;;       (zero-inner top)
;;       (succ-inner bottom))))
;; (definition top-or-bottom ((x nat))
;;   (sigma-elimination
;;     ((cons choice)
;;      (value (nat-helper cons)))
;;     x
;;     (enum-elimination cons
;;       (left top)
;;       (right bottom))))
;; こうか。第1成分を取り出してその値がどうなっているかをみて、それに応じた処理を書く。

;; zero-innerのときtopに、そうでないときbottomになる関数。
;; (ascription top-or-bottom (hom nat tau))

;; (definition my-dec ((x nat))
;;   (sigma-elimination
;;     ((selector nat-enum)
;;      (value (nat-helper selector)))
;;     x
;;     (enum-elimination selector
;;       (zero-inner (zero))
;;       (succ-inner (zero)))))

;; (definition my-dec ((num nat))
;;   (sigma-elimination
;;     ((selector choice)
;;      (value (nat-helper selector)))
;;     num
;;     (case selector
;;       (left (zero))
;;       (right (succ (succ (succ (zero))))))))

;; 普通に関数として書いたら推論できたわ。なんでわざわざnotationでやってたんだ。
;; 関数として書いたほうが推論できるものが増えてうれしい、ってことがわかる。
;; このへんのsigmaによるあれはもう不要で、というのは、inductive/coinductiveが定義できたから。
;; (definition my-dec ((num nat))
;;   (sigma-elimination
;;     ((selector choice)
;;      (value (nat-helper selector)))
;;     num
;;     (case selector
;;       (left zero)
;;       (right (succ (succ (succ zero)))))))

;; (definition my-dec ((num nat))
;;   (sigma-elimination
;;     ((selector choice)
;;      (value (nat-helper selector)))
;;     num
;;     (case selector
;;       (left (zero))
;;       (right (with-type nat (succ (succ (succ (zero)))))))))

;; (succ (succ (succ (zero))))とかの型がnatじゃないなにかに推論されてるっぽいが？

;; (definition my-dec ((num nat))
;;   (sigma-elimination
;;     ((selector choice)
;;      (value (nat-helper selector)))
;;     num
;;     (case selector
;;       (left (with-type nat (zero)))
;;       (right (with-type nat (succ (succ (succ (zero)))))))))

;; (ascription my-dec (hom nat nat))

;; これがパターンマッチの基本をあたえている
;; こっちで与えるべきヒントって何？
;; valueの型がnatであるって書いても、それはselector = rightの情報がないから解けないよね？
;; というかこっちが推論できてなんでmy-decが推論できないんだ？
;; (definition my-item ((num nat))
;;   (sigma-elimination
;;     ((selector choice)
;;      (value (nat-helper selector)))
;;     num
;;     (case selector
;;       (left zero)
;;       (right value))))

;; (ascription my-item
;;   (hom nat nat))

;; こういうmatchのコードはもうふつうにsigma-elimに書き換えることができる。
;; まさに上のように書き換えればいいだけなので。
;; (definition foo ((num nat))
;;   (match num
;;     ((nat.zero _) (zero))
;;     ((nat.succ n) n)))
;; value部分についてのmatchがあったら、という話はあるけど。「atomだったらそこで止めて、nodeだったらcaseで展開」みたいな。

;; こういうのがあっても便利かも：
;;   (enum-with-prefix nat zero succ)
;;   ~> nat = {nat.zero, nat.succ}


;; (constant read
;;   (pi
;;     ((A type)
;;      (in file-descriptor)
;;      (len (is-enum A)))
;;     (product (u8-array A) i64)))

(let bar (str))

;; (write n3 stdout bar enum.n3)

;; (definition buf
;;   (u8-array-introduction
;;     (n12-0 10)
;;     (n12-1 20)
;;     (n12-2 30)
;;     (n12-3 40)
;;     (n12-4 50)
;;     (n12-5 60)
;;     (n12-6 70)
;;     (n12-7 80)
;;     (n12-8 90)
;;     (n12-9 100)
;;     (n12-10 110)
;;     (n12-11 120)))

(definition some-struct
  (struct-introduction
    (3 u8) (10 u8) (100 u16) (3222 u32) (10 i64)))

;; malloc(15)に相当する操作だと言えるかも。initは余計だけどね。
(definition buf
  (struct-elimination
    ((p u8) (q u8) (r u16) (s u32) (t i64))
    some-struct
  (array-introduction u8
    0
    0
    p
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0)))

(write hole stdout buf 3)
;; (write n15 stdout buf enum.n15)

;; (definition a
;;   (read n15 stdin buf enum.n15))

;; (let foo
;;   (sigma-elimination
;;     ((read-content (u8-array n15))
;;      (read-size i64))
;;     a
;;     read-content))

;; こう書けたほうがうれしい？
;; (sigma-elimination a
;;   ((read-content (u8-array n15))
;;    (read-size i64))
;;   (foo)
;;   (let p some-computation)
;;   (let q (pohe p f1 f2 f3))
;;   (bar)
;;   (buz)
;;   (qux)
;;   read-content)

;; (let bar foo)

;; writeは(product (u8-array A) i64)を返している。
;; これはどこでも使用されていないのでfreeされる、という感じ。
;; (write n15 stdout foo enum.n15)

;; (let size
;;   (sigma-elimination
;;     ((p (u8-array n15))
;;      (q i64))
;;     a
;;     q))
;; aのコピーが通ってない？
;; 修正できたっぽい？できた。

;; (write 10 stdout foo 3)とかって書けたほうがラクかな〜？
;; (write n3 stdout foo enum.n3)

;; (write n12 stdout foo enum.n12)

;; (write n20 stdout foo enum.n20)

;; (write n3 stdout (test) enum.n3)

;; (constant open
;;   (pi
;;     ((A type)
;;      (path (u8-array A))
;;      (flags i64)
;;      (mode i64))
;;     (product (u8-array A) file-descriptor)))

;; 0 = rdonly
;; これを使うとコンパイルが異様に遅くなる。なんでだろう？
;; (let file-and-str
;;   (open n32 "/Users/u2zv1wx/Downloads/sample.txt" 0 0))

    ;; (product (array A u8) file-descriptor)

;; (ascription file-and-str
;;   (product (array n32 u8) file-descriptor))

;; (let file
;;   (sigma-elimination
;;     ((p (array n32 u8))
;;      (q file-descriptor))
;;     file-and-str
;;     q))

;; (let item-and-len
;;   (read n15 file buf 15))
;; (let item-and-len
;;   (read n15 file buf enum.n15))

;; (let item
;;   (sigma-elimination
;;     ((read-content (array n15 u8))
;;      (read-size i64))
;;     item-and-len
;;     read-content))

;; マジでファイルを読み書きできるようになってしまった。えらすぎる。
;; writeのバイト数のところはi64で指定するようにしたほうがいいかもしれない。
;; itemの型がわかってるんだから、(write _ stdout item enum.n15)とかでもいけるね。
;; printをこれで定義できるわけだ。
;; (write n15 stdout item enum.n15)
;; (write n15 stdout item 15)

;; (close file)

;; (definition x 10)

;; (i64.add (i64.add 3 x) x)

;; ;; このsizeをみるかぎり、なんかreadじたいはできてるっぽい。byte数がちゃんと得られてる。
;; size

;; (exit 10)

;; ここでもmallocの処理がある。
;; forkしたあとでmallocしたらなんでダメなの？
;; forkはリソースを完全にコピーするんだよね？
;; (i64.add 3 3)
(let pid (fork))

;; ((lambda (pid) pid) (fork))

;; (exit 20)

;; letはクロージャになるから、たしかに、mallocの処理はここで入る。
(fork)

(fork)

;; こうしてu1の配列をつくっても、[u1, u1, u1]とかは結局1byte単位でalignされてしまうから目的の配列を得ることはできない。
;; むしろ[u8, u8, u8]などとする必要がでてくる。
(definition bits ((A type))
  (array A u1))

;; 3が返ってるってことは、0 = stdin, 1 = stdout, 2 = stderrだから、ちゃんとファイルが開けてるはず。
;; file


(definition pohe
  (struct-elimination
    ((p u8) (q u8) (r u16) (s u32) (t i64))
    some-struct
    t))

;; (let result-pair
;;   (array-access-u8 hole buf n15-2))

(let result
  (sigma-elimination
    ((new-buf hole) (value hole))
    (array-access-u8 hole buf n15-2)
    value))

;; (let result
;;   (sigma-elimination
;;     ((new-buf hole) (value hole))
;;     (array-access-u8 hole buf n15-2)
;;     new-buf))

;; statementがあればborrowもいい感じに定義できそう。
;;   (let-borrow result
;;     (array-access-u8 hole buf n15-2))
;; ~>
;;   (let sig (array-access-u8 hole buf n15-2))
;;   (sigma-elimination (buf result) (cont))
;; みたいな。letの代わりにトップレベルのsigma-elimみたいなものが必要になるが。まあ、それはともかく。

;; (exit 100)

;; pidはあくまでparent processのものが返ってくる？
;; pid

(i64.add pid pohe)

;; 変数がenum-elimされてるから依存ありのほうで推論が起こる
;; enum-elimを依存なしにすると普通に推論できる

;; ここが推論できないのは、enum-elimで依存がありうるってことになってるから。
;; (definition fact ((n i64))
;;   (enum-elimination n
;;     ((i64 1) 1)
;;     (default (i64.mul n (fact (i64.sub n 1))))))

;; (definition fact ((n i64))
;;   (enum-elimination n
;;     ((i64 1) 1)
;;     (default (i64.mul n (with-type i64 (fact (i64.sub n 1)))))))

;; allow weakcase
;; (definition fact ((n i64))
;;   (enum-elimination n
;;     (1 1) ;; weak case (i64 1)
;;     (default (i64.mul n (with-type i64 (fact (i64.sub n 1)))))))

(definition fact ((n i64))
  (enum-elimination n
    (1 1) ;; weak case (don't have to write `(i64 1)`)
    (default (i64.mul n (fact (i64.sub n 1))))))

(ascription fact (hom i64 i64))

;; こっちなら推論できる。これはつまり、なんというか、情報を与えればenum-elimをいじらなくても推論可能ってこと？
;; でもさ、defaultのほうの結果がi64で確定してるんだから、1のほうがi64であることも本来はわかるはずじゃない？
;; (definition fact ((n i64))
;;   (enum-elimination n
;;     ((i64 1)
;;       (begin
;;         (let (x i64) 1)
;;         x))
;;     (default (i64.mul n (fact (i64.sub n 1))))))

;; (ascription fact
;;   (pi
;;     ((n i64))
;;     i64))

;; (write hole stdout result 15)

;; 3になるはずなんですけど。実行のたびに異なる結果が返ってくる。
;; たぶんmallocしたどっかのアドレスを間違って参照してるんだけど。なんでだ？
;; わかった。取得した3みたいなのをポインタとして理解してしまってるからおかしいんだ、これ。
;; 修正できた。いいね。
;; result

n15-4

;; (definition foo ((x hole)) x)

;; (ascription foo (hom nat hole))

;; (定義 ご 5)

;; (fact ご)

(fact 5)

   ;; (fact  top  )




;; ほんとはここにエラーが表示されるべきなのに別な場所に流れる
;; ~> 修正した。ちゃんと適切な場所にエラーが表示されるようになった。
;; (fact zero)

(definition pohe
  (sigma-introduction left unit))

;; (ascription pohe (sigma ((x choice)) top))

;; (fact pohe  )

;; type error:
;; (fact (begin (lambda ((A type) (y A)) y)))

;; 型のなかに出現するnatの定義を展開せずにそのままnatとして表示できていてうれしい、って話。
;; (fact (begin (lambda ((y nat)) y)))
;; エラーをflycheckで表示できるようになったぜ。イエーイ。

;; (definition nat-direct ()
;;   (sigma
;;    ((p choice))
;;     (case p
;;       (left top)
;;       (right (nat-direct)))))

;; (definition g ((y nat)) y)


;; 相互再帰を実装した。いいね。
;; definitionの一般化としてとれてるところが偉い。
(definition
  ((p (hom i64 i64)) ((a i64)) (q a)) ;; こんなかんじでascriptionを与えると推論がすぐ終わる。
  (q ((y i64)) (with-type i64 (p y)))
  (r ((z i64)) (p z))
  (s ((z i64)) (p z))
  (t ((z i64)) (p z))
  (u ((z i64)) (p z))
  (v ((z i64)) (p z))
  (w ((z i64)) (p z))
  (x ((z i64)) (p z))
  (y ((z i64)) (p z))
  (z ((z i64)) (p z))
  (a ((z i64)) (y z)))

;; 0要素のdefinitionも合法
(definition)

;; implicit beginもちゃんと処理できてる。
(definition loo ((x i64))
  (let y x)
  (let long-long-name y)
  (let longer-name long-long-name)
  (let longest-longest-name longer-name)
  (let longest-name i64.add i64.sub)
  longest-longest-name)

(definition foo ((x i64))
  (let y x)
  y)

(let foo
  (lambda ((x i64)) ((lambda ((y hole)) y) x)))

;; これはxのほうにunderlineがきてほしいような。
;; natの定義が展開されるときに後ろに情報がながれてるって話か。
;; (definition foo ((x i64)) x)


;; (ascription foo (hom i64 nat))

;; homでascriptionを与えたときに依存がないって情報を反映できるとうれしい？
;; holeでcontextをextendするのは依存がないって情報を与えるのと同じことか。
(ascription p (hom i64 i64))

(ascription q (hom i64 i64))

;; (ascription q (hom i64 (lambda ((x i64)) x)))

;; 次のように書くと推論にけっこう時間がかかる。flexをめっちゃ試したりしてるのかな？
;; そのとおりだった。
;; まあ、型エラーの推論のときはtimeoutをとってもいいな。
;; (ascription a (hom i64 tau))

;; 一番簡単なinductive typeの処理
(inductive nat ()
  (nat.zero () (nat))
  (nat.succ ((n (nat))) (nat)))

;; (inductive nat ()
;;   (nat.zero () (nat))
;;   (nat.succ ((n (nat))) (nat)))

;; 引数ありのinductive typeの処理


(inductive list ((A tau))
  (list.nil () (list A))
  (list.cons ((_ A) (_ (list A))) (list A)))

(inductive LIST ((A tau))
  (LIST.nil () (LIST A))
  (LIST.cons ((_ A) (_ (LIST A))) (LIST A)))

(inductive TEST ((A tau))
  (TEST.nil () (TEST A))
  (TEST.cons ((_ A) (_ (TEST A))) (TEST A)))

(inductive mylist ((A tau) (B tau))
  (mylist.nil () (mylist A B))
  (mylist.cons ((_ A) (_ (mylist A B))) (mylist A B)))


;; 量化された引数の部分はpiで包まないといけない（でないと全体で共有されてしまうので固定になる）
;; つまり、inductiveの引数は「そこを固定して」ってことなんだな。
(inductive vec ((A tau) (n (nat)))
  (vec.nil () (vec A (nat.zero)))
  (vec.cons ((m (nat)) (_ A) (_ (vec A m))) (vec A (nat.succ m))))

;; こっちはwell-typed
;; (inductive my-vec ((A tau) (n (nat)))
;;   (vec-zero () (my-vec A (zero))))

;; (inductive my-vec ((A tau) (n (nat)))
;;   (vec-cons ((_ A) (_ (my-vec A n))) (my-vec A (succ n))))

;; (i64.add 100 (vec.cons i64 (nat.zero) (nat.zero) 10 (vec.nil i64 (nat.zero))))

;; こんな感じでvecも使える。
;; あれ？ここは型エラーになるべきでは？
;; いや、vecのこの引数のほうは「どうでもいいやつ」だから関係ない。いわばパラメータの部分なので。
;; このときはaの型はちゃんとvec i64 (nat.zero)になってる。
(let a (vec.nil i64 (nat.succ (nat.zero))))


(inductive item ((A tau))
  (item.intro () (item A))
  ;; (item.cont0 ((_ (item A)) (_ (list (list (item A))))) (item A))

  (item.cont0 ((_ (item A)) (_ (LIST (TEST (list (item A)))))) (item A))
  (item.cont1 ((_ (item A)) (_ (list (item A)))) (item A))
  (item.cont5 ((_ (item A)) (_ (LIST (list (item A))))) (item A))
  ;; (item.cont0 ((_ (item A)) (_ (LIST (list (item A))))) (item A))
  (item.cont6 ((_ (item A)) (_ (TEST (list (item A))))) (item A))
  (item.cont7 ((_ (item A)) (_ (LIST (TEST (item A))))) (item A))
  ;; (item.cont10 ((_ (item A)) (_ (list (TEST (item A))))) (item A))
  ;; (item.cont0 ((_ (item A)) (_ (LIST (LIST (item A))))) (item A))
  ;; (item.cont1 ((_ (item A)) (_ (list (list (item A))))) (item A))
  ;; (item.cont1 ((_ (item A)) (_ (list (list (item A))))) (item A))
  (item.cont2 ((_ A) (_ (item A))) (item A)))

;; (inductive item ((A tau))
;;   (item.intro () (item A))
;;   (item.cont ((_ (item A)) (_ (list (item A)))) (item A))
;;   (item.cont2
;;     ((_ A)
;;      (_ (pi
;;           ((_ (pi ((_ (item A))) i64)))
;;            (item A))))
;;     (item A))
;;   (item.dom-sig ((_ (sigma ((_ (item A))) (item A)))) (item A))
;;   ;; (item.cont3 ((_ A) (_ (pi ((_ (item A))) (item A)))) (item A))
;;   (item.cont1 ((_ (item A))
;;                (_ (list (list (item A))))
;;                (_ (list (mylist (item A) i64)))
;;                (_ A)
;;                (_ (nat))
;;                (_ i64))
;;               (item A)))


(coinductive stream ((A tau))
  (stream.head ((_ (stream A))) A)
  (stream.tail ((_ (stream A))) (stream A)))

;; (i64.add stream.coinduction 3)

;; (coinductive stream ((A tau))
;;   (stream.head ((_ (stream A))) A)
;;   (stream.tail ((_ (stream A))) (stream A)))

;; これも通った
(coinductive modified-stream ((A tau))
  (modified-stream.head ((_ (modified-stream A))) A)
  (modified-stream.tail ((_ (modified-stream A))) (stream (list (stream (modified-stream A))))))

;; (coinductive nested-stream ((A tau))
;;   (nested-stream.head ((_ (nested-stream A))) A)
;;   (nested-stream.tail ((_ (nested-stream A))) (stream (stream (nested-stream A)))))

(coinductive nested-stream ((A tau))
  (nested-stream.head ((_ (nested-stream A))) A)
  (nested-stream.tail ((_ (nested-stream A))) (list (stream (nested-stream A)))))

;; これも通る。えらすぎる。
(coinductive list-stream ((A tau))
  (list-stream.head ((_ (list-stream A))) A)
  (list-stream.tail ((_ (list-stream A))) (list (list-stream A))))

;; identity type
(inductive identity ((A tau) (x A) (y A))
  (identity.reflexive ((a A)) (identity A a a)))

;; enumよりもmodeのほうがキーワードとしてよさそう。

;; (mode bool false true) ;; true should be 1, false should be 0

;; (mode choice left right)

;; (mode top unit)

;; (mode item
;;   foo
;;   bar
;;   buz)

;; (mode ionian c d e f g a b)

;; (mode C-Dorian C D Eb F G A Bb)

;; (mode-elimination some-item
;;   (left foo)
;;   (bar hoge))

;; ;; from C3
;; ;; modeに応じた処理の分岐
;; (switch C-ionian
;;   (C "261Hz")
;;   (D "277Hz")
;;   ...
;;   (A "440Hz")
;;   (B "498Hz"))

;; (inductive bool ()
;;   (bool.true () (bool))
;;   (bool.false () (bool)))

;; (inductive sample ((A tau))
;;   (sample.true () (sample A))
;;   (sample.false () (sample A)))

;; (inductive sample ((b (bool)))
;;   (sample.true () (sample (bool.true)))
;;   (sample.false () (sample (bool.false))))
;; induction principleを自動生成できるようにした。これでnatの内部実装を気にせずにnatを利用できるようになる。
;; (i64.add 100 (nat.succ unit))

;; (let list.recursion.helper
;;   hole
;;   (lambda ((y hole)
;;            (xs (list i64)))
;;     (list.induction
;;       hole
;;       hole
;;       (lambda ()
;;         (sigma-introduction FOO (list.nil i64)))
;;       (lambda ((x hole) (p (sigma ((_ hole)) hole)))
;;         (sigma-elimination
;;           ((acc hole)
;;            (ys hole))
;;           p
;;           (sigma-introduction BAR (list.cons i64 x xs))))
;;       (sigma-introduction xs (list.nil i64)))))

;; k y xs := fold (\x (acc, xs) -> (g y x xs acc, x : xs)) (f y, [])

;; (i64.add 100 list.induction)

;; identity typeのelimination:
;; (i64.add 100 identity.induction)

;; (i64.add 100 bool.true)

;; (Π ((B (Π () tau))
;;     (ON_TRUE (Π () (B)))
;;     (ON_FALSE (Π () (B)))
;;     (VALUE (bool)))
;;   (B))
;; (let my-bool-induction
;;   (pi ((F (pi (_ (bool)) tau))
;;        (b (bool))
;;        (_ (F (bool.true)))
;;        (_ (F (bool.false))))
;;       (F b))
;;   (lambda ((F (pi (_ (bool)) tau))
;;            (b (bool))
;;            (t (F (bool.true)))
;;            (f (F (bool.false))))
;;     (bool.induction
;;       (lambda () (F b))
;;       (lambda () t) ;; ここだよな〜〜。tと書くと(F (bool.true))になってしまう。実際にはこれで問題ないんだけど（b = trueのときしか呼ばれないので）。
;;       (lambda () f)
;;       b)))
;; 「b = trueのときしか呼ばれない」ってのを利用して強いinduction principleを用意するってのがありうるな。
;; Π (F : bool → Type) (b : bool),
;;   F bool.true →
;;   F bool.false →
;;   F b

;; (let not
;;   (pi ((_ (bool)))
;;     (bool))
;;   (lambda ((b (bool)))
;;     (bool.induction
;;       (lambda () (bool))
;;       bool.false
;;       bool.true
;;       b)))

(definition mysig
  (sigma
    ((A tau))
    (pi ((_ A)) A)))

(let foo
  mysig
  (sigma-introduction i64 (lambda ((x i64)) x)))

;; (let bar
;;   (sigma-elimination
;;     ((A tau)
;;      (x2 (pi ((_ A)) A)))
;;     foo
;;     x2))

;; (let foo (not (not (b))))

;; (Π ((B (Π () (tau 6602)))
;;     (ON_TRUE (Π () (B)))
;;     (ON_FALSE (Π () (B)))
;;     (VALUE (bool)))
;;   (B))

;; (let test
;;   (bool.induction
;;     (lambda () tau)
;;     ;; (lambda () top)
;;     (lambda () (identity (bool) (not (not (bool.true))) (bool.true)))
;;     ;; (lambda () (identity (bool) (not (not (bool.true)))) (bool.true))
;;     (lambda () (identity (bool) (not (not (bool.false))) (bool.false)))
;;     ;; (lambda () (identity (bool) (not (not (bool.false)))) (bool.false))
;;     (bool.true)))

;; これは(bool.true) = bとかが不明ってことでエラーになる。
;; 原因はなに？どうすれば修正できるだろう？
;; branchごとに値が実際には具体化されてるんだけど、それを型システムのほうで表現できていないのが原因。

;; (theorem 3.2.2-flip-true
;;   (identity (bool) (not (not (bool.true))) (bool.true))
;;   (identity.reflexive (bool) (bool.true) (bool.true) (bool.true)))

;; 定理の名前を番号だけにするとなんか論文とかとそのまんまの対応がとれてうれしいかも。
;; (theorem 3.2.3
;;   (forall ((b (bool)))
;;     (identity (bool) (not (not b)) b))
;;   (assume ((b (bool)))
;;     (bool.induction
;;       (lambda () (identity (bool) (not (not b)) b))
;;       (lambda () (identity.reflexive (bool) b b b))
;;       (lambda () (identity.reflexive (bool) b b b))
;;       b)))

;; coinduction principleも自動生成できるようにした。偉すぎる。
;; (i64.add 1000 stream.coinduction)


(i64.add 100 (i64 10))

;; (.add 100 10)

(u32.add 22 23)

;; (i64.add 100 (unsafe-cast f32 i64 10.25))

;; (i64.add 100 (unsafe-cast (bool) i64 (bool.true)))

;; (fact 4)

;; (i64 10)
(f32 10.3)

(fact 5)

(u8.add 200 200) ;; ~> 144 (overflow)

(u1.sub 1 0)

;; (u32.add 200 300)

;; 初期値付きのenum
;; (enum test
;;   foo
;;   bar
;;   (buz 10)
;;   qux
;;   (pohe 100)
;;   popo)

;; bar

;; popo
;; (i64.add 3 0)

;; ここのエラーでnatの型を開かずに済ませたいところ。
;; でないと型エラーが読めたものではなくなる。
;; nat = topが解けないと知るためにはどうすればよいか？
;; (g (lambda ((x nat)) x))

;; (Σ ((p choice))
;;   (case p
;;     (left top)
;;     (right
;;      ((μ nat-direct ()
;;         (Σ ((p choice))
;;           (case p
;;             (left top)
;;             (right (nat-direct)))))))))


;; メタ変数とかを適切にrenameしたうえでエラーとして表示する、ってことのチェック。
;; (fact (top 100))


;; こんな感じで相互再帰を書くことになる。
;; (mutual-definition
;;   (even ((x1 tau) (foo nat)) admit)
;;   (odd ((A tau) (y2 A)) admit))

;; こう書けたほうがうれしい？そうでもないか？
;; 素直な感じはする。
;; いつものdefinitionをこっちの特殊ケースとしてとるとよさそう。
;; (definition
;;   (even ((x1 tau) (foo nat))
;;     admit)
;;   (odd ((A tau) (y2 A))
;;     admit))

;; こっちのほうが素直かなー。
;; (mutual-definition
;;   (even ((x1 tau) (foo nat))
;;     (let x foo)
;;     (let y bar)
;;     (return admit))
;;   (odd ((A tau) (y2 A))
;;     admit))

;; キーワードをたくさん使うコース。微妙。
;; (mutual
;;   (definition even ((x1 tau) (foo nat))
;;     (let x foo)
;;     (let y bar)
;;     (return admit))
;;   (definition odd ((A tau) (y2 A))
;;     admit))

;; これはなんか欠けてる感じがするよな。
;; (mutual
;;   (even ((x1 tau) (foo nat))
;;     (let x foo)
;;     (let y bar)
;;     (return admit))
;;   (odd ((A tau) (y2 A))
;;     admit))

;; 敢えての倒置
;; (definition-mutual
;;   (even ((x1 tau) (foo nat))
;;     (let x foo)
;;     (let y bar)
;;     (return admit))
;;   (odd ((A tau) (y2 A))
;;     admit))
;; (fact (5 top))
;; hole

;; hole

;; new.neut ends here
