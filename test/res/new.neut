(include "notation.neut")

(include "enum.neut")

(include "top.neut")

(include "bottom.neut")

(include "constant.neut")

(include "state.neut")

(include "io.neut")

(enum choice left right)

(enum three three-0 three-1 three-2)

(constant admit-explicit
  (pi ((A type)) A))

(keyword admit)

(notation admit (admit-explicit _))

;; 「あ」のutf8-encoding
(definition str ()
  (u8-array-introduction
    (n3-0 227)
    (n3-1 129)
    (n3-2 130)))

;; 文字列をunicode encodingされたu8 arrayへと変換して保持
(definition test ()
  "あいしてる")

;; (notation (sigma (xt+) t)
;;   (pi
;;     ((c tau)
;;      (_ (pi (xt+ (_ t)) c)))
;;     c))
(definition string
  (sigma ((A type) (prf (is-enum A)))
    (u8-array A)))

;; 長さがn15になるのがポイントで、ここでunicodeの複雜性が出てくる
;; n15の部分をsigmaで包めばどうにかなりそうな雰囲気はある。
(write n15 stdout (test) enum.n15)

(write n15 stdout (test) enum.n15)

(write n15 stdout (test) enum.n15)

(enum nat-enum zero succ-inner)

;; nat = mu x. 1 + x = mu x. Sigma (p : choice). case p of left -> 1 | right -> x
(definition nat-inner ()
  (sigma ((x nat-enum))
    (enum-elimination x
      (zero top)
      (succ-inner (nat-inner)))))

(let (nat tau) (nat-inner))

(let (foo (nat-inner))
  (sigma-introduction zero unit))

(keyword succ)

(notation (succ x)
  (sigma-introduction succ-inner x))

;; こうするとあたかもsuccがコンストラクタであるかのようにつかえる。
(let (bar (nat-inner))
  (succ foo))

;; ちゃんと推論できとる。えらい。
(let (buz nat)
  (succ bar))

(ascription bar nat)

(ascription buz nat)

;; natの上の関数とかってかけるかな？
;; この引数xについてのパターンマッチをしたい。
(definition my-succ ((x nat))
  (sigma-elimination ((selector nat-enum) (value _)) x
    (enum-elimination selector
      (zero top)
      (succ-inner bottom))))
;; こうか。第1成分を取り出してその値がどうなっているかをみて、それに応じた処理を書く。

;; zeroのときtopに、そうでないときbottomになる関数。
(ascription my-succ (hom nat tau))

(definition x 10)

(i64.add (i64.add 3 x) x)

;; new.neut ends here
