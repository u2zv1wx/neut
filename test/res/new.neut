;; define basic notations

;; synonyms
(keyword type)

(notation type tau)

(keyword universe)

(notation universe tau)

(keyword forall)

(notation forall pi)

(keyword apply)

(notation apply pi-elimination)

(keyword fix)

(notation fix mu)

;; sequential execution
(keyword pi-i)

(notation pi-i pi-introduction)

(keyword pi-e)

(notation pi-e pi-elimination)

(keyword let)

(keyword begin)

(keyword definition)

(notation (begin e) e)

(notation (begin e rest+)
  (pi-e (pi-i ((_ _)) (begin rest+)) (begin e)))

(notation (begin (let x e+) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (begin e+)))

(notation (begin (definition x e) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (mu x e)))

(notation (begin (definition name (x+) e+) rest+)
  (pi-e (pi-i ((name _)) (begin rest+)) (mu name (pi-i (x+) (begin e+)))))

;; lambda: pi-introduction with implicit begin block
(keyword lambda)

(notation (lambda () e)
  (pi-introduction () (begin e)))

(notation (lambda (xts+) e)
  (pi-i (xts+) (begin e)))

;; define recursive term at top level without using `mu` explicitly
(notation (definition name e)
  (let name (mu name e))) ;; こっちの `let` はspecial formのほうのlet.

(notation (definition name () e+)
  (let name (mu name (lambda () e+))))

(notation (definition name (x+) e+)
  (let name (mu name (lambda (x+) e+))))

;; type ascription
;; (ascribe e t) ~> (let (_ t) e)
(keyword ascription)

;; (constant is-enum)

(notation (ascription e t)
  (let (_ t) e))

(constant is-enum (pi ((_ type)) type))

(keyword to-type-list)

;; 意味としては(t)へと変換するべきであるような気がする。でないとsplicingにならないような？
(notation (to-type-list t)
  ((_ t)))

(notation (to-type-list t t+)
  ((_ t) (splice (to-type-list t+))))

(keyword arrow)

(notation (arrow (t+) cod)
  (pi (to-type-list t+) cod))

;; (hom a b c) = a -> (b -> c)
(keyword hom)

(notation (hom t) t)

(notation (hom t rest+)
  (pi
    ((_ t))
    (hom rest+)))

(keyword sigma)

(notation (sigma (xt+) t)
  (pi
    ((c tau)
     (_ (pi (xt+ (_ t)) c)))
    c))

;; ここはarrowの定義のおかげでさくっといける。
;; cって導入してある新しい変数はスコープがちゃんとここで切れてるので問題なし。
(keyword product)

(notation (product t+)
  (pi
    ((c tau)
     (_ (arrow (t+) c)))
    c))

(keyword sigma-introduction)

(keyword to-hole-list)

(notation (to-hole-list e)
  ((_ _)))

(notation (to-hole-list e e+)
  ((_ _) (splice (to-hole-list e+))))

(notation (sigma-introduction e+)
  (lambda
    ((elim-result-type tau)
     (eliminator (pi (to-hole-list e+) elim-result-type)))
    (eliminator e+)))

(keyword sigma-elimination)

(notation (sigma-elimination (xt+) e1 e2)
  (e1 (lambda (xt+) e2)))

(definition state ((S type) (A type))
  (hom S (product S A)))

(ascription state
  (pi
    ((S type)
     (A type))
    type))

(definition state-return ((S type) (A type) (x A))
  (lambda ((env S))
    (sigma-introduction env x)))

(ascription state-return
  (pi
    ((S type)
     (A type)
     (x A))
    (hom S (product S A))))

(enum bottom)

(definition io ((a type))
  (state bottom a))

;; (ascription io
;;   (hom type type))

;; IO Bみたいなやつ。
(definition io-return ((B type) (x B))
  (state-return bottom B x))

(ascription io-return
  (pi
    ((A type)
     (x A))
    (io A)))

(enum top unit)

(ascription io-return
  (pi
    ((A type)
     (x A))
    (state bottom A)))

(constant file-descriptor tau)

(constant stdout file-descriptor)

(constant write
  (pi
    ((A type)
     (out file-descriptor)
     (str (u8-array A))
     (len (is-enum A)))
    top))

(enum choice left right)

(enum three three-0 three-1 three-2)

(constant admit-explicit
  (pi ((A type)) A))

(keyword admit)

(notation admit (admit-explicit _))

(definition write ((B type) (out file-descriptor) (str (u8-array B)) (len (is-enum B)))
  (io-return top (write B out str len)))

;; 「あ」のutf8-encoding
(definition str ()
  (u8-array-introduction
    (n3-0 227)
    (n3-1 129)
    (n3-2 130)))

;; 文字列をunicode encodingされたu8 arrayへと変換して保持
(definition test ()
  "あいしてる")

;; 長さがn15になるのがポイントで、ここでunicodeの複雜性が出てくる
;; n15の部分をsigmaで包めばどうにかなりそうな雰囲気はある。
(write n15 stdout (test) enum.n15)

;; new.neut ends here
