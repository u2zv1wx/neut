;; define basic notations

;; synonyms
(keyword type)

(notation type tau)

(keyword universe)

(notation universe tau)

(keyword forall)

(notation forall pi)

(keyword apply)

(notation apply pi-elimination)

(keyword fix)

(notation fix mu)

;; sequential execution
(keyword pi-i)

(notation pi-i pi-introduction)

(keyword pi-e)

(notation pi-e pi-elimination)

(keyword let)

(keyword begin)

(keyword definition)

(notation (begin e) e)

(notation (begin e rest+)
  (pi-e (pi-i ((_ _)) (begin rest+)) (begin e)))

(notation (begin (let x e+) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (begin e+)))

(notation (begin (definition x e) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (mu x e)))

(notation (begin (definition name (x+) e+) rest+)
  (pi-e (pi-i ((name _)) (begin rest+)) (mu name (pi-i (x+) (begin e+)))))

;; lambda: pi-introduction with implicit begin block
(keyword lambda)

(notation (lambda (xts+) e)
  (pi-i (xts+) (begin e)))

;; define recursive term at top level without using `mu` explicitly
(notation (definition name e)
  (let name (mu name e))) ;; こっちの `let` はspecial formのほうのlet.

(notation (definition name (x+) e+)
  (let name (mu name (lambda (x+) e+))))

;; type ascription
;; (ascribe e t) ~> (let (_ t) e)
(keyword ascription)

(constant is-enum)

(notation (ascription e t)
  (let (_ t) e))

(ascription is-enum (pi ((_ type)) type))

(keyword to-type-list)

;; 意味としては(t)へと変換するべきであるような気がする。でないとsplicingにならないような？
(notation (to-type-list t)
  ((_ t)))

(notation (to-type-list t t+)
  ((_ t) (splice (to-type-list t+))))

(keyword arrow)

(notation (arrow (t+) cod)
  (pi (to-type-list t+) cod))

;; (hom a b c) = a -> (b -> c)
(keyword hom)

(notation (hom t) t)

(notation (hom t rest+)
  (pi
    ((_ t))
    (hom rest+)))

(keyword sigma)

(notation (sigma (xt+) t)
  (pi
    ((c tau)
     (_ (pi (xt+ (_ t)) c)))
    c))

;; ここはarrowの定義のおかげでさくっといける。
;; cって導入してある新しい変数はスコープがちゃんとここで切れてるので問題なし。
(keyword product)

(notation (product t+)
  (pi
    ((c tau)
     (_ (arrow (t+) c)))
    c))

(keyword sigma-introduction)

(keyword to-hole-list)

(notation (to-hole-list e)
  ((_ _)))

(notation (to-hole-list e e+)
  ((_ _) (splice (to-hole-list e+))))

;; ;; これだとeliminatorのcodが最初に解決されたもので確定してしまうからだめ？
(notation (sigma-introduction e+)
  (lambda
    ((elim-result-type tau)
     (eliminator (pi (to-hole-list e+) elim-result-type)))
    (eliminator e+)))
;; (notation (sigma-introduction e+)
;;   (lambda
;;     ((elim-result-type tau)
;;      (eliminator (pi (???) elim-result-type)))
;;     (eliminator e+)))

(keyword sigma-elimination)

(notation (sigma-elimination (xt+) e1 e2)
  (e1 (lambda (xt+) e2)))

(definition state ((S type) (A type))
  (hom S (product S A)))

;; (ascription state
;;   (pi
;;     ((S type)
;;      (A type))
;;     type))

;; ここでsigma-intro-2は、reduceの結果をAで固定してしまう？
;; これによって、eliminatorの型が特定のものに固定してしまう。
;; この時点でeliminatorがかなり具体的なものになってしまう、ということ。
(definition state-return ((S type) (A type) (x A))
  (lambda ((env S))
    (sigma-introduction env x)))

;; (definition state-return ((S type) (A type) (x A))
;;   (lambda ((env S))
;;     (sigma-introduction-2 env x)))

;; (definition state-return ((S type) (A type) (x A))
;;   (lambda ((env S))
;;     (lambda ((result-type tau)
;;              (elim (arrow (S A) result-type)))
;;       (elim env x))))

;; (ascription state-return
;;   (pi
;;     ((S type)
;;      (A type)
;;      (x A))
;;     (hom S (product S A))))

(enum bottom) ;; for io-monad

(definition io ((a type))
  (state bottom a))

;; (ascription io
;;   (hom type type))

;; IO Bみたいなやつ。
(definition io-return ((B type) (x B))
  (state-return bottom B x))

;; ところで、こうしたうえでio.returnを
;;   (notation (io.return e) (io-return _ e))
;; のように定義すると、型推論でなんかいい感じになりそう。
;; とにかく型推論を上手く実装しないと。

(ascription io-return
  (pi
    ((A type)
     (x A))
    (io A)))

;; (ascription io-return
;;   (pi
;;     ((A type)
;;      (x A))
;;     (state bottom A)))

(enum top unit)

(ascription io-return
  (pi
    ((A type)
     (x A))
    (state bottom A)))

(constant unsafe.eval-io)

(ascription unsafe.eval-io
  (hom
    (io top)
    top))

(constant file-descriptor)

(ascription file-descriptor type)

(constant stdout)

(ascription stdout file-descriptor)

(constant unsafe.write)

(ascription unsafe.write
  (pi
    ((A type)
     (out file-descriptor)
     (str (u8-array A))
     (len (is-enum A)))
    top))
;; (ascription unsafe.write
;;   (pi
;;     ((A (tata 10))
;;      (out file-descriptor)
;;      (str (u8-array A))
;;      (len (is-enum A)))
;;     top))


(enum choice left right)

(constant admit-explicit)

(ascription admit-explicit
  (pi ((A type)) A))

(keyword admit)

(notation admit (admit-explicit _))

;; writeが無事定義できた〜。
;; (size-of A)とかってしたほうがis-enumよりもいいかも？まあそのへんは適当に。
(definition write ((A type) (out file-descriptor) (str (u8-array A)) (len (is-enum A)))
  (io-return top (unsafe.write A out str len)))
;; implicitは、explicit.writeみたいなのを展開型として用意した上で、notationの定義を入れれば終了。

;; (write choice stdout (admit (u8-array choice)) enum.choice)
;; これがちゃんと型つくのかなりうれしいな。
(write choice stdout admit enum.choice)

(io-return top unit)

;; (ascription write
;;   (arrow (top top top top) bottom))

;; (write choice stdout (admit (u8-array choice)) unit)

;; (u8-array-introduction
;;   (left 3)
;;   (right 2))

;; unit
;; (io-return top unit)
;; unsafe.write
;; stdout
