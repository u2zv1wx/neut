;; define basic notations

;; synonyms
(keyword type)
(notation type tau)

(keyword universe)
(notation universe tau)

(keyword forall)
(notation forall pi)

(keyword apply)
(notation apply pi-elimination)

(keyword fix)
(notation fix mu)

;; sequential execution
(keyword pi-i)
(notation pi-i pi-introduction)

(keyword pi-e)
(notation pi-e pi-elimination)

(keyword let)
(keyword begin)
(keyword definition)

(notation (begin e) e)

(notation (begin e rest+)
  (pi-e (pi-i ((_ _)) (begin rest+)) (begin e)))

(notation (begin (let x e+) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (begin e+)))

(notation (begin (definition x e) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (mu x e)))

(notation (begin (definition name (x+) e+) rest+)
  (pi-e (pi-i ((name _)) (begin rest+)) (mu name (pi-i (x+) (begin e+)))))

;; lambda: pi-introduction with implicit begin block
(keyword lambda)
(notation (lambda (xts+) e)
  (pi-i (xts+) (begin e)))

;; define recursive term at top level without using `mu` explicitly
(notation (definition name e)
  (let name (mu name e))) ;; こっちの `let` はspecial formのほうのlet.

(notation (definition name (x+) e+)
  (let name (mu name (lambda (x+) e+))))

;; type ascription
;; (ascribe e t) ~> (let (_ t) e)
(keyword ascription)

(constant is-enum)

(notation (ascription e t)
  (let (_ t) e))

(ascription is-enum (pi ((_ type)) type))

;; (hom a b c) = a -> (b -> c)
(keyword hom)

(notation (hom t) t)

(notation (hom t rest+)
  (pi
    ((_ t))
    (hom rest+)))

(keyword sigma)

(notation (sigma (xt+) t)
  (pi
    ((c tau)
     (_ (pi (xt+ (_ t)) c)))
    c))

;; ここはarrowの定義のおかげでさくっといける。
;; cって導入してある新しい変数はスコープがちゃんとここで切れてるので問題なし。
(keyword product)

(notation (product t+)
  (pi
    ((c tau)
     (_ (arrow (t+) c)))
    c))

(keyword sigma-introduction)

;; ;; これだとeliminatorのcodが最初に解決されたもので確定してしまうからだめ？
(notation (sigma-introduction e+)
  (lambda
    ((elim-result-type tau)
     (eliminator _))
    (eliminator e+)))

;; (keyword sigma-introduction-2)

;; これだとpiの引数が最初に解決したもので確定してしまうからだめ？
;; でも、notationが展開されるたびにholeが別物としてとられたら。
;; いや、現在のコードではsigma-introは結局1回しか使用されていない。
;; 型推論、正しかったっぽい。
;; (notation (sigma-introduction-2 e1 e2)
;;   (lambda
;;     ((elim-result-type tau)
;;      (eliminator (pi ((_ _) (_ _)) elim-result-type)))
;;     (eliminator e1 e2)))

(keyword sigma-elimination)

(notation (sigma-elimination (xt+) e1 e2)
  (e1 (lambda (xt+) e2)))


(definition state ((S type) (A type))
  (hom S (product S A)))
;; たぶんこのstateも、
;;   (keyword state)
;;   (notation (state S A)
;;     (hom S (product S A)))
;; として実現する必要がある。ようするに、型はnotationによって定義する必要がある。
;; 完全展開型のほうで常に書くようにすればwell-typeになるわけで。
;; 逆に言えば、newtype相当の処理はdefinitionによって実現されることになる？

(ascription state
  (pi
    ((S type)
     (A type))
    type))

;; ここでsigma-intro-2は、reduceの結果をAで固定してしまう？
;; これによって、eliminatorの型が特定のものに固定してしまう。
;; この時点でeliminatorがかなり具体的なものになってしまう、ということ。
;; (definition state-return ((S type) (A type) (x A))
;;   (lambda ((env S))
;;     (sigma-introduction-2 env x)))

(definition state-return ((S type) (A type) (x A))
  (lambda ((env S))
    (lambda ((result-type tau)
             (elim (arrow (S A) result-type)))
      (elim env x))))

;; (ascription state-return
;;   (pi
;;     ((S type)
;;      (A type)
;;      (x A))
;;     (hom S (product S A))))

(enum bottom) ;; for io-monad

(definition io ((a type))
  (state bottom a))
;; たぶんioは
;;  (notation (io a)
;;    (state bottom a))
;; のようにして実現する必要がある。

;; (ascription io
;;   (hom type type))

;; IO Bみたいなやつ。
(definition io-return ((B type) (x B))
  (state-return bottom B x))

;; ところで、こうしたうえでio.returnを
;;   (notation (io.return e) (io-return _ e))
;; のように定義すると、型推論でなんかいい感じになりそう。
;; とにかく型推論を上手く実装しないと。

(ascription io-return
  (pi
    ((A type)
     (x A))
    (io A)))

;; (ascription io-return
;;   (pi
;;     ((A type)
;;      (x A))
;;     (state bottom A)))

(enum top unit)

(ascription io-return
  (pi
    ((A type)
     (x A))
    (state bottom A)))

;; (ascription unsafe.eval-io
;;   (hom
;;     (io top)
;;     top))

(constant file-descriptor)
(ascription file-descriptor type)
(constant stdout)
(ascription stdout file-descriptor)
(constant unsafe.write)
(ascription unsafe.write
  (pi
    ((A type)
     (out file-descriptor)
     (str (u8-array A))
     (len (is-enum A)))
    top))
;; unsafe.write : Pi (A : Univ, out : file-descriptor, str : u8-array a, len : is-enum A). top

;; (enum choice left right)

unit
;; (io-return top unit)
;; stdout
