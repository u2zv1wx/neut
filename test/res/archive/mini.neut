(index top unit)

(index i32)

(index u32)

(reserve forall)

(reserve arrow)

(reserve lambda)

(reserve apply)

(reserve exists)

(reserve product)

(reserve pair)

(reserve case)

(reserve universe)

(reserve let)

(reserve begin)

(reserve definition)

(reserve mu)

(reserve module)

(reserve include)

(reserve use)

(notation (begin e)
  e)

(notation (begin e rest+)
  (apply (lambda ((_ _)) (begin rest+)) (begin e)))

(notation (begin (let x e+) rest+)
  (apply (lambda ((x _)) (begin rest+)) (begin e+)))

(notation (begin (definition x e) rest+)
  (apply (lambda ((x _)) (begin rest+)) (mu x e)))

(notation (begin (definition name (x+) e+) rest+)
  (apply (lambda ((name _)) (begin rest+)) (mu name (lambda (x+) (begin e+)))))

;; (primitive core.u32.sub (arrow u32 u32 u32))

(reserve definition)

(notation (definition name e)
  (let name (mu name e)))

(notation (definition name (x+) e+)
  (let name (mu name (lambda (x+) (begin e+)))))

;; (let type universe)

;; (definition string ((n u32))
;;   (vector n u32))

(index nat:core nat:zero nat:succ)

(definition nat
  (exists ((l nat:core))
    (case l
      ((nat:zero top)
       (nat:succ nat)))))

(let bar (pair 1 2 3))
(ascription bar (product i32 i32 u32))
;; (ascription bar (vector 3 i32))

;; (let buz (pair nat:zero unit))
;; (ascription buz nat)

; (let succ-buz (pair nat:succ buz))
; (ascription succ-buz (code nat))

;; unit
