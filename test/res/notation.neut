;; define basic notations

;; synonyms
(keyword type)
(notation type tau)

(keyword universe)
(notation universe tau)

(keyword forall)
(notation forall pi)

(keyword apply)
(notation apply pi-elimination)

(keyword fix)
(notation fix mu)

;; sequential execution
(keyword pi-i)
(notation pi-i pi-introduction)

(keyword pi-e)
(notation pi-e pi-elimination)

(keyword let)
(keyword begin)
(keyword definition)

(notation (begin e) e)

(notation (begin e rest+)
  (pi-e (pi-i ((_ _)) (begin rest+)) (begin e)))

(notation (begin (let x e+) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (begin e+)))

(notation (begin (definition x e) rest+)
  (pi-e (pi-i ((x _)) (begin rest+)) (mu x e)))

(notation (begin (definition name (x+) e+) rest+)
  (pi-e (pi-i ((name _)) (begin rest+)) (mu name (pi-i (x+) (begin e+)))))

;; lambda: pi-introduction with implicit begin block
(keyword lambda)
(notation (lambda (xts+) e)
  (pi-i (xts+) (begin e)))

;; define recursive term at top level without using `mu` explicitly
(notation (definition name e)
  (let name (mu name e))) ;; こっちの `let` はspecial formのほうのlet.

(notation (definition name (x+) e+)
  (let name (mu name (lambda (x+) e+))))

;; type ascription
;; (ascribe e t) ~> (let (_ t) e)
(keyword ascription)

(constant is-enum)

(notation (ascription e t)
  (let (_ t) e))

(ascription is-enum (pi ((_ type)) type))

;; (notation (arg-list t) (_ t))

;; (notation (arg-list e rest+) ((_ t) (arg-list rest+)))

;; (hom a b c) = a -> (b -> c)
(keyword hom)

(notation (hom t) t)

(notation (hom t rest+)
  (pi
    ((_ t))
    (hom rest+)))

(keyword sigma)

(notation (sigma (xt+) t)
  (pi
    ((c tau)
     (_ (pi (xt+ (_ t)) c)))
    c))

;; ここはarrowの定義のおかげでさくっといける。
;; cって導入してある新しい変数はスコープがちゃんとここで切れてるので問題なし。
(keyword product)

(notation (product t+)
  (pi
    ((c tau)
     (_ (arrow (t+) c)))
    c))

;; (notation (sigma-introduction e+)
;;   (lambda ;; ところでformattingはこうするのがよさそうね。
;;     ((elim-result-type
;;       tau) ;; いちばんcanonicalな形での表現。縦に冗長だけど、スケールはする。「縦に読む」って感じ。
;;      (eliminator
;;       (arrow
;;         ((x1 A1)  ;; ここにA1についてのコメント。
;;          ...
;;          (xn An)) ;; ここにAnについてのコメント。
;;         elim-result-type)))
;;     (eliminator e+))) ;; 適用はこれで問題ないはずで。eliminatorの型を不明にしておいても大丈夫なんだろうか？さすがにきつくない？
;; こうしたいんだけど、piの引数部分をかくことができない。特殊なマクロが必要なのかしら。

;; 型推論を信じていくスタイル。
(keyword sigma-introduction)

(notation (sigma-introduction e+)
  (lambda
    ((elim-result-type tau)
     (eliminator _)) ;; eliminatorの型は推論で決定する
    (eliminator e+)))

;; sigma-elimはこれでいいのかな？
(keyword sigma-elimination)

(notation (sigma-elimination (xt+) e1 e2)
  (e1 (lambda (xt+) e2)))

;; stateはpartial applicationを許す形で定義する必要がある
;; (notation (definition name (x+) e+)
;;   (let name (mu name (lambda (x+) e+))))
;; これだと2引数が同時に必要。
(definition state ((S type) (A type))
  (hom S (product S A)))

(enum bottom) ;; for io-monad

;; まあ、こっちのほうで引数を供給すればよいだけではある。
(definition io ((a type))
  (state bottom a))

;; just for test
(enum top unit)
