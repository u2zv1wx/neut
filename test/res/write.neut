;; (define test ()
;;   "あ")

;; (os.write os.stdout (test) 3)

;; (no-implicit-core)

;; (introspect OS
;;   (linux (include library "core/constant/linux.neut"))
;;   (darwin (include library "core/constant/darwin.neut")))

;; (include library "core/notation.neut")


(include library "core/integer.neut")

(include library "core/string.neut")

(include library "core/list.neut")

(let test "あ")

;; (section os)

;; (constant file-descriptor tau)

;; (constant stdout file-descriptor)


;; (constant write
;;   (pi
;;     ((A u64)
;;      (out file-descriptor)
;;      (str (array A u8))
;;      (len u64))
;;     (product (array A u8) u64)))

;; (attribute write (implicit 0))

;; (end os)


(use os)

;; こっちだとmalloc/freeがめっちゃ発生する。
;; (begin
;;   (let len (write stdout test 3))
;;   (let len (@os.write 3 stdout test 3))
;;   (let len (write stdout test 3))
;;   len)

;; (write hole stdout &test 3)




;; こっちだと最初と最後の1回だけ。
;; ここの最初の「&test」も「test」に解決されるわけだけど、するとbeginのあとでも「test」が
;; 使用されていることから、ここでtestのコピーが走ることになる。
(with let-bind
  (let _
    (let _ (i64 100))
    (string.print &test) ;; これは「内側」のwithについてのborrowとして処理される
    (string.print &test)) ;; 末尾でのみborrowが許される（途中では別な場所でのborrowになる）（というか途中のborrowも自動で実装されてるわ、これ）
  (let _ (string.print &test))
  (let len (string.print &test)) ;; ここの "defined but not used" はfreeを具体的に行うことを要求しているとみなせる。「せっかく借用したのに」というわけ。
  (erase test)
  len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）
  ;; 末尾でのborrowをここでもし許可しようとするなら、トップレベルのborrowが必要になってくる、というわけ。


;; (begin
;;   (let len (os.write os.stdout &test 3))
;;   (let len (os.write os.stdout &test 3))
;;   (let len (os.write os.stdout &test 3))
;;   len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）

(theorem some-theorem
  (Π ((A tau))
    (hom A A))
  (assume (_)
    (assume (x) x)))

(verify ((λ ((x tau)) x) top))

(string.print "\n")

(verify some-theorem)

;; (define my-verify ((A tau) (p A))
;;   ((irreducible (lambda ((x A)) (string.print "verified"))) p))

(define loop ((x i64))
  (witness i64
    (loop x)))

(let _ some-theorem) ;; 普通にこれでverifyになるのでは？なった。
;; pureだとreduceされてしまうという問題はあるか。いや、reduceできたらreduceできたでいいのか。

;; (let _ (loop 3))

;; (@os.write 3 os.stdout "あ" 3)
;; (@os.write 3 os.stdout "あ" 3)
;; (@os.write 3 os.stdout "あ" 3)

;; (i64.add tau 10)

;; (let a (os.write os.stdout &test 3))
;; (let a (os.write os.stdout &test 3))
;; (let a (os.write os.stdout &test 3))
;; (let a (os.write os.stdout &test 3))

(with let-bind
  (let _ (string.print &test))
  (let _ (string.print &test))
  (i64 10)
  (let _ (string.print &test))
  (let len (string.print &test))
  (erase test)
  len)


;; (let _ (string.print &test))
;; (let hoge (string.print &test))
;; (i64 10)
;; (let _ (string.print &test))
;; (let len (string.print &test))


(string.print test)

(let _ (i64 10))

(string.print test)


;; (print-character 45)
;; (string.print test)

(i64.print -1234321)

(define fact ((n i64))
  (witness i64
    (if (icmp-sle-i64 n 0)
      1
      (with let-bind
        (string.print "looping with (もちろん日本語も出力できるよ). ")
        (i64.print ?n)
        (let _ (i64.add 10 10))
        (let hogehoge (i64 10))
        (let _ (i64.add hogehoge 1))
        (string.print "\n")
        (?mul-i64 n (fact (?sub-i64 n 1)))))))



(let xs (list i64)
  (list.new 1 2 3 4 5))

(inductive equal ((A tau) (x A) (y A))
  (refl ((z A)) (equal A z z)))


;; (attribute equal
;;   (implicit 0))

?equal

?equal.fold



;; ?@@@equal.refl

?equal.refl

;; @?equal.refl


(define my-id ((a tau) (_ tau) (_ tau) (x a)) x)

;; (define my-id ((?a tau) (x a)) x)

;; #my-id
?my-id


;; (constant outer (hom i64 i64))

;; (outer 10)

;; (constant something i64)

;; (i64.add 10 something)



(attribute my-id (implicit 0 1 2))

?my-id

;; (attribute my-id (implicit 1))

?@my-id



;; (attribute my-id (implicit 2))

?my-id

(define id ((a tau) (x a)) x)


(id i64 (i64 3)) ;; これでよくね？
;; (equal * 10 20)とかって書けるわけだし。
;; (list.nil *)とか(cons * 10 (cons * 20 (nil *)))とかはめんどくさいだろうか？
;; でも真実じゃん？
;; さらに言えば、機能としてはべつにnotationで同じことが実現できるわけで。

;; (keyword id*)

;; (notation (id* e)
;;   (id * e))

;; (id* (i64 3)) ;; こうできるわけでさ。


(let p
  (equal.refl (i64 3)))

(let p
  (@equal.refl i64 3))

;; (i64.add top tau)


-
foobaraoeuaoeuaoeuaoeuaoeuao. いい感じじゃない？

ほげほげ。コメントがいい感じで書ける。色もつく。
-

?p

-
section foo
あ、色、こうなるのね。
(define foo (x) foo bar)みたいに、色がつくのか。これは……どうなんだろう？微妙では。
やっぱコメントは無色のほうがいいね。
hogehoge. きちんとハイライトされてる。
はい。これでnewlineもちゃんと処理できた。
あおう。

顧客が本当に必要だったもの、では。特にパフォーマンス上の問題も感じない。次はtokenizerのほうを修正していく感じか。

これがあるとやっぱり文章みたいにコメントを書けてかなり快適だと思うんですよ。mode-flipがあると。さすがに便利でしょ。
-


-
foobaraoaeuaeou日本語入力ホゲホゲ。このへんの色ってどうにかしてくれないかな。aoeuaoeuaoeuaoeuそれらしくなってる、のか？日本語入力パート。文字入力のタイミングでハイライトが壊れてしまうという問題がある。
-



?p


(inductive choice ()
  (item-1 () (choice))
  (item-2 () (choice)))

(define hoge-func ((x i64)) x)


?choice.fold
;; (choice.fold (choice.item-1) (lambda () i64) ?admit ?admit)


(define flip ((c (choice)))
  (witness (choice)
    (case c
      ((choice.item-1)
        (choice.item-2))
      ((choice.item-2)
        (choice.item-1)))))

?flip

(define 日本語でもべつにいい ((x i64)) (i64.add x 10))


(define sample ((x i64)) (i64.add x 10))

(define sample tau)

(theorem double-flip-is-identity
  (pi ((c (choice)))
    (equal
      (choice)
      c
      (flip (flip c))))
  (assume ((c (choice)))
    (case c
      ((choice.item-1)
        admit) ;; (F @ c) {c .= (choice.item-1)}
      ((choice.item-2)
        ?admit) ;; (F @ c) {c .= (choice.item-2)}
        ))) ;; F @ c

?double-flip-is-identity

;; (verify double-flip-is-identity)

(string.print "\n")

;; (i64.print (fact 10))

(i64.print (fact (unsafe.cast i64 i64 (list.length xs))))



(define unused-function ((_ tau)) tau)




(inductive hogehoge ((a tau))
  (make ((_ (hom i64 (list (hogehoge a))))) (hogehoge a)))

;; (attribute unused-function
;;   (implicit 0))


;; (provide unused-function)
(?string.print "\n")

;; (string.print (pi-introduction (x) x))

;; (string.print (100 tau))

(string.print "hello, world!\n")

;; (let a1 (os.write os.stdout test 3))
;; (let a2 (os.write os.stdout test 3))
;; (let a3 (os.write os.stdout test 3))

;; (i64 0)
