;; (definition test ()
;;   "あ")

;; (os:write os:stdout (test) 3)

;; (no-implicit-core)

;; (introspect OS
;;   (linux (include library "core/constant/linux.neut"))
;;   (darwin (include library "core/constant/darwin.neut")))

;; (include library "core/notation.neut")


(include library "core/integer.neut")

(include library "core/string.neut")

(include library "core/list.neut")

(let test "あ")

;; (section os)

;; (constant file-descriptor tau)

;; (constant stdout file-descriptor)


;; (constant write
;;   (pi
;;     ((A u64)
;;      (out file-descriptor)
;;      (str (array A u8))
;;      (len u64))
;;     (product (array A u8) u64)))

;; (attribute write (implicit 0))

;; (end os)

(use os)

;; こっちだとmalloc/freeがめっちゃ発生する。
;; (begin
;;   (let len (write stdout test 3))
;;   (let len (@os:write 3 stdout test 3))
;;   (let len (write stdout test 3))
;;   len)

;; (write hole stdout &test 3)


;; こっちだと最初と最後の1回だけ。
;; ここの最初の「&test」も「test」に解決されるわけだけど、するとbeginのあとでも「test」が
;; 使用されていることから、ここでtestのコピーが走ることになる。
(begin
  (let len (string:print &test))
  (let len (string:print &test))
  (let len (string:print &test))
  len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）

;; (begin
;;   (let len (os:write os:stdout &test 3))
;;   (let len (os:write os:stdout &test 3))
;;   (let len (os:write os:stdout &test 3))
;;   len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）

(theorem some-theorem
  (Π ((A tau))
    (hom A A))
  (assume (a)
    (assume (x) x)))

(verify ((λ ((x tau)) x) top))

(verify some-theorem)


;; (@os:write 3 os:stdout "あ" 3)
;; (@os:write 3 os:stdout "あ" 3)
;; (@os:write 3 os:stdout "あ" 3)

;; (i64:add (os:write os:stdout test 3) 10)

;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))


(let a (string:print &test))
(let a (string:print &test))
(let a (string:print &test))
(let a (string:print &test))

;; (print-character 45)

(i64:print -1234321)

(definition fact ((n i64))
  (witness i64
    (if (i64:le n 0)
      1
      (with let-bind
        (?string:print "looping with (もちろん日本語も出力できるよ): ")
        (i64:print ?n)
        (string:print "\n")
        (?i64:mul n (fact (?i64:sub n 1)))))))

(let xs (list i64)
  (list:new 1 2 3 4 5))


(string:print "\n")

;; (i64:print (fact 10))

(i64:print (fact (unsafe:cast u64 i64 (list:length xs))))

(?string:print "\n")

;; (let a1 (os:write os:stdout test 3))
;; (let a2 (os:write os:stdout test 3))
;; (let a3 (os:write os:stdout test 3))

;; (i64 0)
