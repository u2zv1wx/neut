;; (definition test ()
;;   "あ")

;; (os:write os:stdout (test) 3)

;; (no-implicit-core)

;; (introspect OS
;;   (linux (include library "core/constant/linux.neut"))
;;   (darwin (include library "core/constant/darwin.neut")))

;; (include library "core/notation.neut")


(include library "core/integer.neut")

(include library "core/string.neut")

(include library "core/list.neut")

(let test "あ")

;; (section os)

;; (constant file-descriptor tau)

;; (constant stdout file-descriptor)


;; (constant write
;;   (pi
;;     ((A u64)
;;      (out file-descriptor)
;;      (str (array A u8))
;;      (len u64))
;;     (product (array A u8) u64)))

;; (attribute write (implicit 0))

;; (end os)


(use os)

;; こっちだとmalloc/freeがめっちゃ発生する。
;; (begin
;;   (let len (write stdout test 3))
;;   (let len (@os:write 3 stdout test 3))
;;   (let len (write stdout test 3))
;;   len)

;; (write hole stdout &test 3)




;; こっちだと最初と最後の1回だけ。
;; ここの最初の「&test」も「test」に解決されるわけだけど、するとbeginのあとでも「test」が
;; 使用されていることから、ここでtestのコピーが走ることになる。
(with let-bind
  (let _
    (let _ (i64 100))
    (string:print &test) ;; これは「内側」のwithについてのborrowとして処理される
    (string:print &test)) ;; 末尾でのみborrowが許される（途中では別な場所でのborrowになる）（というか途中のborrowも自動で実装されてるわ、これ）
  (let _ (string:print &test))
  (let len (string:print &test)) ;; ここの "defined but not used" はfreeを具体的に行うことを要求しているとみなせる。「せっかく借用したのに」というわけ。
  (erase test)
  len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）
  ;; 末尾でのborrowをここでもし許可しようとするなら、トップレベルのborrowが必要になってくる、というわけ。


;; (begin
;;   (let len (os:write os:stdout &test 3))
;;   (let len (os:write os:stdout &test 3))
;;   (let len (os:write os:stdout &test 3))
;;   len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）

(theorem some-theorem
  (Π ((A tau))
    (hom A A))
  (assume (_)
    (assume (x) x)))

(verify ((λ ((x tau)) x) top))

(string:print "\n")

(verify some-theorem)

;; (definition my-verify ((A tau) (p A))
;;   ((irreducible (lambda ((x A)) (string:print "verified"))) p))

(definition loop ((x i64))
  (witness i64
    (loop x)))

(let _ some-theorem) ;; 普通にこれでverifyになるのでは？なった。
;; pureだとreduceされてしまうという問題はあるか。いや、reduceできたらreduceできたでいいのか。

;; (let _ (loop 3))

;; (@os:write 3 os:stdout "あ" 3)
;; (@os:write 3 os:stdout "あ" 3)
;; (@os:write 3 os:stdout "あ" 3)

;; (i64:add tau 10)

;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))

(with let-bind
  (let _ (string:print &test))
  (let _ (string:print &test))
  (i64 10)
  (let _ (string:print &test))
  (let len (string:print &test))
  (erase test)
  len)


;; (let _ (string:print &test))
;; (let hoge (string:print &test))
;; (i64 10)
;; (let _ (string:print &test))
;; (let len (string:print &test))


(string:print test)

(let _ (i64 10))

(string:print test)


;; (print-character 45)
;; (string:print test)

(i64:print -1234321)

(definition fact ((n i64))
  (witness i64
    (if (i64:le n 0)
      1
      (with let-bind
        (string:print "looping with (もちろん日本語も出力できるよ): ")
        (i64:print ?n)
        (let _ (i64:add 10 10))
        (let hogehoge (i64 10))
        (let _ (i64:add hogehoge 1))
        (string:print "\n")
        (?i64:mul n (fact (?i64:sub n 1)))))))


(let xs (list i64)
  (list:new 1 2 3 4 5))

(inductive equal ((A tau) (x A) (y A))
  (refl ((z A)) (equal A z z)))


;; (attribute equal
;;   (implicit 0))

?equal

?equal:induction

;; ?@@@equal:refl

?equal:refl

;; @?equal:refl


(definition my-id ((a tau) (_ tau) (_ tau) (x a)) x)

;; (definition my-id ((?a tau) (x a)) x)

;; #my-id
?my-id


;; (constant outer (hom i64 i64))

;; (outer 10)

;; (constant something i64)

;; (i64:add 10 something)



;; (attribute my-id (implicit 0 1 2))

?my-id

;; (attribute my-id (implicit 1))

;; ?@my-id



;; (attribute my-id (implicit 2))

?my-id

(definition id ((a tau) (x a)) x)

(id i64 (i64 3)) ;; これでよくね？
;; (equal * 10 20)とかって書けるわけだし。
;; (list:nil *)とか(cons * 10 (cons * 20 (nil *)))とかはめんどくさいだろうか？
;; でも真実じゃん？
;; さらに言えば、機能としてはべつにnotationで同じことが実現できるわけで。

;; (keyword id*)

;; (notation (id* e)
;;   (id * e))

;; (id* (i64 3)) ;; こうできるわけでさ。

(let p (equal:refl i64 3))

;; (i64:add top tau)

?p

(inductive choice ()
  (item-1 () (choice))
  (item-2 () (choice)))

(definition hoge-func ((x i64)) x)


?choice:induction
;; (choice:induction (choice:item-1) (lambda () i64) ?admit ?admit)


(definition flip ((c (choice)))
  (witness (choice)
    (case c
      ((choice:item-1)
        (choice:item-2))
      ((choice:item-2)
        (choice:item-1)))))

?flip

(definition 日本語でもべつにいい ((x i64)) (i64:add x 10))


(definition sample ((x i64)) (i64:add x 10))

(theorem double-flip-is-identity
  (pi ((c (choice)))
    (equal
      (choice)
      c
      (flip (flip c))))
  (assume ((c (choice)))
    (case c
      ((choice:item-1)
        admit) ;; (F @ c) {c := (choice:item-1)}
      ((choice:item-2)
        ?admit) ;; (F @ c) {c := (choice:item-2)}
        ))) ;; F @ c

?double-flip-is-identity

;; (verify double-flip-is-identity)

(string:print "\n")

;; (i64:print (fact 10))

(i64:print (fact (unsafe:cast u64 i64 (list:length * xs))))



(definition unused-function ((_ tau)) tau)



(inductive hogehoge ((a tau))
  (make ((_ (hom i64 (list (hogehoge a))))) (hogehoge a)))

;; (attribute unused-function
;;   (implicit 0))


;; (provide unused-function)
(?string:print "\n")

(string:print "hello, world!\n")

;; (let a1 (os:write os:stdout test 3))
;; (let a2 (os:write os:stdout test 3))
;; (let a3 (os:write os:stdout test 3))

;; (i64 0)
