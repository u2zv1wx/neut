;; (include library "core/core.neut")

(coinductive my-record ()
  (item-1 ((_ (my-record))) i64)
  (item-2 ((_ (my-record))) u32)
  (item-3 ((_ (my-record))) top))

(let item
  (record (my-record)
    (item-1 10)
    (item-3 unit)
    (item-2 20)))

(let xs (list i64)
  (list:cons 25 (list:cons 100 (list:cons 1000 (list:nil)))))

;; (list! 25 100 1000)みたいな略記を許すようにしてもいいかもしれないが。

(case xs
  ((list:nil) (i64 10))
  ((list:cons value ys)
   (case ys
     ((list:nil) (i64 20))
     ((list:cons v2 zs) v2))))

;; (item-2 item)

;; (item-2 item)

;; (item-1 item)

;; (let xs (list.cons i64 1 (list.cons i64 2 (list.cons i64 (item-1 item) (list.nil i64)))))

;; ;; これがちゃんと動くようになった
;; (definition sum ((xs (list i64)))
;;   (case xs
;;     ((list:nil) 0)
;;     ((list:cons z ys)
;;       (i64.add z (sum ys)))))

;; (definition fact ((xs (list i64)))
;;   (case xs
;;    ((list.nil _) 1)
;;    ((list.cons _ z ys) (i64.mul z (fact ys)))))

;; (fact xs)
