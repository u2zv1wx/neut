;; (include library "core/core.neut")

;; (coinductive my-record ()
;;   (item-1 ((_ (my-record))) i64)
;;   (item-2 ((_ (my-record))) u32)
;;   (item-3 ((_ (my-record))) top))

;; (let item
;;   (record (my-record)
;;     (item-1 10)
;;     (item-3 unit)
;;     (item-2 20)))

(section some-library)

(use list)

;; (let xs (list i64)
;;   (cons 25 (list:cons 100 (list:cons 1000 (list:nil)))))

(let xs (list i64)
  (cons 25 (cons 100 (cons 1000 (nil)))))

;; (unuse list)

(let ps (list i64)
  (cons 25 (cons 100 (cons 1000 (nil)))))

;; ↓ こう書くとエラーがlist.neutのほうで報告されてしまうという問題がある。修正すること。
;; (let item
;;   (list:cons 25 (list:cons 100 (list:cons 1000 (list:nil)))))

;; (list! 25 100 1000)みたいな略記を許すようにしてもいいかもしれないが。

;; 名前空間というかauto-prefixがあるとコードがかなりスッキリしますね。
(section item)

(definition sum ((xs (list i64)))
  (case xs
    ((nil) 0)
    ((cons z ys)
      (i64.add z (sum ys)))))

(end item)

(definition pohe ([a tau] (xs (list a)))
  (case xs
    ((nil) 0)
    ((cons _ ys) (u64.add 1 (pohe a ys)))))



(case xs
  ((nil) (i64 10))
  ((cons value ys) (i64 20)))

(case xs
  ((nil) (i64 10))
  ((cons value ys)
   (case ys
     ((nil) (i64 20))
     ((cons v2 zs) v2))))

;; (os:exit i64 (case xs
;;   ((list:nil) (i64 10))
;;   ((list:cons value ys)
;;    (case ys
;;      ((list:nil) (i64 20))
;;      ((list:cons v2 zs) v2)))))

(let zs (list i64)
  (cons 1 (cons 2 (cons 3 (nil)))))

(let ws
  (@cons i64 1 (cons 2 (cons 3 (nil)))))

(use os)

(exit i64 (some-library:item:sum zs))

(unuse list)
;; (item-2 item)

;; (item-2 item)

;; (item-1 item)

;; (let xs (list.cons i64 1 (list.cons i64 2 (list.cons i64 (item-1 item) (list.nil i64)))))

;; ;; これがちゃんと動くようになった


;; (definition fact ((xs (list i64)))
;;   (case xs
;;    ((list.nil _) 1)
;;    ((list.cons _ z ys) (i64.mul z (fact ys)))))

;; (fact xs)

(end some-library)
