* 2020-01-01-1756
** 概要
同一の変数名を使用しているよ、とLLVMに叱られる。同じ型を複数箇所で使用する必要があることに由来していそう？

** 結論
linearizeのときに同じ型を複数回使用する可能性があって、んで実際複数回使用すると同じ名前の変数を使用することになる、という話。セマンティクスとしては問題ないはずなんだけど、LLVMがなぜかshadowingを許可していないせいでこっちのコードの方に修正が必要になってきている、という状況。

** 雑記
とりあえずaffineSigmaの引数をdumpした。closure-3421を複数回使用しているらしいが。
……たぶんわかった。これもlinearizeの話だ。たとえば
#+BEGIN_SRC haskell
linearize xts (m, CodeSigmaElim yts d e) = do
  let xts' = filter (\(x, _) -> x `elem` varCode e) xts
  e' <- linearize (xts' ++ yts) e
  withHeader xts (m, CodeSigmaElim yts d e')
#+END_SRC
こういうコードがあって、かつxts'がemptyじゃないとする。さらにeのなかでこのxts'についてのコピーがあったとする。すると、このときは、eのなかでxts'のなかの特定の型tがまず使われる。さらにこのうえでwithHeader xtsによってxについての処理が入ると（たとえばdのなかでxが複数回使われるとか）、同じ型tがふたたびここでも使われることになる。こうしてコードとしては同一のものが複数箇所に出現することになって、これはまあ、処理としては妥当であるが、LLVMとしては妥当ではない。そういう原因だろう。
解決策はいちおうあって、つまりtermを複数回polarizeするというもの。あるいはrenameをするというもの。あるいはLLVMにプルリクを投げるというもの。
無駄に処理を行うことになるなー。linearizeのタイミングでrenameをすればいいってのはそうなんだけどさー。
