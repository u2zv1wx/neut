;; simple coinductive type
;; (coinductive stream ((A tau))
;;   (head
;;     ((_ (stream A)))
;;     A)
;;   (tail
;;     ((_ (stream A)))
;;     (stream A)))

(inductive stream ((A tau))
  (unfold ((F (hom tau tau))
           (h (hom (F A) A))
           (t (hom (F A) (F A)))
           (_ (F A)))
          (stream A)))

(define stream.head ((A tau) (x (stream A)))
  (case x
    ((stream.unfold _ h _ v) (h v))))

(attribute stream.head (implicit 0))

(define stream.tail ((A tau) (x (stream A)))
  (witness (stream A)
    (case x
      ((stream.unfold F h t v)
        (stream.unfold F h t (t v)))))) ;; externalize!

(attribute stream.tail (implicit 0))
;; ?stream.unfold

(let stream-from-zero
  (stream.unfold
    (lambda ((x tau)) x)
    (lambda ((x i64)) x)
    (lambda ((x i64)) (add-i64 x 1))
    0))

;; ?stream.tail
(i64.print (stream.head (stream.tail (stream.tail (stream.tail stream-from-zero)))))
;; (i64.print (stream.head stream-from-zero))

;; nested coinductive type
(coinductive foo ((A tau))
  (elim0
    ((_ (foo A)))
    A)
  (elim1
    ((_ (foo A)))
    (stream (list (stream (foo A))))))

;; mutually coinductive type
(coinductive
  (buz ((x i64))
    (elim0 ((_ (buz x)))
      (qux x)))
  (qux ((x i64))
    (elim1 ((_ (qux x)))
      (buz x))))

(coinductive my-record ((a tau))
  (item-1
    ((_ (my-record a)))
    a)
  (item-2
    ((_ (my-record a)))
    i64)
  (item-3
    ((_ (my-record a)))
    top))


(let item
  (record (my-record i64)
    (item-1 10)
    (item-3 top.unit)
    (item-2 20)))

(i64.print (my-record.item-1 item))

(i64.print (my-record.item-2 item))
