;; preliminary.

(no-implicit-core)

;; for test
;; (ensure libarchive/3.4.2
;;   "https.//www.libarchive.org/downloads/libarchive-3.4.2.tar.gz")

(include library "core/notation.neut")

(include library "core/option.neut")

(include library "core/bool.neut")

(include library "core/lazy.neut")

(use option)

(use bool)

(use lazy)

;; content.

(section list)

(inductive list ((a tau))
  (nil
    ()
    (list a))
  (cons
    ((_ a)
     (_ (lazy (list a))))
    (list a)))

(keyword list.new)

(notation (list.new)
  (list.nil))

(notation (list.new a)
  (list.cons * a (thunk * (list.nil *))))

(notation (list.new a rest+)
  (list.cons * a (thunk * (list.new rest+))))

(define head
  ((a tau)
   (xs (list a)))
  (witness (option a)
    (list.fold a xs
      (lambda (_)
        (option a))
      (lambda ()
        (none a))
      (lambda (h _)
        (some a h)))))

;; (attribute head (implicit 0))

(define length
  ((a tau)
   (xs (list a)))
  (witness i64
    (list.fold a xs
      (lambda (_)
        i64)
      (lambda ()
        0)
      (lambda (_ acc)
        (add-i64 1 (force i64 acc))))))

;; (attribute length (implicit 0))

(define append
  ((a tau)
   (xs (list a))
   (ys (list a)))
  (witness (list a)
    (list.fold a xs
      (lambda (_)
        (list a))
      (lambda ()
        ys)
      (lambda (z acc)
        (cons a z acc)))))

;; (attribute append (implicit 0))

(define is-null
  ((a tau)
   (xs (list a)))
  (witness bool
    (list.fold a xs
      (lambda (_)
        bool)
      (lambda ()
        true)
      (lambda (_ _)
        false))))


;; (attribute is-null (implicit 0))

(define map
  ((a tau)
   (b tau)
   (f (hom a b))
   (xs (list a)))
  (witness (list b)
    (list.fold a xs
      (lambda (_)
        (list b))
      (lambda ()
        (nil b))
      (lambda (y acc)
        (cons b (f y) acc)))))


;; (attribute map (implicit 0 1))

(define return
  ((a tau)
   (x a))
  (witness (list a)
    (list.new x)))

;; (attribute return (implicit 0))

(define concatenate
  ((a tau)
   (m (list (list a))))
  (witness (list a)
    (list.fold (list a) m
      (lambda (_)
        (list a))
      (lambda ()
        (nil *))
      (lambda (xs acc)
        (append * xs (force * acc))))))

;; (attribute concatenate (implicit 0))

(define bind
  ((a tau)
   (b tau)
   (m (list a))
   (k (hom a (list b))))
  (witness (list b)
    (concatenate * (map * * k m))))

;; (attribute bind (implicit 0 1))

;; (provide head)

;; (provide length)

;; (provide append)

;; (provide is-null)

;; (provide map)

;; (provide return)

;; (provide concatenate)

;; (provide bind)

(end list)
