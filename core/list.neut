;; preliminary.

(no-implicit-core)

;; for test
;; (ensure libarchive/3.4.2
;;   "https.//www.libarchive.org/downloads/libarchive-3.4.2.tar.gz")

(include library "core/notation.neut")

(include library "core/option.neut")

(include library "core/bool.neut")

(include library "core/lazy.neut")

(use option)

(use bool)

(use lazy)

;; content.

(section list)

(inductive list ((a tau)) ;; list .= Pi (a . tau). tauだからaがunusedとして報告される。修正すること。
  (nil
    ()
    (list a))
  (cons
    ((_ a)
     (_ (lazy (list a))))
    (list a)))

(keyword list.new)

(notation (list.new)
  (list.nil))

(notation (list.new a)
  (list.cons a (thunk (list.nil))))

(notation (list.new a rest+)
  (list.cons a (thunk (list.new rest+))))

;; (define head
;;   ((a tau)
;;    (xs (list a)))
;;   (witness (option a)
;;     (case xs
;;       ((nil)
;;         (none))
;;       ((cons y _)
;;         (some y)))))

(define head
  ((a tau)
   (xs (list a)))
  (witness (option a)
    (list.fold xs
      (lambda (_)
        (option a))
      (lambda ()
        (none))
      (lambda (h _)
        (some h)))))

(attribute head (implicit 0))

(define length
  ((a tau)
   (xs (list a)))
  (witness i64
    (list.fold xs
      (lambda (_)
        i64)
      (lambda ()
        0)
      (lambda (_ acc)
        (add-i64 1 (force acc))))))

;; (define length
;;   ((a tau)
;;    (xs (list a)))
;;   (witness i64
;;     (case xs
;;       ((nil)
;;         0)
;;       ((cons _ ys)
;;         (add-i64 1 (length a ys))))))

(attribute length (implicit 0))

;; (define append
;;   ((a tau)
;;    (xs (list a))
;;    (ys (list a)))
;;   (witness (list a)
;;     (case xs
;;       ((nil)
;;         ys)
;;       ((cons z zs)
;;         (cons z (append a zs ys))))))

(define append
  ((a tau)
   (xs (list a))
   (ys (list a)))
  (witness (list a)
    (list.fold xs
      (lambda (_)
        (list a))
      (lambda ()
        ys)
      (lambda (z acc)
        (cons z acc)))))
    ;; (case xs
    ;;   ((nil)
    ;;     ys)
    ;;   ((cons z zs)
    ;;     (cons z (append a zs ys))))))

(attribute append (implicit 0))

;; ;; (define is-null
;; ;;   ((a tau)
;; ;;    (xs (list a)))
;; ;;   (witness bool
;; ;;     (case xs
;; ;;       ((nil)
;; ;;         true)
;; ;;       ((cons _ _)
;; ;;         false))))

(define is-null
  ((a tau)
   (xs (list a)))
  (witness bool
    (list.fold xs
      (lambda (_)
        bool)
      (lambda ()
        true)
      (lambda (_ _)
        false))))
;;     ;; (case xs
;;     ;;   ((nil)
;;     ;;     true)
;;     ;;   ((cons _ _)
;;     ;;     false))))


(attribute is-null (implicit 0))

;; ;; (define map
;; ;;   ((a tau)
;; ;;    (b tau)
;; ;;    (f (hom a b))
;; ;;    (xs (list a)))
;; ;;   (witness (list b)
;; ;;     (case xs
;; ;;       ((nil)
;; ;;         (nil))
;; ;;       ((cons y ys)
;; ;;         (cons
;; ;;           (f y)
;; ;;           (map a b f ys))))))

(define map
  ((a tau)
   (b tau)
   (f (hom a b))
   (xs (list a)))
  (witness (list b)
    (list.fold xs
      (lambda (_)
        (list b))
      (lambda ()
        (nil))
      (lambda (y acc)
        (cons (f y) acc)))))
;;       ;; ((nil)
;;       ;;   (nil))
;;       ;; ((cons y ys)
;;       ;;   (cons
;;       ;;     (f y)
;;       ;;     (map a b f ys))))))

(attribute map (implicit 0 1))

(define return
  ((a tau)
   (x a))
  (witness (list a)
    (list.new x)))
;;     ;; (cons a x (nil a))))

(attribute return (implicit 0))

(define concatenate
  ((a tau)
   (m (list (list a))))
  (witness (list a)
    (list.fold m
      (lambda (_)
        (list a))
      (lambda ()
        (nil))
      (lambda (xs acc)
        (append xs (force acc))))))
;;       ;; ((cons x xs)
;;       ;;   (append x (concatenate a xs))))))

;; ;; (define concatenate
;; ;;   ((a tau)
;; ;;    (m (list (list a))))
;; ;;   (witness (list a)
;; ;;     (case m
;; ;;       ((nil)
;; ;;         (nil))
;; ;;       ((cons x xs)
;; ;;         (append x (concatenate a xs))))))

(attribute concatenate (implicit 0))

(define bind
  ((a tau)
   (b tau)
   (m (list a))
   (k (hom a (list b))))
  (witness (list b)
    (concatenate (map k m))))

(attribute bind (implicit 0 1))

;; (provide head)

;; (provide length)

;; (provide append)

;; (provide is-null)

;; (provide map)

;; (provide return)

;; (provide concatenate)

;; (provide bind)

(end list)
