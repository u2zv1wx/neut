;; preliminary.

(no-implicit-core)

;; for test
;; (ensure libarchive/3.4.2
;;   "https.//www.libarchive.org/downloads/libarchive-3.4.2.tar.gz")

(include "core/notation.neut")

(include "core/option.neut")

(include "core/bool.neut")

(include "core/lazy.neut")

(include "core/identity.neut")

(include "core/string.neut")

(include "core/integer.neut")

(use option)

(use bool)

(use lazy)

;; content.

(section list)

(inductive list ((a tau))
  (nil
    ()
    (list a))
  (cons
    ((_ a)
     (_ (pi () (list a))))
    (list a)))

(keyword list.new)

(notation (list.new)
  (list.nil))

;; (notation (list.new a)
;;   (list.cons * a (list.nil *)))

;; (notation (list.new a rest+)
;;   (list.cons * a (list.new rest+)))

(notation (list.new a)
  (list.cons * a (lazy.thunk * (list.nil *))))

(notation (list.new a rest+)
  (list.cons * a (lazy.thunk * (list.new rest+))))


(define head
  ((a tau)
   (xs (list a)))
  (witness (option a)
    (list.fold a xs
      (λ (_)
        (option a))
      (λ ()
        (none a))
      (λ (h _)
        (some a h)))))

(inductive choice ((a tau))
  (left ()
    (choice a))
  (right ((_ a) (_ (pi () (list a))))
    (choice a)))

(define unchoice
  ((a tau)
   (xs (choice a)))
  (witness (list a)
    (choice.fold a xs
      (λ (_)
        (list a))
      (λ ()
        (nil a))
      (λ (y acc)
        (cons a y acc)))))

;; ;; µF -> FµF
;; (define iso
;;   ((a tau)
;;    (xs (list a)))
;;   (witness (choice a)
;;     (list.fold a xs
;;       (λ (_)
;;         (choice a))
;;       (λ ()
;;         (choice.left a))
;;       (λ (y acc)
;;         (with identity.bind
;;           (let ys
;;             (thunk *
;;               (with identity.bind
;;                 (string.print "foo")
;;                 (unchoice a (force * acc)))))
;;           (choice.right a y ys))))))

(define iso-i64
  ((xs (list i64)))
  (witness (choice i64)
    (list.fold i64 xs
      (λ (_) hole)
      (λ ()
        (choice.left i64))
      (λ (y acc)
        (with identity.bind
          (let ys
            (lambda ()
              (with identity.bind
                (i64.print y)
                (string.print "\n")
                (unchoice i64 (acc)))))
          (choice.right i64 y ys))))))

(inductive tree ((A tau))
  (leaf () (tree A))
  (node ((_ A) (_ (tree A)) (_ (tree  A))) (tree A)))

?tree.fold

;; acc部分の処理がthunkに包まれているのでこのexamineはただちに終了する
;; そこのthunkを入れない場合は遅くなるはず。
;; ……ただちに終了するかわりに、計算がコピーされる (CBNの宿命)。


;; (inductive list-strict ((a tau))
;;   (nil
;;     ()
;;     (list-strict a))
;;   (cons
;;     ((_ a)
;;      (_ (list-strict a)))
;;     (list-strict a)))

;; (inductive choice-strict ((a tau))
;;   (left ()
;;     (choice-strict a))
;;   (right ((_ a) (_ (pi () (list-strict a))))
;;     (choice-strict a)))

;; (define unchoice-strict
;;   ((a tau)
;;    (xs (choice-strict a)))
;;   (witness (list-strict a)
;;     (choice-strict.fold a xs
;;       (λ (_)
;;         (list-strict a))
;;       (λ ()
;;         (list-strict.nil a))
;;       (λ (y acc)
;;         (list-strict.cons a y (acc))))))

;; (define lift
;;   ((a tau)
;;    (xs (list-strict a)))
;;   (witness (choice-strict a)
;;     (list-strict.fold a xs
;;       (λ (_)
;;         (choice-strict a))
;;       (λ ()
;;         (choice-strict.left a))
;;       (λ (y acc)
;;         (with identity.bind
;;           (let ys-lazy (λ () (unchoice-strict a acc)))
;;           (choice-strict.right a y ys-lazy))))))

;; (define lift-i64
;;   ((xs (list-strict i64)))
;;   (witness (choice-strict i64)
;;     (list-strict.fold i64 xs
;;       (λ (_)
;;         (choice-strict i64))
;;       (λ ()
;;         (choice-strict.left i64))
;;       (λ (y acc)
;;         (with identity.bind
;;           (let ys-lazy
;;             (λ ()
;;               (with identity.bind
;;                 (i64.print y)
;;                 (string.print "\n")
;;                 (unchoice-strict i64 acc))))
;;           (choice-strict.right i64 y ys-lazy))))))


;; (attribute head (implicit 0))

(define length
  ((a tau)
   (xs (list a)))
  (witness i64
    (list.fold a xs
      (λ (_)
        i64)
      (λ ()
        0)
      (λ (_ acc)
        (add-i64 1 (acc))))))

(define length-rec-i64
  ((xs (list i64)))
  (choice.fold i64 (iso-i64 xs)
    (λ (_)
      i64)
    (λ ()
      0)
    (λ (y ys)
      (with identity.bind
        (string.print "y : ")
        (i64.print y)
        (string.print "\n---\n")
        (let foo (ys))
        (string.print "---(after)\n")
        (add-i64 1 (length-rec-i64 foo))))))


;; (define head-rec-strict-i64
;;   ((xs (list-strict i64)))
;;   (choice-strict.fold i64 (lift-i64 xs)
;;     (λ (_)
;;       *)
;;     (λ ()
;;       (none i64))
;;     (λ (h _)
;;       (with identity.bind
;;         (i64.print h)
;;         (some * h)))))

;; (attribute length (implicit 0))

(define append
  ((a tau)
   (xs (list a))
   (ys (list a)))
  (witness (list a)
    (list.fold a xs
      (λ (_)
        (list a))
      (λ ()
        ys)
      (λ (z acc)
        (cons a z acc)))))

;; (attribute append (implicit 0))

(define is-null
  ((a tau)
   (xs (list a)))
  (witness bool
    (list.fold a xs
      (λ (_)
        bool)
      (λ ()
        true)
      (λ (_ _)
        false))))


;; (attribute is-null (implicit 0))

(define map
  ((a tau)
   (b tau)
   (f (hom a b))
   (xs (list a)))
  (witness (list b)
    (list.fold a xs
      (λ (_)
        (list b))
      (λ ()
        (nil b))
      (λ (y acc)
        (cons b (f y) acc)))))


;; (attribute map (implicit 0 1))

(define return
  ((a tau)
   (x a))
  (witness (list a)
    (list.new x)))

;; (attribute return (implicit 0))

(define concatenate
  ((a tau)
   (m (list (list a))))
  (witness (list a)
    (list.fold (list a) m
      (λ (_)
        (list a))
      (λ ()
        (nil *))
      (λ (xs acc)
        (append * xs (acc))))))

;; (attribute concatenate (implicit 0))

(define bind
  ((a tau)
   (b tau)
   (m (list a))
   (k (hom a (list b))))
  (witness (list b)
    (concatenate * (map * * k m))))

;; (attribute bind (implicit 0 1))

;; (provide head)

;; (provide length)

;; (provide append)

;; (provide is-null)

;; (provide map)

;; (provide return)

;; (provide concatenate)

;; (provide bind)

(end list)
