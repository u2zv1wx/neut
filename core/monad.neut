(no-implicit-core)

(include library "core/foundation.neut")

(include library "core/functor.neut")

(definition return-type ((m (hom tau tau)))
  (pi
    ((a tau)
     (_ a))
    (m a)))

(definition bind-type ((m (hom tau tau)))
  (pi
    ((a tau)
     (b tau)
     (_ (m a))
     (_ (hom a (m b))))
    (m b)))

(coinductive monad ((m (hom tau tau)))
  (witness-functor ((_ (monad m)))
    (functor m))
  (return ((_ (monad m)))
    (return-type m))
  (bind ((_ (monad m)))
    (bind-type m)))

(inductive left-kan-extension
  ((g (hom tau tau))
   (a tau))
  (make
    ((x tau)
     (_ (g x))
     (_ (hom x a)))
    (left-kan-extension g a)))

;; こっちは書けた。いわゆる「free monad」は型がおかしいけど、こっちはちゃんと書ける。
;; たとえばgがidentityだったら、nodeはx型のtermとx -> tree Aっていうペアから成立していることになって、xとtree Aのペアとみなせて、
;; つまりconsになっている。
;; もしgがA -> (A, A)みたいなやつだったら、xと(Tree A, Tree A)のペアになっていて、だからbinary treeになる。
;; じゃあ、list aの定義をtree id aにしてしまってよさそう、かな？
;; 任意要素へのbranchはどう書く？それはまあ、gのところにlist : tau -> tauを与えればよいのでは。
;; こうすると、list bとb -> tree list aとが与えられることになって、これはつまりlistがfunctorであることからlist (tree list a)を与えることで、
;; だから任意個数のbranchになる。いいね。相当一般的だ。
;; treeというか、もっと一般的な何かであるような。structureみたいな？constructionみたいな？
;; leafのところがbasisになって、nodeのところがextensionみたいになって。
;; list a = construction identity aだし、binary-tree a = construction (X -> X * X) aだし、tree a = construction list aだし、という。
;; もちろんtree-plus a = construction tree aとすることもできて。同様にしてn次元のtreeが定義される。何に使うのかは知らん。
;; というか、これ、inductiveな構造ぜんぶ定義できるまであるんでは？
(inductive tree ((g (hom tau tau)) (a tau))
  (leaf
    ((_ a))
    (tree g a))
  (node
    ((b tau)
     (_ (g b))
     (_ (hom b (tree g a))))
    (tree g a)))

(attribute tree:node
  (implicit 2))

;; g x -> (x -> FFree g a) -> FFree g a

;; note that `(f (tree f a))` is malformed with respect to inductive declaration
;; (inductive tree ((f (hom tau tau)) (a tau))
;;   (leaf ((_ a)) (tree f a))
;;   (node ((_ (f (tree f a)))) (tree f a)))

;; (monad:induction)
