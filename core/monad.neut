(no-implicit-core)

(include library "core/foundation.neut")

(include library "core/functor.neut")

(include library "core/top.neut")

(include library "core/bool.neut")

(define return-type ((m (hom tau tau)))
  (pi
    ((a tau)
     (_ a))
    (m a)))

(define bind-type ((m (hom tau tau)))
  (pi
    ((a tau)
     (b tau)
     (_ (m a))
     (_ (hom a (m b))))
    (m b)))

(coinductive monad ((m (hom tau tau)))
  (witness-functor
    ((_ (monad m)))
    (functor m))
  (return
    ((_ (monad m)))
    (return-type m))
  (bind
    ((_ (monad m)))
    (bind-type m)))

(section monad)

;; monadic composition
(define compose
  ((m hole)
   (a hole)
   (b hole)
   (c hole)
   (M (monad m))
   (f (hom a (m b)))
   (g (hom b (m c))))
  (witness (hom a (m c))
    (lambda (x)
      (with (bind M)
        (let tmp (f x))
        (g tmp)))))

(attribute monad.compose (implicit 0 1 2 3))

(define when
  ((f (hom tau tau))
   (M (monad f))
   (condition bool)
   (comp (f top)))
  (witness (f top)
    (if condition
      comp
      ((return M) top top.unit))))

(attribute monad.when (implicit 0))

(provide monad.compose)

(provide monad.when)

(end monad)
