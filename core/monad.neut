(no-implicit-core)

(include library "core/foundation.neut")

(include library "core/functor.neut")

(include library "core/top.neut")

(include library "core/bool.neut")

(definition return-type ((m (hom tau tau)))
  (pi
    ((a tau)
     (_ a))
    (m a)))

(definition bind-type ((m (hom tau tau)))
  (pi
    ((a tau)
     (b tau)
     (_ (m a))
     (_ (hom a (m b))))
    (m b)))

(coinductive monad ((m (hom tau tau)))
  (witness-functor
    ((_ (monad m)))
    (functor m))
  (return
    ((_ (monad m)))
    (return-type m))
  (bind
    ((_ (monad m)))
    (bind-type m)))

(section monad)

(definition return-plus
  ([a tau]
   [m (hom tau tau)]
   (M (monad m)))
  (witness
    (hom a (m a))
    (lambda (x) ((return M) a x))))

;; こう書けると嬉しい、のかな〜？
;; (definition return-plus
;;   ([a tau]
;;    [m (hom tau tau)]
;;    (M (monad m)))
;;   (witness
;;     (hom a (m a))
;;     (lambda (x) (M.return a x))))

(definition bind-plus
  ([a tau]
   [b tau]
   [m (hom tau tau)]
   (M (monad m)))
  (witness
    (forall
      ((x (m a))
       (f (hom a (m b))))
      (m b))
    (lambda (x f)
      ((monad:bind M) a b x f))))

;; monadic composition
(definition compose
  ([m hole]
   [a hole]
   [b hole]
   [c hole]
   (M (monad m))
   (f (hom a (m b)))
   (g (hom b (m c))))
  (witness (hom a (m c))
    (lambda (x)
      (with (bind-plus M)
        (let tmp (f x))
        (g tmp)))))

(definition when
  ([f (hom tau tau)]
   (M (monad f))
   (condition bool)
   (comp (f top)))
  (witness (f top)
    (if condition
      comp
      ((return-plus M) top:unit))))

(end monad)
