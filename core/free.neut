(no-implicit-core)

(include "core/foundation.neut")

(include "core/functor.neut")

(include "core/monad.neut")

(include "core/base.neut")

(include "core/identity.neut")

(inductive free ((g (hom tau tau)) (a tau))
  (leaf
    ((_ a))
    (free g a))
  (node
    ((b tau)
     (_ (g b))
     (_ (hom b (free g a))))
    (free g a)))

(use free)

(section free)

(define map
  ((g (hom tau tau)))
  (witness (functor-form (free g _))
    (lambda (a b (f (hom a b)) m)
      (free.fold g a m
        (lambda (_ _)
          ((free g _) b))
        (lambda (x)
          (leaf g b (f x)))
        (lambda (p val acc)
          (node g b p val acc))))))

;; f (Free f a) -> Free f aがほしいが。
;; fに構造がないと無理そう？……いけた。
(define in ((f (hom tau tau)) (a tau) (x (f ((free f _) a))))
  (witness ((free f _) a)
    (free.node
      f
      a
      ((free f _) a)
      x
      (lambda (y) y))))

;; Free f a -> f (Free f a)
?free.fold

;; free fがfunctorであることを利用してなんかうまくやれないか？
;; fのところにfree fを自動で与えるようにすればいいだけか？x : free (free f) aとする、ってわけ。
;; その場合は結果のほうはfree f (free (free f) a)みたいになるが。fについてのfoldが使えないから微妙では？
(define out
  ((f (hom tau tau))
   (M (monad f))
   (a tau)
   (x ((free f _) a)))
  (witness (f ((free f _) a))
    (free.fold f a x
      (lambda (_ _)
        (f ((free f _) a)))
      (lambda (x)
        ((functor.map f (monad.witness-functor f M))
           a
           ((free f _) a)
           (lambda (val) (free.leaf f a val))
           ((monad.return f M) a x)))
      (lambda (b v k)
        ((functor.map f (monad.witness-functor f M))
          b
          ((free f _) a)
          (λ (value) (free.in f a (k value)))
          v)))))

(define witness-functor
  ((g (hom tau tau)))
  (witness (functor (free g _))
    (functor.new
      (free g _)
      (free.map g))))

(define return
  ((g (hom tau tau)))
  (witness (return-type (free g _))
    (lambda (_ x)
      (leaf * * x))))

(define bind
  ((g (hom tau tau)))
  (witness (bind-type (free g _))
    (lambda
      ((a tau)
       (b tau)
       (m ((free g _) a))
       (k (hom a ((free g _) b))))
      (free.fold g a m
        (lambda (_ _)
          ((free g _) b))
        (lambda (x)
          (k x))
        (lambda (p val acc)
          (node * * p val acc))))))

(define witness-monad
  ((g (hom tau tau)))
  (witness (monad (free g _))
    (monad.new
      (free g _)
      (free.witness-functor g)
      (free.return g)
      (free.bind g))))

(provide map)

(provide return)

(provide bind)

(provide witness-functor)

(provide witness-monad)

(end free)
