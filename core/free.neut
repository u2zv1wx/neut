(no-implicit-core)

(include library "core/foundation.neut")

(include library "core/functor.neut")

(include library "core/monad.neut")

(include library "core/base.neut")

(inductive free-internal ((g (hom tau tau)) (a tau))
  (leaf
    ((_ a))
    (free-internal g a))
  ;; left Kan extension
  (node
    ((b tau)
     (_ (g b))
     (_ (hom b (free-internal g a))))
    (free-internal g a)))

(use free-internal)

?free-internal:fold

(define free ((g (hom tau tau)))
  (witness (hom tau tau)
    (lambda (a)
      (free-internal g a))))

(section free)

(define map ((g (hom tau tau)))
  (witness (functor-form (free g))
    (lambda (a b (f (hom a b)) m)
      (case m
        ((leaf x)
          (leaf (f x)))
        ((node (p tau) val (cont (hom p ((free g) a))))
          (with let-bind
            (let f' (lambda (x) ((map g) a b f x)))
            (node p val (compose cont f'))))))))

(define witness-functor ((g (hom tau tau)))
  (witness (functor (free g))
    (record (functor (free g))
      (map
        (free:map g)))))

(define return ((g (hom tau tau)))
  (witness (return-type (free g))
    (lambda (_ x)
      (leaf x))))

(define bind ((g (hom tau tau)))
  (witness (bind-type (free g))
    (lambda
      ((a tau)
       (b tau)
       (m ((free g) a))
       (k (hom a ((free g) b))))
      (case m
        ((leaf x)
          (k x))
        ((node p val cont)
          (with let-bind
            (let cont-then-k
              (lambda ((x p))
                ((bind g) a b (cont x) k)))
            (node p val cont-then-k)))))))

(define witness-monad ((g (hom tau tau)))
  (witness (monad (free g))
    (record (monad (free g))
      (witness-functor
        (free:witness-functor g))
      (return
        (free:return g))
      (bind
        (free:bind g)))))

(provide map)

(provide return)

(provide bind)

(provide witness-functor)

(provide witness-monad)

(end free)
