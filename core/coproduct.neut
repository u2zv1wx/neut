(no-implicit-core)

(include "core/notation.neut")

(include "core/functor.neut")

(include "core/monad.neut")

(section coproduct)

(inductive coproduct
  ((e tau)
   (a tau))
  (left ((_ e))
    (coproduct e a))
  (right ((_ a))
    (coproduct e a)))

(define map
  ((e tau)
   (a tau)
   (b tau)
   (f (hom a b))
   (m (coproduct e a)))
  (witness (coproduct e b)
    (coproduct.fold * * m
      (lambda (_ _)
        (coproduct e b))
      (lambda (err)
        (left * * err))
      (lambda (val)
        (right * * (f val))))))

;; (attribute map (implicit 0 1 2))

(define return
  ((e tau)
   (a tau)
   (x a))
  (witness (coproduct e a)
    (right * * x)))

;; (attribute return (implicit 0 1))

(define bind
  ((e tau)
   (a tau)
   (b tau)
   (comp (coproduct e a))
   (k (hom a (coproduct e b))))
  (witness (coproduct e b)
    (coproduct.fold * * comp
      (lambda (_ _)
        (coproduct e b))
      (lambda (err)
        (left * * err))
      (lambda (val)
        (k val)))))

;; (attribute bind (implicit 0 1 2))

(define throw
  ((e tau)
   (a tau)
   (err e))
  (witness (coproduct e a)
    (left * * err)))

;; (attribute throw (implicit 0 1))

(define either
  ((e tau))
  (witness (hom tau tau)
    (lambda ((a tau))
      (coproduct e a))))

(define either-map
  ((e tau))
  (witness (functor-form (either e))
    (lambda (_ _ f m)
      (coproduct.map * * * f m))))

(define either-return
  ((e tau))
  (witness (return-type (either e))
    (lambda (_ x)
      (coproduct.return * * x))))

(define either-bind
  ((e tau))
  (witness (bind-type (either e))
    (lambda (_ _ m k)
      (coproduct.bind * * * m k))))

(define witness-functor
  ((e tau))
  (witness (functor (either e))
    (functor.new
      (either e)
      (either-map e))))

(define witness-monad
  ((e tau))
  (witness (monad (either e))
    (monad.new
      (either e)
      (witness-functor e)
      (either-return e)
      (either-bind e))))

(provide throw)

(provide witness-monad)

(end coproduct)
