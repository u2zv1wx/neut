(no-implicit-core)

;; define basic notations

;; synonyms
(keyword type)

(notation type tau)

(keyword universe)

(notation universe tau)

(keyword forall)

(notation forall pi)

(keyword Π)

(notation Π pi)

(keyword *)

(notation * hole)

(keyword switch)

(notation switch enum-elimination)

(keyword lambda)

(notation lambda pi-introduction)

(keyword λ)

(notation λ pi-introduction)

(keyword witness)

(notation (witness t e)
  ((lambda ((x t)) x) e))

(keyword hom)

(notation (hom t) t)

(notation (hom t rest+)
  (pi
    ((_ t))
    (hom rest+)))

(keyword theorem)

(notation (theorem x t e)
  (let (x t) e))

(keyword assume)

(notation assume lambda)

(keyword if)

(notation (if b e1 e2)
  (switch b
    (bool.true
      e1)
    (bool.false
      e2)))

(keyword define)

(notation (define f xts e)
  (let f (fix f xts e)))

(notation (define f e)
  (let f e))

(keyword to-type-list)

(notation (to-type-list t)
  ((_ t)))

(notation (to-type-list t t+)
  ((_ t) (splice (to-type-list t+))))

;; (keyword arrow)

;; (notation (arrow (t+) cod)
;;   (pi (to-type-list t+) cod))

(keyword sigma)

(notation (sigma (xt+) t)
  (Π
    ((c tau)
     (_ (Π (xt+ (_ t)) c)))
    c))

(keyword ∑)

(notation ∑ sigma)

(keyword product)

(notation (product t+)
  (Π
    ((c tau)
     (_ (Π (to-type-list t+) c)))
    c))

(keyword to-hole-list)

(notation (to-hole-list e)
  ((_ *)))

(notation (to-hole-list e e+)
  ((_ *) (splice (to-hole-list e+))))

(keyword sigma-introduction)

(notation (sigma-introduction)
  (λ
    ((elim-result-type tau)
     (k (Π () elim-result-type)))
    (k)))

(notation (sigma-introduction e+)
  (λ
    ((elim-result-type tau)
     (k (Π (to-hole-list e+) elim-result-type)))
    (k e+)))

(keyword sigma-elimination)

(notation (sigma-elimination () e1 e2)
  (e1 * (λ () e2)))

(notation (sigma-elimination (xt+) e1 e2)
  (e1 * (λ (xt+) e2)))

(keyword tuple)

(notation tuple sigma-introduction)

(keyword construct)

(notation construct sigma-introduction)

(keyword destruct)

(notation (destruct e xts rest+)
  (sigma-elimination xts e (with identity.bind rest+)))

;; (notation (if b e1 e2)
;;   (switch b
;;     (1 e1)
;;     (default e2)))

;; (notation (if b e1 e2)
;;   (switch b
;;     (bool:true e1)
;;     (bool:false e2)))
