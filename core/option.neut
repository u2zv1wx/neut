(no-implicit-core)

(include "foundation.neut")

(include "functor.neut")

(include "monad.neut")

(section option)

(inductive option ((a tau))
  (none ()
    (option a))
  (some ((x a))
    (option a)))

(define map
  (witness (functor-form option)
    (lambda (_ _ f m)
      (case m
        ((none)
          (none))
        ((some x)
          (some (f x)))))))

;; (satisfies-functor option), (satisfies-return option)みたいに書いてもいいかも。

(define return
  (witness (return-type option)
    (lambda (_ x)
      (some x))))

(define bind
  (witness (bind-type option)
    (lambda (_ _ m k)
      (case m
        ((none)
          (none))
        ((some x)
          (k x))))))

(define from-option
  ((a tau)
   (x a)
   (m (option a)))
  (witness a
    (case m
      ((none)
        x)
      ((some y)
        y))))

(attribute from-option (implicit 0))

?functor.unfold

;; (coinductive functor ((f (hom tau tau)))
;;   (map ((_ (functor f)))
;;     (functor-form f)))

;; (coinductive sample-record ((f (hom tau tau)) (g i64))
;;   (map ((_ (functor f)))
;;     (functor-form f)))

;; ?sample-record.unfold

?monad.unfold

(define witness-functor
  (witness (functor option)
    (record (functor option)
      (map
        option.map))))

(define witness-monad
  (witness (monad option)
    (record (monad option)
      (witness-functor
        option.witness-functor)
      (return
        option.return)
      (bind
        option.bind))))

(end option)


;; 射影はこういう実装になるはずだけど。推論が通ってねえ。
;; やっぱcaseの推論は修正する必要がある。
;; (let k (functor-form option)
;;   (case option.witness-functor
;;     ((functor.unfold f ma base-value) (ma base-value))))

;; (define witness-fake
;;   (witness (fake option)
;;     (fake.unfold
;;       fake
;;       (lambda ((_ (fake option))) option.map)
;;       (unsafe.cast (hom tau tau) (fake option) (lambda (x) x)))))
      ;; (map
      ;;   option.map))))

;; (let pohe (functor-form option)
;;   (case witness-fake
;;     ((fake.unfold f ma base-value) (ma base-value))))
