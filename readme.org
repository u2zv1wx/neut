#+TITLE: Neut
Neut is a dependently-typed programming language based on [[https://en.wikipedia.org/wiki/Calculus_of_constructions][the Calculus of Constructions (CoC)]]. The interesting point I believe is that this language determines how to allocate/free memory at compile-time, without extra annotations to the source language. In other words, Neut in its source language is an ordinary lambda-calculus after all (imagine something like Haskell, Coq, Agda, Lean), and at the same time it handles memory without using, for example:

- explicit malloc/free,
- garbage collection,
- region-based memory management.

Theoretically, this is made possible by translating the source language into a dependent-and-linear variant of [[https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf][Call-by-Push-Value]]. The crucial point of the translation is to see that knowing the type of a term is knowning how to eta-expand the term, which in turn means knowing how to copy/discard the term. In the translation, a type is not erased, but *translated into a computationally-meaningful term that copies/discards the terms of the type*. Those who are interested in these theoretical things can find further details in the [[#theoretical-notes][section about the theory of Neut]].

Practically, this means that you can write your program in the ordinary lambda calculus without any extra restrictions/annotations, and at the same time are allowed to pursue performance in the language via e.g. borrowing or linearity. The source code doesn't need esoteric annotations for the compiler to infer how to use resources. Nor does the world stop all of a sudden by GC. You have full control over resource allocation.

Here I briefly summerize the basic properties of Neut before diving into the details:

- A compiled language
- The output is [[https://llvm.org/docs/LangRef.html][LLVM IR]] / assembly / object binary (the last two are via clang)
- The type system is CoC + recursion + int + float + enum + array + struct
- The evaluation strategy is call-by-value
- Every tail call is optimized into a loop
- The memory management is statically determined at compile time (Can be optimized via borrowing and linearity)
- Has inductive/coinductive type (despite the fact that the core logic is not CoIC but CoC)

* Table of Contents                                                    :TOC:
- [[#some-hopefully-illuminating-examples][Some (Hopefully) Illuminating Examples]]
  - [[#type-based-mallocfree-determination][Type-Based malloc/free Determination]]
  - [[#manual-optimization-via-borrowing][Manual Optimization via Borrowing]]
  - [[#automatic-optimization-via-mallocfree-cancellation][Automatic Optimization via malloc/free Cancellation]]
  - [[#summary][Summary]]
- [[#installation][Installation]]
- [[#syntax-and-semantics-of-statements][Syntax and Semantics of Statements]]
  - [[#attribute][attribute]]
  - [[#constant][constant]]
  - [[#definelet][define/let]]
  - [[#ensure][ensure]]
  - [[#enum][enum]]
  - [[#include][include]]
  - [[#inductive][inductive]]
  - [[#coinductive][coinductive]]
  - [[#introspect][introspect]]
  - [[#keywordnotation][keyword/notation]]
  - [[#useunuse][use/unuse]]
  - [[#sectionend][section/end]]
  - [[#verify][verify]]
- [[#syntax-and-semantics-of-inference-rules][Syntax and Semantics of Inference Rules]]
  - [[#tau][tau]]
  - [[#upsilon][upsilon]]
  - [[#pi][pi]]
  - [[#fix][fix]]
  - [[#constant-1][constant]]
  - [[#hole][hole]]
  - [[#int][Int]]
  - [[#float][Float]]
  - [[#enum-1][Enum]]
  - [[#array][Array]]
  - [[#struct][Struct]]
- [[#auxiliary-syntax][Auxiliary Syntax]]
  - [[#sigma-type][Sigma Type]]
  - [[#with-notation-do-notation-with-explicit-monadic-bind][With Notation: do-Notation with Explicit Monadic Bind]]
  - [[#record][Record]]
  - [[#inductive-and-coinductive-types][Inductive and Coinductive types]]
- [[#macro-expansion][Macro Expansion]]
- [[#compiler-commands][Compiler Commands]]
  - [[#archive][archive]]
  - [[#build][build]]
  - [[#check][check]]
  - [[#complete][complete]]
- [[#where-is-][Where is ...?]]
  - [[#unsigned-integers][Unsigned Integers?]]
  - [[#typeclass][Typeclass?]]
  - [[#proof-related-stuff][Proof-Related Stuff?]]
  - [[#the-universe-hierarchy][The Universe Hierarchy?]]
- [[#theoretical-notes][Theoretical Notes]]
  - [[#compile-time-memory-usage-determination][Compile-Time Memory Usage Determination]]
  - [[#box-modality-polarity-and-closure-conversion][Box Modality, Polarity, and Closure Conversion]]
  - [[#realizing-inductivecoinductive-types-within-coc-including-nested-mutual-or-higher-ones][Realizing Inductive/Coinductive Types within CoC (including nested, mutual, or higher ones)]]
  - [[#universe-hierarchy-and-the-weakly-normalizing-fragment][Universe Hierarchy and the Weakly-Normalizing Fragment]]
  - [[#unified-pattern-resolution-in-dependent-type-inference]["Unified" Pattern Resolution in Dependent Type Inference]]
  - [[#a-simple-implementation-of-mutually-recursive-functions][A Simple Implementation of Mutually-Recursive Functions]]
- [[#contribution][Contribution]]
  - [[#to-implementation][To Implementation]]
  - [[#to-documentation][To Documentation]]
  - [[#to-theory][To Theory]]
- [[#appendix][Appendix]]
  - [[#llvm-ir-for-the-first-example-print-without-borrowing][LLVM IR for the First Example (Print without Borrowing)]]
  - [[#llvm-ir-for-the-second-example-print-with-borrowing][LLVM IR for the Second Example (Print with Borrowing)]]
- [[#references][References]]

* Some (Hopefully) Illuminating Examples

** Type-Based malloc/free Determination
Here I will firstly show an "inefficient" version of some code pieces. After that, I will show a more efficient version of the code, and compare resulting LLVM IR.

Note that the code here is written in a rather verbose way to make things as explicit as possible to the readers. You don't have to be that verbose in actual code.

The following code prints the string ="a"= for the three times:
#+BEGIN_SRC scheme
(with identity.bind
  (let str "a")          ;; define a variable `str : string` with content `"hello"`
  (let _ (string.print str)) ;; you can also write just `(print str)` instead of `(let _ (print str))`
  (let _ (string.print str))
  (string.print str))
#+END_SRC
The `(with identity.bind (...))` is the same as so-called do-notation in Haskell or other languages, specilized to the identity monad.
# You may note that the language doesn't require the IO monad. This is because the evaluation strategy of Neut is CBV.

By running =$ neut build --no-alloc-cancellation --emit llvm filename.neut=, we obtain schematically the following LLVM IR (the =--no-alloc-cancellation= is to disable certain optimization that we will see [[#memory-reuse-via-linearity][later]]):
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; Repeat the following for the 3 times:
  ;;   <memory allocation for the string>
  ;;   <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;;   <write the string into stdout>
  ;;   <memory deallocation for the string>
}
#+END_SRC
The non-schematic, actual output can also be be found in the [[#llvm-ir-for-the-first-example][appendix]]. I chose not to write the IR here since the output is a bit long (59 lines).

The resulting LLVM IR creates a string in memory, print it, and free it for the three times. In other words, the IR creates two copies of the original string. This is because the variable =str= is used for the three times; The content of a variable is copied to create n instances when the variable is used for the n times. If the variable isn't used at all (n = 0), the content of the variable is discarded (deallocated). If the variable is used exactly once, or linearly (n = 0), the content of the variable is used without any discarding/copying operation.

The way how a variable is copied is determined by the type of the variable. For example, if the type of a variable is the array type as in the example above, the copying operation is something that you would do in C to copy an array (allocation then value insertion). If the type is an immediate type like an integer type, the "copying" operation is the one that uses the original value for the clone value. Every type determines how to copy/discard the type of a value of the type, including the type of type itself.

This is the basics of the behavior of resource copying/discarding of this language. As you can easily imagine, this naive copying/discarding would result in an inefficient object code. We often use a variable more than once. If those uses of a variable result in copying the content every time, the performance of the resulting code would be nothing but a disaster. Thankfully, there is a workaround for this performance problem.

** Manual Optimization via Borrowing
The point of the workaround is nothing special: If those copying/discarding result from using variables in non-linear way, we just have to use those variables in linear way. Let's go back to the first example code:
#+BEGIN_SRC scheme
(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
#+END_SRC
We would like to use the variable =str= linear way. To this end, we just request =string.print= to include the argument =str= in its return value. So, the type of =string.print= shouldn't be something like =string -> top= - where the =top= is the unit type - but should be =string -> top * string=. More specifically, the implementation of =string.print= should be something like (in pseudo-code):
#+BEGIN_SRC text
string.print :: string -> top * string
string.print str = do
  {print the string `str` without consuming it}
  return (unit, str)
#+END_SRC
With that definition of =string.print=, we can use the variable =str= linear way (again, in pseudo-code):
#+BEGIN_SRC text
let str1 = "a";
let (_, str2) := string.print str1;
let (_, str3) := string.print str2;
let (_, str4) := string.print str3;
0
#+END_SRC
Note that the variables =str1=, =str2=, =str2=, and =str3= are used exactly once, and =str4= for the 0 time. Therefore, the copying operation doesn't occur in the code above. Also, since the =str4= is defined but not used, the =str4= is discarded immediately after its definition:
#+BEGIN_SRC text
let str1 = "a";                         -- allocation of `str1`
let (_, str2) := string.print str1;     -- print `str1`, return it as a element of a tuple, and rename it as `str2`
let (_, str3) := string.print str2;     -- print `str2`, return it as a element of a tuple, and rename it as `str3`
let (_, str4) := string.print str3;     -- print `str3`, return it as a element of a tuple, and rename it as `str4`, then deallocate `str4`
0                                       -- return 0
#+END_SRC

Now we have seen that those redundant copying/discarding can be avoided by writing the code in the manner above. There still remains a problem: code cluttering. It would be much nicer to have more sophisticated notation of that code pattern. Towards that end, firstly note that we can use the same name for the variables =str1=, =str2=, =str3=, and =str4= thanks to variable shadowing:
#+BEGIN_SRC text
let str = "a";
let (_, str) := string.print str;
let (_, str) := string.print str;
let (_, str) := string.print str;
0
#+END_SRC
Now, we just have to introduce a notation that translates:
#+BEGIN_SRC text
let foo := string.print &str;
#+END_SRC
into:
#+BEGIN_SRC text
let (foo, str) := string.print &str;
#+END_SRC

With this notation, our running example is rewritten as follows:
#+BEGIN_SRC text
let str = "a";
let _ := string.print &str;
let _ := string.print &str;
let _ := string.print &str;
0
#+END_SRC

And this is the notation that is implemented in Neut. Indeed, the following is a valid code of Neut:
#+BEGIN_SRC scheme
(with identity.bind
  (let str "a")
  (let _ (string.print &str))
  (let _ (string.print &str))
  (let _ (string.print &str))
  (i64 0))
#+END_SRC
where the last =(i64 0)= is to tell the compiler that the type of =0= is =i64= and not, e.g. =i32=. This notation is "borrowing" in Neut. Note that borrowing is nothing but a syntactic translation. Borrowing has nothing to do with, for example, the type system, or the operational semantics, of Neut. Indeed, this syntactic translation is processed in the stage of parsing in the compiler.

OK, then, how does the resulting LLVM IR change? Is it faster now? Let us compile the code above by running =$ neut build --no-alloc-cancellation --emit llvm filename.neut=. The output is short enough to include it here:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; memory allocation
  %_12034 = getelementptr i8, i8* null, i64 1
  %_12035 = ptrtoint i8* %_12034 to i64
  %_12036 = call fastcc i8* @malloc(i64 %_12035)
  ;; create the string "a" (i.e. write the character 'a' to the allocated memory)
  %_12037 = bitcast i8* %_12036 to [1 x i8]*
  %_12038 = inttoptr i8 97 to i8* ;; a = 97
  %_12039 = ptrtoint i8* %_12038 to i8
  %_12040 = getelementptr [1 x i8], [1 x i8]* %_12037, i32 0, i64 0 ;; where to write 'a'
  store i8 %_12039, i8* %_12040 ;; write a
  ;; write the string into stdout for the three times
  %_12041 = inttoptr i64 1 to i8* ;; this `1` stands for stdout
  %_12042 = inttoptr i64 1 to i8* ;; this `1` is the length of the string in bytes
  %_12043 = call fastcc i8* @write(i8* %_12041, i8* %_12036, i8* %_12042)
  %_12044 = inttoptr i64 1 to i8*
  %_12045 = inttoptr i64 1 to i8*
  %_12046 = call fastcc i8* @write(i8* %_12044, i8* %_12036, i8* %_12045)
  %_12047 = inttoptr i64 1 to i8*
  %_12048 = inttoptr i64 1 to i8*
  %_12049 = call fastcc i8* @write(i8* %_12047, i8* %_12036, i8* %_12048)
  ;; memory deallocation
  %_12050 = bitcast i8* %_12036 to [1 x i8]*
  %_12051 = getelementptr [1 x i8], [1 x i8]* %_12050, i32 0, i32 0
  %_12052 = load i8, i8* %_12051
  %_12053 = bitcast [1 x i8]* %_12050 to i8*
  call fastcc void @free(i8* %_12053)
  %_12054 = inttoptr i8 %_12052 to i8*
  ;; return 0
  %_12055 = inttoptr i64 0 to i8*
  %_12056 = ptrtoint i8* %_12055 to i64
  ret i64 %_12056
}
#+END_SRC
or more schematically:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout for the three times>
  ;; <memory deallocation for the string>
  ;; <return 0>
}
#+END_SRC
The former LLVM IR is the actual output except for the comments like ";; memory allocation", which are inserted after compilation for explanatory purposes. The point here is that the string stored at =%12036= (the second argument of =@write=) is reused without copying, as expected. The resulting assembly code is reasonably small too:
#+BEGIN_SRC asm
	.section	__TEXT,__text,regular,pure_instructions
	.macosx_version_min 12, 15
	.globl	_main                   ## -- Begin function main
	.p2align	4, 0x90
_main:                                  ## @main
	.cfi_startproc
## %bb.0:
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset %rbx, -15
	movl	$1, %edi                 # 1-byte memory allocation (you can ignore the lines above this line)
	callq	_malloc
	movq	%rax, %rbx
	movb	$97, (%rax)              # write 'a' (= 97) to the allocated memory
	movl	$1, %edi                 # set the arguments for `_write`
	movl	$1, %edx
	movq	%rax, %rsi
	callq	_write                   # ... and call `_write` (i.e. print 'a')
	movl	$1, %edi                 # (repeat)
	movl	$1, %edx
	movq	%rbx, %rsi
	callq	_write
	movl	$1, %edi                 # (repeat)
	movl	$1, %edx
	movq	%rbx, %rsi
	callq	_write
	movq	%rbx, %rdi               # free the allocated memory
	callq	_free
	xorl	%eax, %eax
	popq	%rbx
	retq
	.cfi_endproc
                                        ## -- End function
.subsections_via_symbols
#+END_SRC
In short: the resulting code is faster in that it is free from the redundant copying/discarding we saw in the first example.

This is how Neut controls resources efficiently, without modifying the type system of the source language (the ordinary dependent lambda calculus).

** Automatic Optimization via malloc/free Cancellation
Neut's static, type-based malloc/free determination enables not only the "manual" optimization we have just seen, but also another "automatic" optimization. Remember the first example:
#+BEGIN_SRC scheme
(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (let _ (string.print str))
  (i64 0))
#+END_SRC
and the output IR of this example code:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; Repeat the following for the 3 times:
  ;;   <memory allocation for the string>
  ;;   <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;;   <write the string into stdout>
  ;;   <memory deallocation for the string>
}
#+END_SRC
The code is already judged to be inefficient in that it allocates/deallocates memory unnecessarily. In other words, it is inefficient in that the code deallocates the memory that can actually be reused.

But if the sizes of memory being allocated/deallocated are known at compile-time, isn't it possible to compare the sizes of them in compile-time and emit a code that reuses the allocated memory?

And it is indeed possible. When the option =--no-alloc-cancellation= is not passed, the compiler translates code pieces something like this:
#+BEGIN_SRC llvm
define TYPE @FUNCTION_NAME(...) {
  (...)
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>    -- (*1)
  ;; <memory allocation for the string>      -- (*2)
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>
  (...)
}
#+END_SRC
into something like this:
#+BEGIN_SRC llvm
define TYPE @FUNCTION_NAME(...) {
  (...)
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>
  (...)
}
#+END_SRC
In other words, the compiler can cancel the memory deallocation at =(*1)= and the allocation at =(*2)=, reusing the allocated memory in its continuation. This is automatic malloc/free cancellation. By this "fallback" optimization, the compiler can emit performant code even if a user wrote code in an "inefficient" way.

Note that the "create the string" parts are not optimized away from the resulting LLVM IR, in contrast to the one of borrowing:
#+BEGIN_SRC llvm
define i64 @main() {
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <write the string into stdout>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>
  ;; <return 0>
}
#+END_SRC
Although the compiler can cancel memory allocations/deallocations, it cannot cancel its accompanying initialization process (at least currently). If you do need performance, you need to write code in the linear/borrowing style.

** Summary
- Neut statically determines malloc/free at compile-time via type information.
- The content of a variable is
  - discarded if and only if the variable isn't used at all.
  - untouched if and only if the variable is used exactly once (i.e. used linearly).
  - copied if and only if the variable is used more than once.
- Linearity results in an efficient code.
- Non-linearity results in an inefficient code.
- Borrowing can be used as a convenient syntactic tool when accomplishing linearity.
- Redundant malloc/free can be reduced by automatic malloc/free cancellation.
- Borrowing-based, or "manually" optimized code is faster than cancellation-based, or "automatically" optimized code.

* Installation
The currently supported platforms are: Linux (x64), macOS (x64).

Make sure you have already installed [[https://docs.haskellstack.org/en/stable/README/][stack]] and [[https://clang.llvm.org/][clang]]. Then, clone the repository and build it:
#+BEGIN_SRC shell
$ git clone https://github.com/u2zv1wx/neut
$ cd neut
$ ./install.sh 0.1.0.0
#+END_SRC
Also make sure that you have =~/.local/bin= in your =$PATH=.

To uninstall, you just have to remove =~/.local/bin/neut= and =~/.local/share/neut=; Neut won't clutter your system.

* Syntax and Semantics of Statements
A program of Neut is a list of statements. Each statement is one of the following statements described in this section.

# Every example in this section is a valid program in itself. You can [[#build][build]] and run the code to check the behavior.

** attribute
The =attribute= statement modifies the state of the compiler so that given identifier has given attributes.

*** Example
#+BEGIN_SRC scheme
(define id ((a tau) (x a)) x)

(id top top.unit) ;; ~> top.unit

;; (id top.unit) ;; ~> type error

(attribute id (implicit 0)) ;; => Set the first argument of `id` to be implicit

;; (id top top.unit) ;; ~> type error

(id top.unit) ;; ~> {translated into `(id hole top.unit)`} ~> results in top.unit

(@id top top.unit) ;; ~> top.unit
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(attribute ID ATTR)
#+END_SRC
*** Semantics
When evaluated, the =(attribute x attr)= statement modifies the state of compiler so that the [[#upsilon][variable]] =x= has specified attribute =attr=. Currently, the only attribute that can be specified is =(implicit NUM ... NUM)=.

If the implicit information of a variable =x= is set to be =(implicit NUM ... NUM)=, the compiler inserts [[#hole][holes]] at the specified indices of the arguments of [[#pi][function-application]] =(x e1 ... en)=.

If a variable is prefixed by =@= when its used, its implicit information is ignored.

** constant
The =constant= statement declares an external constant.

*** Example
#+BEGIN_SRC scheme
(constant os.file-descriptor tau)

(constant os.stdin os.file-descriptor)

(constant os.fork (pi () i64))
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(constant ID TERM)
#+END_SRC
*** Semantics
When evaluated, the =(constant x t)= statement modifies the state of the compiler so that a [[#constant][constant]] =x= of type =t= is available for later use. Declared constants can then be available for use as in the same way of ordinary [[#upsilon][variables]]. Every constant must have distinct names. This statement is currently intended for internal use, such as for implementation of syscalls. External constants (FFI) might also be supported in future release via this statement.

** define/let
The =define= / =let= statement evaluates given term and binds the result to a variable.

*** Example
#+BEGIN_SRC scheme
(let foo (i64 10)) ;; define a variable `foo` to be `10`

(i64.print foo) ;; ~> 10 (this is equivalent to `(let _ (i64.print foo))`)

(let (bar i64) 20) ;; define with type annotation

(i64.print bar) ;; ~> 20

;; ordinary definition (i.e. 1-mutual definition)
(define fact ((x i64))
  (if (icmp-sle-i64 x 0) ;; compare (by less-than-or-equal) two `i64`s as signed integers
    1
    (mul-i64 x (fact (sub-i64 x 1))))) ;; the self-referential variable "fact" is available in its function body

(i64.print (fact foo)) ;; ~> 3628800 (= 10!)

;; 2-mutual definition
(define
  (even (n)      ;; argument without type annotation
    (if (icmp-eq-i64 n 0) ;; compare (by equal) two `i64`s
      true
      (odd (sub-i64 n 1))))
  (odd ((n i64)) ;; argument with type annotation
    (if (icmp-eq-i64 n 0)
      false
      (even (sub-i64 n 1)))))

(i64.print
  (if (even 10)
    100
    1000)) ;; ~> 100

;; 1-mutual definition (i.e. generalized notation of "ordinary" definition)
(define
  (fact ((x i64))
    (if (icmp-sle-i64 x 0)
      1
      (mul-i64 x (fact (sub-i64 x 1))))))

(i64.print (fact 10)) ;; ~> 3628800


;; 0-mutual definition is also valid
(define)
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(let (ID TERM) TERM)

(let ID TERM)

(define
  (ID ((ID TERM) ... (ID TERM))
    TERM)
  ...
  (ID ((ID TERM) ... (ID TERM))
    TERM))

;; alternative notation for (define (ID ((ID TERM) ... (ID TERM)) TERM))
(define ID ((ID TERM) ... (ID TERM)) TERM)
#+END_SRC
*** Semantics
When parsed, the =(let x e)= statement does nothing.

When evaluated, the =(let x e)= statement checks the type of the term =e=, evaluates the term =e=, then defines a variable =x= with =e= as its content. =x= is available in the remaining program. The type of =x= can be specified to be =t= by writing =(let (x t) e)=.

The 0-mutual definition does nothing.

When parsed, 1-mutual definitions =(define (f ((x A) ... (x A)) e))= are translated into =(let f (fix f ((x A) ... (x A)) e))=, and then evaluated as ordinary let statement. Convenient 1-mutual definitions =(define f ((x A) ... (x A)) e)= are translated into =(define (f ((x A) ... (x A)) e))=, and then processed as ordinary 1-mutual definitions.

When parsed, n-mutual definitions (n >= 2) are also translated into appropriate let-and-fix.

If user input is not parsed as a statement when it is supposed to be, the compiler firstly interpret it as a term =e=, and then processes a statement =(let _ e)=.

** ensure
The =ensure= statement fetches the content of the specified URL for later use.

*** Example
#+BEGIN_SRC scheme
;; extracts the content of URL into ~/.local/share/neut/NEUT_VERSION/library/some-library/0.2.0.0
(ensure some-library/0.2.0.0
  "https://example.com/some-library-0.2.0.0.tar.gz")

(include library "some-library/0.2.0.0/some-file.neut")
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(ensure ID "URL_OF_LIBRARY")
#+END_SRC
*** Semantics
When parsed, the =(ensure path "URL")= statement fetches the content of the specified URL, extracts the content into =~/.local/share/neut/NEUT_VERSION/path=, assuming that the format of the archive is =tar.gz=. The =path= must be a valid path string. Every path separator in =path= is treated as "real" one. For example, if the =path= is =some-library/0.2.0.0=, the content of the archive is extracted into =~/.local/share/neut/NEUT_VERSION/some-library/0.2.0.0=. Incidentally, this means that users can choose where to install third-party libraries.

If the target directory of archive extraction already exists, the =ensure= statement does nothing.

This statement is intended to be used in harmony with the [[#include][include]] statement.

Archives specified in =(ensure path "URL")= is intended to be ones created via the [[#archive][archive]] subcommand.

** enum
The =enum= statement declares a new enum-type and its values.
*** Example
#+BEGIN_SRC scheme
(enum choice left right) ;; defines choice : tau, choice.left : choice, and choice.right : choice

(let x choice.left)

(i64.print
  (enum-elimination x
    (choice.left
      (i64 1))
     choice.right
      (i64 2))) ;; ~> 1

(i64.print (unsafe.cast choice i64 choice.left)) ;; ~> 0

(i64.print (unsafe.cast choice i64 choice.right)) ;; ~> 1

(enum foo
  (a 100)
  b
  (c 20)
  d
  e
  (f 103))

(i64.print (unsafe.cast foo i64 foo.a)) ;; ~> 100
(i64.print (unsafe.cast foo i64 foo.b)) ;; ~> 101
(i64.print (unsafe.cast foo i64 foo.c)) ;; ~> 20
(i64.print (unsafe.cast foo i64 foo.d)) ;; ~> 21
(i64.print (unsafe.cast foo i64 foo.e)) ;; ~> 22
(i64.print (unsafe.cast foo i64 foo.f)) ;; ~> 103
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(enum ID ID_INT ... ID_INT)

ID_INT := ID | (ID INT)
#+END_SRC
*** Semantics
When parsed, a =(enum x a1 ... an)= statement updates the state of the compiler so that the specified enum-type =x : tau= and the enum-values =x.a1, ..., x.an : x= can be used in the succeeding code.

Every enum-value has its internal i64 value (discriminant). Those discriminant value can be extracted by using the unsafe cast, though not recommended in ordinary use.

Discriminant value starts from =0= by default, and increments one by one. The "current" value of this process can be modified by writing, e.g. =(enum foo a (b 100) c d)=. In this example, the discriminant value of =c= is defined to be =101=.

The discriminant values of a enum-type must be distinct.

** include
The =include= statement temporary transfers the parsing process to the file specified by given path, if necessary.
*** Example
#+BEGIN_SRC scheme
(include "relative/path/from/this/file/to/some/file.neut")

(include "relative/path/from/this/file/to/some/file.neut") ;; including an already included file; do nothing

(include library "relative/path/from/library/dir/to/some/file.neut")
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(include "PATH_TO_FILE")

(include library "PATH_TO_FILE")
#+END_SRC
*** Semantics
When parsed, the =(include path)= statement transfers current parsing process to the parsing process of the file specified by the =path=. After the transferred parsing process is finished, the suspended remaining parsing process is resumed.

The path is computed relative to the current file by default. The =(include library path)= statement can be used to set the base path of this path calculation to be the library path of Neut (i.e. =~/.local/share/neut/NEUT_VERSION/library=).

If the file at the =path= is already included, this statement does nothing.

When including a file, both [[#useunuse][the prefix environment]] and [[#sectionend][the section environment]] must be empty.

Cyclic inclusion is invalid.

** inductive
The =inductive= statement defines an inductive type, its introduction rules, and its elimination rule (fold).
*** Example
#+BEGIN_SRC scheme
(inductive nat ()
  (zero () (nat))
  (succ (_ (nat)) (nat)))

(inductive list ((a tau))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))

(define length
  ((a tau)
   (xs (list a)))
  (case xs
    ((list.nil)
      0)
    ((list.cons _ ys)
      (add-i64 1 (length a ys)))))

(let (xs (list i64)) (list.cons 10 (list.cons 20 (list.nil)))

(i64.print (length xs)) ;; ~> 2
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(inductive LEAF ((LEAF TREE) ... (LEAF TREE))
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE)
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE))

;; n-mutual inductive type
(inductive
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE))
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)))
#+END_SRC
*** Semantics
When parsed, the =inductive= statement is translated into =let= statements that defines (1) the inductive type, (2) the introduction rules (or the constructors of the inductive type), and (3) the elimination rule (or the "fold" of the type). For example, consider the following =inductive= statement:
#+BEGIN_SRC scheme
(inductive list ((a tau))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))
#+END_SRC
Given this statement, the compiler generates [[#definelet][let]] statements that defines the followings:
1. The inductive type =list : Pi (a : tau). tau=
2. The introduction rules (constructors) of the type:
   - =list.nil : Pi (a : tau). list a=, where the =a : tau= is set to be [[#attribute][implicit]].
   - =list.cons : Pi (a : tau, _ : a, _ : list a). list a=, where the =a : tau= is set to be [[#attribute][implicit]].
3. The elimination rule of the type:
   - =list.fold : (Π ((a tau) (_ (list a)) (list (arrow (tau) tau)) (_ (arrow () (F a))) (_ (arrow (a (F a)) (F a)))) (F a))=, where the =a : tau= is set to be [[#attribute][implicit]].
The elimination rule might seem intimidating. In the actual code, however, you don't have to use that generated term since the rule [[#case][case]] can be used in harmony with the rule [[#fix][fix]] to achieve the expressiveness of =fold=, as in the function =length= in the example code above.

When used in the domain of a constructor, the inductive type being defined must be occurred covariantly.

The codomain of each constructor must be of the form =(a e1 ... en)=, where the =a= is the inductive type being defined. If =e1, ..., en= are not the same as the argument of the inductive type, such a constructor is defined to be generalized. An inductive type with at least one generalized constructor is defined to be generalized.

Nested inductive type is allowed if and only if the outer, already-defined inductive type is neither mutual nor generalized.

** coinductive
The =coinductive= statement defines a coinductive type, its elimination rules, and its introduction rule (unfold).
*** Example
#+BEGIN_SRC scheme
(coinductive stream ((A tau))
  (head
    ((_ (stream A)))
    A)
  (tail
    ((_ (stream A)))
    (stream A)))

(let stream-from-zero
  (stream.unfold
    (lambda ((x tau)) x)
    (lambda ((x i64)) x)
    (lambda ((x i64)) (add-i64 x 1))
    0))

(i64.print (stream.head (stream.tail (stream.tail (stream.tail stream-from-zero)))))
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(coinductive LEAF ((LEAF TREE) ... (LEAF TREE))
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE)
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE))

;; n-mutual coinductive type
(coinductive
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE))
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)))
#+END_SRC
*** Semantics
When parsed, the =coinductive= statement is translated into =let= statements that defines (1) the coinductive type, (2) the elimination rules (or the destructors of the coinductive type), and (3) the introduction rule (or the "unfold" of the type). For example, consider the following =coinductive= statement:
#+BEGIN_SRC scheme
(coinductive stream ((A tau))
  (head
    ((_ (stream A)))
    A)
  (tail
    ((_ (stream A)))
    (stream A)))
#+END_SRC
Given this statement, the compiler generates [[#definelet][let]] statements that defines the followings:
1. The coinductive type =stream : Pi (a : tau). tau=
2. The elimination rules (destructors) of the type:
   - =stream.head : Pi (a : tau, _ : stream a). a=, where the =a : tau= is set to be [[#attribute][implicit]].
   - =stream.tail : Pi (a : tau, _ : stream a). stream a=, where the =a : tau= is set to be [[#attribute][implicit]].
3. The introduction rule of the type:
   - =stream.unfold : (Π ((A tau) (F (arrow (tau) tau)) (_ (arrow ((F A)) A)) (_ (arrow ((F A)) (F A))) (_ (F A))) (stream A))=, where the =a : tau= is set to be [[#attribute][implicit]].

When used in the codomain of a destructor, the coinductive type being defined must be occurred covariantly.

The domain of each constructor must be of the form =(a x1 ... xn)=, where the =a= is the inductive type being defined, and =x1, ..., xn= are the argument of the coinductive type. Note that there doesn't exist such a thing like "generalized coinductive type".

Nested coinductive type is allowed if and only if the outer, already-defined coinductive type is not mutual.

As a side note, internally, a =coinductive= statement is implemented via a translation into an =inductive= statement. For example, the example of =stream= above is translated into the following statement:
#+BEGIN_SRC scheme
(inductive stream ((A tau))
  (unfold ((F (hom tau tau))
           (h (hom (F A) A))
           (t (hom (F A) (F A)))
           (_ (F A)))
          (stream A)))
#+END_SRC
with the definitions of corresponding destructors:
#+BEGIN_SRC scheme
(define stream.head ((A tau) (x (stream A)))
  (case x
    ((stream.unfold _ h _ v) (h v))))

(attribute stream.head (implicit 0))

(define stream.tail ((A tau) (x (stream A)))
  (witness (stream A)
    (case x
      ((stream.unfold F h t v)
        (stream.unfold F h t (t v))))))

(attribute stream.tail (implicit 0))
#+END_SRC

** introspect
The =introspect= statement introspects the state of the compiler and selects statements by those information.
*** Example
#+BEGIN_SRC scheme
(introspect OS
  (linux
    (include library "constant/linux.neut"))
  (darwin
    (include library "constant/darwin.neut")))
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(introspect COMPILE_TIME_VAR (ID STATEMENT ... STATEMENT) ... (ID STATEMENT ... STATEMENT))
#+END_SRC
*** Semantics
When parsed, the =(introspect var (v1 stmt-list-1) ... (vn stmt-list-n))= statement introspects the value of the compile-time variable =var= and select a list of statement according to it.

If the corresponding value is not found in the clause list, this statement does nothing.

The =var= must be a valid compile-time variable. Valid compile-time variables and its possible values currently available are as in the table below:

| compile-time variable | possible values |
|-----------------------+-----------------|
| OS                    | linux, darwin   |
| architecture          | x64             |

** keyword/notation
The =keyword= statement registers a keyword for notation. The =notation= statement registers a notation.
*** Example
#+BEGIN_SRC scheme
(keyword λ)

(notation λ pi-introduction)

(keyword if)

(notation (if b e1 e2)
  (enum-elimination b
    (bool.true e1)
    (bool.false e2)))
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(keyword LEAF)

(notation TREE TREE)
#+END_SRC
*** Semantics
When parsed, the statement =(keyword x)= modifies the state of the compiler so that the =x= is treated as a keyword. This affects the result of [[#macro-expansion][macro expansion]] in the succeeding code.

When parsed, the statement =(notation FROM TO)= modifies the state of the compiler so that the mapping =FROM ~> TO= is recognized as a notation. This affects the result of [[#macro-expansion][macro expansion]] in the succeeding code.

See [[#macroexpansion][the section on macro expansion]] for the details of keywords and notations.

** use/unuse
The =use= / =unuse= statement registers a prefix for name resolution.
*** Example
#+BEGIN_SRC scheme
(let foo.bar.buz (i64 10))

;; (i64.print buz)      ;; ~> undefined variable: `buz`
;; (i64.print bar.buz)  ;; ~> undefined variable: `bar.buz`
(i64.print foo.bar.buz) ;; ~> 10

(use foo)

;; (i64.print buz)      ;; ~> undefined variable: `buz`
(i64.print bar.buz)     ;; ~> 10
(i64.print foo.bar.buz) ;; ~> 10

(use foo.bar)

(i64.print buz)         ;; ~> 10
(i64.print bar.buz)     ;; ~> 10
(i64.print foo.bar.buz) ;; ~> 10

(unuse foo)

(i64.print buz)         ;; ~> 10
;; (i64.print bar.buz)  ;; ~> undefined variable: `bar.buz`
(i64.print foo.bar.buz) ;; ~> 10
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(use LEAF)

(unuse LEAF)
#+END_SRC
*** Semantics
When parsed, the statement =(use PREFIX)= inserts =PREFIX= at the head of the prefix environment, which is a list of prefixes.

When parsed, the statement =(unuse PREFIX)= removes =PREFIX= from the prefix environment. If the =PREFIX= is not contained in the environment, the =unuse= statement does nothing.

The prefix environment modifies [[#upsilon][how the compiler parses a variable]].

** section/end
*** Example
#+BEGIN_SRC scheme
(section pohe)

(let foo (i64 10))

(section qux)

(let bar (i64 20))

(i64.print foo)          ;; ~> 10
(i64.print pohe.foo)     ;; ~> 10
(i64.print bar)          ;; ~> 20
(i64.print qux.bar)      ;; ~> 20
(i64.print pohe.qux.bar) ;; ~> 20

(end qux)

(i64.print foo)          ;; ~> 10
(i64.print pohe.foo)     ;; ~> 10
;; (i64.print bar)       ;; ~> undefined variable: `bar`
(i64.print qux.bar)      ;; ~> 20
(i64.print pohe.qux.bar) ;; ~> 20

(end pohe)

;; (i64.print foo)       ;; ~> undefined variable: `foo`
(i64.print pohe.foo)     ;; ~> 10
;; (i64.print bar)       ;; ~> undefined variable: `bar`
;; (i64.print qux.bar)   ;; ~> undefined variable: `qux.bar`
(i64.print pohe.qux.bar) ;; ~> 20
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(section LEAF)

(end LEAF)
#+END_SRC
*** Semantics
The list of statement
#+BEGIN_SRC scheme
(section FOO)
(let x1 e1)
...
(let xn en)
(end FOO)
#+END_SRC
is equivalent to:
#+BEGIN_SRC scheme
(use FOO)
(let FOO.x1 e1)
...
(let FOO.xn en)
(unuse FOO)
#+END_SRC
In other words, the =section= / =end= statement
- insert the [[#useunuse][use/unuse]] statements at the beginning and the end of the section
- add the name of the section as a prefix of the variables defined by =let= / =define= statements
- keep all the other statements in the section untouched

Each =section= statement must be paired with an =end= statement with the corresponding name.

** verify
The =verify= statement normalizes given term.
*** Example
#+BEGIN_SRC scheme
(verify ((λ ((x tau)) x) top)) ;; ~> verification succeeded (0.000027 seconds)

;; a proof for: forall proposition A, A implies A
(let some-theorem
  (Π ((A tau))
    (hom A A))
  (assume (_)
    (assume (x) x)))

;; check if the proof of the theorem is weakly-normalizing
(verify some-theorem) ;; ~> verification succeeded (0.000003 seconds)
#+END_SRC
*** Syntax
#+BEGIN_SRC scheme
(verify TERM)
#+END_SRC
*** Semantics
The =verify= statement normalizes given term after type checking. The term is reduced so that it doesn't contain any redexes. If the term doesn't terminate, this normalization doesn't terminate.

The evaluation strategy of the normalization process is the applicative order; the call-by-value strategy cannot be used here since it might "overlook" redexes in a lambda abstraction.

This statement can be used to check if the given term is contained in the weakly-normalizing fragment of the CoC without the universe hierarchy.

* Syntax and Semantics of Inference Rules

** tau

** upsilon

** pi

** fix

** constant

** hole

** Int

** Float

** Enum

** Array

** Struct

* Auxiliary Syntax

** Sigma Type

** With Notation: do-Notation with Explicit Monadic Bind

** Record

** Inductive and Coinductive types
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec eleifend tellus euismod erat accumsan, nec euismod sem placerat. Ut eu lacinia arcu, id imperdiet lacus. Integer feugiat lacus mattis, dictum nunc nec, interdum justo. Fusce sed dui id orci faucibus elementum. Vivamus sit amet sapien a lorem efficitur posuere suscipit in lacus. Praesent eget sagittis nisi, id vehicula elit. Vestibulum laoreet odio ex, a aliquet justo consectetur quis. Aenean laoreet vehicula libero id varius. Vivamus condimentum, sem sed sollicitudin placerat, nulla enim faucibus odio, gravida commodo velit mi ac sapien. Integer feugiat diam in lectus porttitor, sit amet viverra velit malesuada.

* Macro Expansion

* Compiler Commands

** archive

** build

** check

** complete

* Where is ...?

** Unsigned Integers?

** Typeclass?

** Proof-Related Stuff?

** The Universe Hierarchy?

* Theoretical Notes

** Compile-Time Memory Usage Determination
(to be written later)

** Box Modality, Polarity, and Closure Conversion
(to be written later)

** Realizing Inductive/Coinductive Types within CoC (including nested, mutual, or higher ones)
(to be written later)

** Universe Hierarchy and the Weakly-Normalizing Fragment
(to be written later)

** "Unified" Pattern Resolution in Dependent Type Inference
(to be written later)

** A Simple Implementation of Mutually-Recursive Functions
(to be written later)

* Contribution

** To Implementation

** To Documentation

** To Theory

* Appendix

** LLVM IR for the First Example (Print without Borrowing)
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  %_11875 = getelementptr i8, i8* null, i64 1
  %_11876 = ptrtoint i8* %_11875 to i64
  %_11877 = call fastcc i8* @malloc(i64 %_11876)
  %_11878 = bitcast i8* %_11877 to [1 x i8]*
  %_11879 = inttoptr i8 97 to i8*
  %_11880 = ptrtoint i8* %_11879 to i8
  %_11881 = getelementptr [1 x i8], [1 x i8]* %_11878, i32 0, i64 0
  store i8 %_11880, i8* %_11881
  %_11882 = inttoptr i64 1 to i8*
  %_11883 = inttoptr i64 1 to i8*
  %_11884 = call fastcc i8* @write(i8* %_11882, i8* %_11877, i8* %_11883)
  %_11885 = bitcast i8* %_11877 to [1 x i8]*
  %_11886 = getelementptr [1 x i8], [1 x i8]* %_11885, i32 0, i32 0
  %_11887 = load i8, i8* %_11886
  %_11888 = bitcast [1 x i8]* %_11885 to i8*
  call fastcc void @free(i8* %_11888)
  %_11889 = inttoptr i8 %_11887 to i8*
  %_11890 = getelementptr i8, i8* null, i64 1
  %_11891 = ptrtoint i8* %_11890 to i64
  %_11892 = call fastcc i8* @malloc(i64 %_11891)
  %_11893 = bitcast i8* %_11892 to [1 x i8]*
  %_11894 = inttoptr i8 97 to i8*
  %_11895 = ptrtoint i8* %_11894 to i8
  %_11896 = getelementptr [1 x i8], [1 x i8]* %_11893, i32 0, i64 0
  store i8 %_11895, i8* %_11896
  %_11897 = inttoptr i64 1 to i8*
  %_11898 = inttoptr i64 1 to i8*
  %_11899 = call fastcc i8* @write(i8* %_11897, i8* %_11892, i8* %_11898)
  %_11900 = bitcast i8* %_11892 to [1 x i8]*
  %_11901 = getelementptr [1 x i8], [1 x i8]* %_11900, i32 0, i32 0
  %_11902 = load i8, i8* %_11901
  %_11903 = bitcast [1 x i8]* %_11900 to i8*
  call fastcc void @free(i8* %_11903)
  %_11904 = inttoptr i8 %_11902 to i8*
  %_11905 = getelementptr i8, i8* null, i64 1
  %_11906 = ptrtoint i8* %_11905 to i64
  %_11907 = call fastcc i8* @malloc(i64 %_11906)
  %_11908 = bitcast i8* %_11907 to [1 x i8]*
  %_11909 = inttoptr i8 97 to i8*
  %_11910 = ptrtoint i8* %_11909 to i8
  %_11911 = getelementptr [1 x i8], [1 x i8]* %_11908, i32 0, i64 0
  store i8 %_11910, i8* %_11911
  %_11912 = inttoptr i64 1 to i8*
  %_11913 = inttoptr i64 1 to i8*
  %_11914 = call fastcc i8* @write(i8* %_11912, i8* %_11907, i8* %_11913)
  %_11915 = bitcast i8* %_11907 to [1 x i8]*
  %_11916 = getelementptr [1 x i8], [1 x i8]* %_11915, i32 0, i32 0
  %_11917 = load i8, i8* %_11916
  %_11918 = bitcast [1 x i8]* %_11915 to i8*
  call fastcc void @free(i8* %_11918)
  %_11919 = inttoptr i8 %_11917 to i8*
  %_11920 = inttoptr i64 0 to i8*
  %_11921 = ptrtoint i8* %_11920 to i64
  ret i64 %_11921
}
#+END_SRC

** LLVM IR for the Second Example (Print with Borrowing)
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; memory allocation
  %_12034 = getelementptr i8, i8* null, i64 1
  %_12035 = ptrtoint i8* %_12034 to i64
  %_12036 = call fastcc i8* @malloc(i64 %_12035)
  ;; create the string "a" (i.e. write the character 'a' to the allocated memory)
  %_12037 = bitcast i8* %_12036 to [1 x i8]*
  %_12038 = inttoptr i8 97 to i8* ;; a = 97
  %_12039 = ptrtoint i8* %_12038 to i8
  %_12040 = getelementptr [1 x i8], [1 x i8]* %_12037, i32 0, i64 0 ;; where to write 'a'
  store i8 %_12039, i8* %_12040 ;; write a
  ;; write the string into stdout for the three times
  %_12041 = inttoptr i64 1 to i8* ;; this `1` stands for stdout
  %_12042 = inttoptr i64 1 to i8* ;; this `1` is the length of the string in bytes
  %_12043 = call fastcc i8* @write(i8* %_12041, i8* %_12036, i8* %_12042)
  %_12044 = inttoptr i64 1 to i8*
  %_12045 = inttoptr i64 1 to i8*
  %_12046 = call fastcc i8* @write(i8* %_12044, i8* %_12036, i8* %_12045)
  %_12047 = inttoptr i64 1 to i8*
  %_12048 = inttoptr i64 1 to i8*
  %_12049 = call fastcc i8* @write(i8* %_12047, i8* %_12036, i8* %_12048)
  ;; memory deallocation
  %_12050 = bitcast i8* %_12036 to [1 x i8]*
  %_12051 = getelementptr [1 x i8], [1 x i8]* %_12050, i32 0, i32 0
  %_12052 = load i8, i8* %_12051
  %_12053 = bitcast [1 x i8]* %_12050 to i8*
  call fastcc void @free(i8* %_12053)
  %_12054 = inttoptr i8 %_12052 to i8*
  ;; return 0
  %_12055 = inttoptr i64 0 to i8*
  %_12056 = ptrtoint i8* %_12055 to i64
  ret i64 %_12056
}
#+END_SRC

* References
- L. de Moura, J. Avigad, S. Kong, and C. Roux, Elaboration in Dependent Type Theory, [[https://arxiv.org/abs/1505.04324]], 2015.
- P. Levy, Call-by-Push-Value: A Subsuming Paradigm, Ph. D. thesis, Queen Mary College, 2001.
