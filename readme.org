#+TITLE: neut
neut is a dependently-typed programming language based on [[https://ncatlab.org/nlab/show/calculus+of+constructions][the Calculus of Constructions (CoC)]]. The interesting point is that this language determines how to allocate/deallocate memory at compile-time, without extra annotations to the type system. In other words, neut in its source language is the ordinary lambda-calculus after all (imagine something like Haskell, OCaml, Idris, Coq, Agda, or Lean), and at the same time it handles memory without using, for example, explicit malloc/free, or garbage collection.

Theoretically, this is made possible by translating every type of the language into a function that can be used to copy/discard the terms of the type; in this language, a type is not erased, but translated into a computationally-meaningful term.

Practically, this means that you can write your program in the ordinary lambda-calculus without any extra restrictions or annotations, and at the same time are allowed to control how resources are used in the program. If you want an ordinary-lambda-calculus based programming language with a human-predictable semantics (including its memory management), this might be for you.

Here I briefly summarize the basic properties of neut before diving into the details:

- A compiled language
- The output is [[https://llvm.org/docs/LangRef.html][LLVM IR]] / assembly / executable binary (the last two are via clang)
- The type system is CoC + fix + int + float + enum - universe hierarchy (+ unsafe cast)
- The type inference algorithm is based on [[https://arxiv.org/abs/1505.04324][the one of Lean]]
- The evaluation strategy is call-by-value
- Memory allocation/deallocation is statically determined at compile time

* Table of Contents                                                    :TOC_3:
- [[#ideas][Ideas]]
  - [[#memory-management-based-on-linearity][Memory Management Based on Linearity]]
    - [[#basics][Basics]]
    - [[#types-as-exponentializers][Types as Exponentializers]]
    - [[#notes-on-closures][Notes on Closures]]
    - [[#notes-on-polymorphic-functions][Notes on Polymorphic Functions]]
    - [[#summary-so-far][Summary So Far]]
  - [[#manual-optimization-via-borrowing][Manual Optimization via Borrowing]]
  - [[#manual-optimization-via-noetic-computation-new-in-0200][Manual Optimization via Noetic Computation (New in 0.2.0.0)]]
  - [[#automatic-optimization-via-mallocfree-cancellation][Automatic Optimization via malloc/free Cancellation]]
  - [[#summary][Summary]]
- [[#installation][Installation]]
- [[#language-overview][Language Overview]]
  - [[#basic-structure][Basic Structure]]
  - [[#example-code][Example Code]]
- [[#syntax-and-semantics-of-the-meta-language][Syntax and Semantics of the Meta Language]]
  - [[#statements][Statements]]
    - [[#define-macro-define-macro-variadic][define-macro, define-macro-variadic]]
    - [[#define-prefix-remove-prefix][define-prefix, remove-prefix]]
    - [[#dry-expand][dry-expand]]
    - [[#ensure][ensure]]
    - [[#include][include]]
    - [[#introspect][introspect]]
    - [[#sectionend][section/end]]
    - [[#statement][statement]]
    - [[#useunuse][use/unuse]]
  - [[#terms][Terms]]
    - [[#variable][variable]]
    - [[#implication][implication]]
    - [[#if][if]]
    - [[#constant][constant]]
    - [[#integer][integer]]
    - [[#leafnode][leaf/node]]
  - [[#notes-on-quote-unquote-and-splice][Notes on Quote, Unquote and Splice]]
- [[#syntax-and-semantics-of-the-object-language][Syntax and Semantics of the Object Language]]
  - [[#statements-1][Statements]]
    - [[#enum][enum]]
    - [[#define][define]]
    - [[#define-prefix-remove-prefix-1][define-prefix, remove-prefix]]
    - [[#reduce][reduce]]
    - [[#useunuse-1][use/unuse]]
    - [[#sectionend-1][section/end]]
  - [[#terms-1][Terms]]
    - [[#tau][tau]]
    - [[#variable-1][variable]]
    - [[#π][Π]]
    - [[#constant-1][constant]]
    - [[#int][int]]
    - [[#float][float]]
    - [[#enum-1][enum]]
    - [[#question][question]]
    - [[#derangement][derangement]]
  - [[#auxiliary-statements][Auxiliary Statements]]
    - [[#define-data][define-data]]
    - [[#define-codata][define-codata]]
    - [[#define-resource-type][define-resource-type]]
  - [[#auxiliary-terms][Auxiliary Terms]]
    - [[#asterisk][asterisk]]
    - [[#sigma][sigma]]
    - [[#with][with]]
    - [[#case-case-noetic][case, case-noetic]]
    - [[#partial-application][Partial Application]]
- [[#compiler-subcommands][Compiler Subcommands]]
  - [[#archive][archive]]
    - [[#example][Example]]
    - [[#notes][Notes]]
  - [[#build][build]]
    - [[#example-1][Example]]
    - [[#notes-1][Notes]]
  - [[#check][check]]
    - [[#example-2][Example]]
    - [[#notes-2][Notes]]
- [[#contribution][Contribution]]
  - [[#development][Development]]
    - [[#the-structure-of-the-compiler][The Structure of the Compiler]]
  - [[#donation][Donation]]
- [[#contact][Contact]]
- [[#things-left-undone][Things Left Undone]]
- [[#appendix][Appendix]]
  - [[#llvm-ir-for-the-first-example][LLVM IR for the First Example]]
  - [[#llvm-ir-for-the-second-example][LLVM IR for the Second Example]]

* Ideas

** Memory Management Based on Linearity
*** Basics
Let's see how neut manages resources. The following code prints the string "a" for the 3 times:
#+BEGIN_SRC neut
; download the core library
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
#+END_SRC
The =(with identity.bind (...))= is the same as the do-notation in Haskell or other languages, specialized to the identity monad.

By running =neut build --no-alloc-cancellation --emit llvm filename.neut=, we obtain schematically the following LLVM IR (the =--no-alloc-cancellation= is to disable certain optimization that we will see later):
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ; Repeat the following for the 3 times:
  ;   <memory allocation for the string>
  ;   <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;   <write the string into stdout>
  ;   <memory deallocation for the string>
}
#+END_SRC
The non-schematic, actual output can also be found in the [[#llvm-ir-for-the-first-example][appendix]]. I chose not to write the IR here since the output is a bit long (59 lines including comments).

The resulting LLVM IR creates a string in memory, print it, and free it for the 3 times. The point here is that the resulting code creates 2 copies of the original string. This is because the variable =str= is used for the 3 times; The content of a variable is copied to create n instances when the variable is used for the n times (n > 1). If the variable isn't used at all (n < 1), the content of the variable is discarded (deallocated). If the variable is used exactly once, or linearly (n = 1), the content of the variable is used without any discarding/copying operation.

By translating the source calculus in the way sketched above, every variable is ensured to be used linearly, except for the ones in the functions that realize those copying/discarding operations. Thus, by checking that those exponentializers use resources properly, we can ensure that the target calculus of this translation handles memory properly too. Then we check that those exponentializers are indeed sane - This is the basic storyline.

The way how a variable is copied/discarded is determined by the type of the variable. For example, if the type of a variable is the array type as in the example above, the copying operation is something that you would do in C to copy an array (memory allocation followed by value insertion). If the type is an immediate type like an integer type, the "copying" operation is the one that uses the original value for the cloned value. Every type is translated into a term that copies/discards the terms of the type, including the type of the types.

*** Types as Exponentializers
Let us go a little deeper. Consider the following schematic user input:
#+BEGIN_SRC haskell
let str : string := "a";
{- A CODE THAT USES `str` for the 3 times -}
#+END_SRC
Intuitively, what the compiler does is to translate the term above into the following term:
#+BEGIN_SRC haskell
let str : string := "a";
let (discard-string, copy-string) := TRANSLATE(string);
let (str1, tmp) := copy-string(str);
let (str2, str3) := copy-string(tmp);
{- THE CODE THAT USES `str1`, `str2`, AND `str3` LINEARLY -}
#+END_SRC
Note that the second line extracts =discard-string= and =copy-string= from the tuple =TRANSLATE(string)=. Every type =X= is translated in this manner; the pair of =discard-X= and =copy-X=. These exponentializers - something that allows us to create n copies of =x= from a single =x= - are used in its continuation so that every variable of this type (=str= in this example) is used linearly.

Incidentally, in the actual implementation, the result of =TRANSLATE(string)= is not a pair, but a function as in the pseudo-code below:
#+BEGIN_SRC haskell
cartesian-string i e :=
  if i == 0
  then discard-string(e)
  else copy-string(e)
#+END_SRC
which is used in the following manner:
#+BEGIN_SRC haskell
let str : string := "a";
let cartesian-string := TRANSLATE(string);
let (str1, tmp) := cartesian-string(1, tmp);
let (str2, str3) := cartesian-string(1, tmp);
{- THE CODE THAT USES `str1`, `str2`, AND `str3` LINEARLY -}
#+END_SRC
This alternative translation frees us from having to create a tuple every time when we translate a type. Thus, in the actual implementation, every type is translated into a closed function, which is then lowered to a pointer (1 word).

It would be worth noting here that these functions like =cartesian-string= are β-reduced (inlined) aggressively; These are ordinary functions that can be defined in the target language, after all.

*** Notes on Closures
You may be wondering now: "How can we copy/discard a closure? In ordinary closure conversion, a lambda-abstraction is translated into a pair consists of (1) all the free variables in the abstraction, and (2) a pointer to an appropriately-arranged closed function. How can that tuple be copied/discarded just by using type information like =i64 -> bool=, which is seemingly useless here? How should we translate the type =i64 -> bool=?"

That is a valid question. The key to give the answer to this question is generalizing the concept of "all the free variables". Consider the following term:
#+BEGIN_SRC haskell
λ (a : type). λ (x : a). λ (y : i64). (x, y)
#+END_SRC
In ordinary closure conversion, the free variables of =λ (y : i64). (x, y)= is calculated to be =[x]= without making a fuss. Here, however, we generalize the concept so that we "trace" all the free variables included in the type of every free variable. In this case, for example, note that the type of =x= is =a=, which is again a free variable if it occurs in =λ (y : i64). (...)=, and thus this =a= is also considered to be a free variable. Since the type of =a= is =type=, which has no free variables, our tracing stops here, resulting a chain of the free variables =[a : type, x : a]=.

Note that every result of this procedure is necessarily "closed". That is, if the list =[x1 : A1, ..., xn : An]= is a result of this tracing process, then the set of free variables in =A{i}= is a subset of ={x1, ..., x{i-1}}=. In this way, we extract a closed chain from a lambda-abstraction.

Let us continue the example of =λ (y : i64), (x, y)=. Using the closed chain we have just calculated, the compiler translates this lambda-abstraction conceptually as follows:
#+BEGIN_SRC text
(∑ [a : type, x : a], (a, x), LABEL_OF_A_CLOSED_FUNCTION)
#+END_SRC
That is, a lambda-abstraction is translated into a tuple consists of *(0) the type of its closed chain*, (1) its closed chain, and (2) a pointer to an appropriately-arranged closed function. Now, remember that every type is translated into a term that copies/discards the terms of the type. Also remember that every type is translated into a function pointer, which can be copied/discarded without any malloc/free operations. Thus, we can generate a function that copies/discards a closure conceptually as follows:
#+BEGIN_SRC haskell
cartesian-closure i closure = do
  -- extract the element of the closure, freeing the outer 3-word tuple
  let (typeOfChain, chain, label) := closure;
  if i == 0
  then do
    -- discard the chain using the type information
    let _ := typeOfChain(0, chain);
    -- note that both typeOfChain and label are immediate
    return ()
  else do
    -- copy the chain using the type information
    let (chainA, chainB) := typeOfChain(1, chain);
    -- construct the 2 closures, and the wrapper tuple (thus do malloc for the 3 times)
    return ((typeOfChain, chainA, label), (typeOfChain, chainB, label))
#+END_SRC
Thus, we can translate every Π-type into the function =cartesian-closure=. Every Closure is copied/discarded in the same way, regardless of its actual details. So, information like =i64= or =bool= in =i64 -> bool= is indeed useless here; It simply isn't necessary since every closure knows how to copy/discard itself.

The remaining piece is how a type of a closed chain like =∑ [a : type, x : a]= is translated. This is where eta-expansion plays its role. Suppose we have a term =e= of type =∑ [a : type, x : a]=. Since we already know the type of =e=, we can eta-expand this term as follows:
#+BEGIN_SRC haskell
let (a, x) := e in
(a, x)
#+END_SRC
Now, at this point, note that if we can copy both =a : type= and =x : a=, we can then copy =e= as follows:
#+BEGIN_SRC haskell
let (a, x) := e in
let (a1, a2) := {COPY_a} a in
let (x1, x2) := {COPY_x} x in
((a1, x1), (a2, x2))
#+END_SRC
Thus, thanks to eta-expansion, the problem of copying/discarding the terms of type =∑ [a : type, x : a]= is reduced into the one of copying/discarding the terms of type =a : type= and =x : a=.

The actual copying function is constructed inductively as follows. The starting point is the following term:
#+BEGIN_SRC haskell
let (a, x) := e in
((a, x), (a, x))
#+END_SRC
Firstly we copy =x= - using its type =a= - so that =x= is used linearly:
#+BEGIN_SRC haskell
let (a, x) := e in
let (x1, x2) := a(1, x) in
((a, x1), (a, x2))
#+END_SRC
This creates a term that uses =x= linearly. Then we copy the term =a= - using its type =type= - so that =a= is used linearly:
#+BEGIN_SRC haskell
let (a, x) := e in
let (a1, tmp) := type(1, a) in
let (a2, a3) := type(1, tmp) in
let (x1, x2) := a1(1, x) in
((a2, x1), (a3, x2))
#+END_SRC
where the =type= is a term defined as follows:
#+BEGIN_SRC haskell
type i a =
  if i == 0
  then ()     -- non-linear (affine) use of `a`
  else (a, a) -- non-linear (relevant) use of `a`
#+END_SRC
which is resource-safe since a type is translated into a function pointer. This creates a term that uses both =a= and =x= linearly.

Note that, by its construction, the first element of a closed chain doesn't contain any free variables, and therefore can be copied without using any free variables.

In conclusion, the copying part of =∑ [a : type, x : a]= is defined by the following term:
#+BEGIN_SRC haskell
copy-sigma sig :=
  let (a, x) := sig in
  let (a1, tmp) := type(1, a) in
  let (a2, a3) := type(1, tmp) in
  let (x1, x2) := a1(1, x) in
  ((a2, x1), (a3, x2))
#+END_SRC
By using this term, we can now copy the tuple =(a, x)= in the closure =(∑ [a : type, x : a], (a, x), LABEL)=. The discarding function is defined similarly. That is, we change the starting point to
#+BEGIN_SRC haskell
let (a, x) := e in
()
#+END_SRC
and do the same inductive procedure. Now we just have to construct the following term:
#+BEGIN_SRC haskell
cartesian-sigma i sig :=
  if i == 0
  then discard-sigma sig
  else copy-sigma sig
#+END_SRC
and translate =∑ [a : type, x : a]= into the =cartesian-sigma= above. In this way we can copy/discard a closure.

# Incidentally, the 3-element representation of a closure can be justified proof-theoretically. Let us consider a depenedent variant of CBPV, where the inference rules =thunk= / =force= can be used only when the assumption is empty:
# #+BEGIN_SRC text
# (empty) |- e : N
# ----------------------- (thunk)
# (empty) |- thunk e : ↓N

# (empty) |- e : ↓N
# ----------------------- (force)
# (empty) |- force e : N
# #+END_SRC
# In such a calculus, we have the following type-isomorphism:
# #+BEGIN_SRC text
# Π (x : A). B ~ ∑ (C : Univ). C × ↓(Π (x : A, env : C). B)
# #+END_SRC
# Regarding the =C= part as the type of environment, this type-isomorphism (left-to-right) can be understood as a description of closure conversion.

*** Notes on Polymorphic Functions
Or you may be wondering: "What if a function is polymorphic? If the size of an argument is not fixed, how can that function copy the term?"

That is again a valid question, and here comes dependent-type. Firstly, remember that a polymorphic function in dependent-type theory is nothing but an ordinary function with an argument of type =tau=, where =tau= is the type of types. For example, the following is a polymorphic function that creates a pair of any type:
#+BEGIN_SRC neut
; to-tuple : Π (a : tau, x : a). a * a
(define to-tuple ((a tau) (x a))
  (tuple x x))
#+END_SRC
This function =to-tuple= is, for example, used as follows:
#+BEGIN_SRC neut
(to-tuple i64 1)          ; ~> (tuple 1 1)
(to-tuple bool bool.true) ; ~> (tuple bool.true bool.true)
(to-tuple string "a")     ; ~> (tuple "a" "a")
#+END_SRC
Note that the type =i64= is used in exactly the same way as =1=; A type is nothing but an ordinary term of type =tau=. And these very terms =i64=, =bool=, and =string= in the example are translated into ordinary closed functions that copies/discards the terms of the types. The =to-tuple= function can therefore copy the resource =x= of type =a= conceptually as follows:
#+BEGIN_SRC haskell
to-tuple :: Π (a : tau, x : a). a * a
to-tuple a x :=
  let (x1, x2) := a(1, x) in
  (x1, x2)
#+END_SRC
Thus the answer to the question is: Polymorphic functions can copy/discard its polymorphic argument since the type, which is guaranteed to be passed as an argument, contains information on how to copy/discard the terms of the type.

*** Summary So Far
- A variable is copied/discarded so that the variable is used linearly
- A type is lowered into a function pointer that copies/discards the terms of the type
- Closures can be copied/discarded since they know how to copy/discard itself
- Polymorphic function can copy/discard its polymorphic arguments thanks to the information provided by its type argument

This is the basic behavior of neut's proof-theoretic memory management. As you might already be aware, this naive copying/discarding can result in an inefficient object code. We often use a variable more than once, as in the example of =str=:
#+BEGIN_SRC neut
(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
#+END_SRC
We can't say the resulting LLVM IR of this code is efficient enough; We can't ignore those redundant copy operations.

Fortunately, there is a workaround for this performance problem.

** Manual Optimization via Borrowing
The point of the workaround is straightforward: If those copying/discarding operations result from using variables non-linearly, we simply have to use variables linearly. Let's go back to the first example code:
#+BEGIN_SRC neut
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
#+END_SRC
We would like to use the variable =str= linearly. To this end, we can request =string.print= to include the argument =str= in its return value. So, the type of =string.print= shouldn't be something like =string -> top= - where the =top= is the unit type - but should be =string -> string * top=, where the =A * B= means the product type of =A= and =B=. More specifically, the implementation of =string.print= should be something like (in pseudo-code):
#+BEGIN_SRC haskell
string.print :: string -> string * top
string.print str = do
  {print the string `str`}
  return (str, unit)
#+END_SRC
With that definition of =string.print=, we can use the variable =str= linearly (again, in pseudo-code):
#+BEGIN_SRC haskell
let str1 = "a";
let (str2, _) := string.print str1;
let (str3, _) := string.print str2;
let (str4, _) := string.print str3;
unit
#+END_SRC
Note that the variables =str1=, =str2=, and =str3= are used exactly once, and =str4= for the 0 time. Therefore, the copying operation doesn't occur in the code above. Also, since the =str4= is defined but not used, the =str4= is discarded immediately after its definition.

Now we have seen that those redundant copying/discarding operations can be avoided by writing the code in the manner above. There still remains a problem: code cluttering. It would be much nicer to have more sophisticated notation of that code pattern. Towards that end, firstly note that we can use the same name for the variables =str1=, =str2=, =str3=, and =str4= thanks to variable shadowing:
#+BEGIN_SRC haskell
let str = "a";
let (str, _) := string.print str;
let (str, _) := string.print str;
let (str, _) := string.print str;
unit
#+END_SRC
Now, we just have to introduce a notation that translates:
#+BEGIN_SRC haskell
let foo := string.print &str;
#+END_SRC
into:
#+BEGIN_SRC haskell
let (str, foo) := string.print str;
#+END_SRC

With this notation, our running example is rewritten as follows:
#+BEGIN_SRC haskell
let str = "a";
let _ := string.print &str;
let _ := string.print &str;
let _ := string.print &str;
unit
#+END_SRC

And this is the notation that is implemented in neut. Indeed, the following is a valid code of neut:
#+BEGIN_SRC neut
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print &str))
  (let _ (string.print &str))
  (let _ (string.print &str))
  top.unit) ; ~> top.unit
#+END_SRC
Or,
#+BEGIN_SRC neut
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print &str))
  (let _ (string.print &str))
  (string.print str)) ; ~> (unit, "a")
#+END_SRC
This notation is "borrowing" in neut. Note that borrowing in neut is nothing but a syntactic translation. Borrowing has nothing to do with, for example, the type system, or the operational semantics, of neut. Indeed, this syntactic translation is processed at the stage of parsing in the compiler.

Let's see how the resulting LLVM IR changes. Is it faster now? We can compile the code above by running =neut build --no-alloc-cancellation --emit llvm filename.neut=. The output is schematically as follows:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ; <memory allocation for the string>
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ; <write the string into stdout for the three times>
  ; <memory deallocation for the string>
  ; <return 0>
}
#+END_SRC
Again, the non-schematic output can be found in the [[#llvm-ir-for-the-second-example][appendix]]. The output in this time is actually short enough to include it here (36 lines including comments), though I chose not to. The point here is that the string "a" is reused without copying, as expected.

The resulting assembly code, which can be obtained by =--emit asm=, is reasonably small too (works on macOS; when you compile the same code on Linux, the =write= operations are lowered into the corresponding syscalls):
#+BEGIN_SRC asm
	.section	__TEXT,__text,regular,pure_instructions
	.macosx_version_min 12, 15
	.globl	_main                   ## -- Begin function main
	.p2align	4, 0x90
_main:                                  ## @main
	.cfi_startproc
## %bb.0:
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset %rbx, -15
	movl	$1, %edi                 # 1-byte memory allocation (you can ignore the lines above this line)
	callq	_malloc
	movq	%rax, %rbx
	movb	$97, (%rax)              # write 'a' (= 97) to the allocated memory
	movl	$1, %edi                 # set the arguments for `_write`
	movl	$1, %edx
	movq	%rax, %rsi
	callq	_write                   # ... and call `_write` (i.e. print 'a')
	movl	$1, %edi                 # (repeat)
	movl	$1, %edx
	movq	%rbx, %rsi
	callq	_write
	movl	$1, %edi                 # (repeat)
	movl	$1, %edx
	movq	%rbx, %rsi
	callq	_write
	movq	%rbx, %rdi               # free the allocated memory
	callq	_free
	xorl	%eax, %eax
	popq	%rbx
	retq
	.cfi_endproc
                                        ## -- End function
.subsections_via_symbols
#+END_SRC
In short: the resulting code is faster in that it is free from the redundant copying operations we saw in the first example.

This is how neut controls resources efficiently, without modifying the type system of the source language.

** Manual Optimization via Noetic Computation (New in 0.2.0.0)
Still, this is not enough. Suppose we have a term of type =list a=, and are trying to calculate its length. The naive implementation would be something like this:
#+begin_src neut
; length : (a : tau, xs : list a) -> i64
(define length ((a tau) (xs (list a)))
  (case xs
    ((nil)
      0)
    ((cons y ys)
      (add-i64 1 (length a ys)))))

(define some-function ()
  (with identity.bind
    (let xs (list.new i64 1 2 3))  ; xs : list i64 := [1, 2, 3]
    (let len (length i64 xs))
    (if (< len 3)
      (foo xs)
      (bar xs)))))
#+end_src
The code above calculates the desired result. However, we can see that the function =some-function= uses =xs= in non-linear manner. This means that the =xs= is cloned just to calculate its length. This behavior is far from satisfactory. On the other hand, if we rewrite =length= so that it also returns the original list (to use the optimization that we have just seen), then we need to write something like this:
#+begin_src neut
; length : (a : tau, xs : list a) -> (list a) * i64
(define length ((a tau) (xs (list a)))
  (case xs
    ((nil)
      (tuple (nil i64) 0))
    ((cons y ys)
      (let (tuple tmp-list ys-length) (length a ys))
      (tuple (cons i64 y tmp-list) (add-i64 1 ys-length)))))
#+end_src
In this implementation, the original list =xs= is totally destructed and reconstructed using =nil= and =cons= from the ground up. Again, this is not a satisfactory behavior.

neut's solution to this problem is two-fold:

1. create an "unconsumable" version of =xs : list a= and use it to avoid redundant copy
2. find a pattern that allows us to use the unconsumable version of =xs= safely, and turn it into a syntax

Let me explain the former part. Let's call the "unconsumable" version of =xs= a "noema" of =xs=. The noema of =xs= - which is of type =noema (list a)= - is defined as follows.

- The memory representation of the value of a noema is the same as that of =xs=.
- The noema is copied/discarded exactly the same way as an integer.

For example, consider the following code:
#+begin_src text
let xs : list i64 := [1, 2, 3] in
let a := f xs in
let b := g xs in
top.unit
#+end_src
Since the =xs= is used twice, the code above is compiled into something like this:
#+begin_src text
let xs : list i64 := [1, 2, 3] in
let xs-copy := copy-as (list i64) xs in
let a := f xs-copy in
let b := g xs in
top.unit
#+end_src

On the other hand, consider the following code (ignore the initialization part):
#+begin_src text
let xs : noema (list i64) := (INITIALIZATION_OF_NOEMA) in
let a := f xs in
let b := g xs in
top.unit
#+end_src
The code above is compiled into something like this:
#+begin_src text
let xs : noema (list i64) := (INITIALIZATION_OF_NOEMA) in
let xs-copy := copy-as i64 xs in
let a := f xs-copy in
let b := g xs in
top.unit
#+end_src
which is equivalent to:
#+begin_src text
let xs : noema (list i64) := (INITIALIZATION_OF_NOEMA) in
let xs-copy := xs in
let a := f xs-copy in
let b := g xs in
top.unit
#+end_src

Note that we can easily break the resource management system of neut if we can use this noema without any restrictions. For example, consider the following code:
#+begin_src text
let xs : noema (list i64) := (INITIALIZATION_OF_NOEMA) in
top.unit
#+end_src
Since the =xs= is discarded not as a list but as an integer, the pseudo-code above does not free the list that is bound to =xs=. In other words, the code above causes a memory leak. This kind of unsafe behavior will be dealed with in the latter part of this section; Here, let us firstly see how this noema can be utilized for optimization.

We need a way to use a noema. =case-noetic= is what we will use for this purpose. =case-noetic= is basically the read-only version of the the pattern matching operator =case=, and thus their uses are more or less the same:
#+begin_src text
let xs : list i64 := [1, 2, 3] in
case xs of
  nil ->
    true
  cons y ys ->
    false

let xs : noema (list i64) := (INITIALIZATION) in
case-noetic xs of
  nil ->
    true
  cons y ys ->
    false
#+end_src

The differences between =case= and =case-noetic= are the following three.

The first one: =case= is used for a term of an ordinary data-type (=list i64=), whereas =case-noetic= is used for a term of a noetic data-type (=noema (list i64)=).

The second one: =case= consumes the matched value (=xs=), whereas =case-noetic= does not; =case-noetic= just reads the value. More specifically, a term of type =list i64= is represented as a tuple something like this: =(TYPE_OF_INTERNAL_DATA, INTERNAL_DATA, CONSTRUCTOR_LABEL)=. =case= extracts the elements from this tuple, deallocates the tuple, and then continues computation using the obtained values (e.g. select correct branch according to =CONSTRUCTOR_LABEL=). =case-noetic= also extracts elements from this tuple, but does not deallocate the tuple. In this sense, =case-noetic= does not consume the matched value.

The third one: in =case-noetic=, the types of the newly-bounded variables in the patterns are wrapped with =noema (...)=. For example, if we use =case-noetic= for a term of type =noema (list i64)=, then the =y= and =ys= in =cons y ys= will be of type =noema i64= and =noema (list i64)=, respectively. This is required to prevent an internal piece of a noema from being deallocated; If we were to set the type of =ys= as =list i64=, the code below will deallocate the =ys=:
#+begin_src text
let xs : noema (list i64) := (INITIALIZATION) in
case-noetic xs of
  nil ->
    true
  cons y ys ->
    false
#+end_src
since =ys= is not used. By wrapping this =ys= with =noema (...)=, we can ensure that a noema is always unconsumable and read-only.

If we have such =case-noetic=, then we can write more efficient =length= basically as follows:
#+begin_src text
-- length-internal : (tau, noema (list a)) -> i64
define length-internal (a : tau) (xs : noema (list a)) :=
  case-noetic xs of
    nil ->
      0
    cons y ys ->
      length-internal a ys

-- length : (tau, list a) -> (list a) * i64
define length (a : tau) (xs (list a)) :=
  let xs-noema := CREATE_NOEMA &xs in
  let len := length-internal a xs-noema in
  (xs, len)
#+end_src
We now need to find a way to create and use noemata safely.

Let us move on to the latter part. To achive safety, we will employ the idea of ST monad here.

We firstly declare an opaque type =subject=, and add a tag of type =subject= to a =noema=. In other words, for a term =s : subject=, we redefine =noema a= into =noema s a=. We also define a =subject=-tagged identity monad, and name it a =noesis=; A =noesis s a= is the same as =identity a= except for the additional argument =s=.

We also define a term =noesis.run : Π (a : tau). (Π (s : subject). noesis s a) -> a=. This is defined as follows:
#+begin_src text
noesis.run a f =
  let dummy-subject : subject                = cast i64 subject 0 in
  let answer        : noesis dummy-subject a = f dummy-subject in
  cast (noesis dummy-subject a) a answer
#+end_src
That is, =noesis.run= executes given =f= by supplying it a dummy argument. This =noesis.run= is something that can be compared to =runST= in ST monad.

Using these new words, we define a syntax =with-subject s (x) computation= as follows:
#+begin_src text
  with-subject s (x) computation
~>
  noesis.run * $ \(s : subject) -> do
    let x = cast a (noema s a) x
    ans <- computation
    return (cast (noema s a) a x, ans)
#+end_src
That is, what =with-subject s (x) computation= does is:
- cast the =x= into a noema, using the same name, shadowing the original =x : a=
- do the computation under the condition =s : subject, x : noema s a=
- return the result of the computation, pairing it with the original =x : a=, which can be obtained by casting =x : noema s a=.

Using this =with-subject=, the noetic =length= can be fully implemented as follows:
#+begin_src text
define length-internal (s : subject) (a : tau) (xs : noema s (list a)) :=
  case-noetic xs of
    nil ->
      0
    cons y ys ->
      length-internal s a ys

-- length : (a : tau, _ : list a) -> (list a) * i64
define length (a : tau) (xs (list a)) :=
  with-subject s (xs)
    ((noesis.return s) i64 (length-internal s a xs))
#+end_src
where the =noesis.return= is the =subject=-tagged version of the return operation of the identity monad.

We can use noemata safely as long as we use it via =with-subject=. Here I used the word "safely" to mean that we can see the following two properties:

(1) The content of every noema will be deallocated later. In other words, no memory leak is possible. This can be ensured since the content is returned as a part of the return value of =with-subject=.

(2) If we can use a noetic variable, then the corresponding resource is always available. In other words, no use-after-free is caused by using a noetic variable. This can be seen by the following reasoning. Firstly, if a use of a noema causes a use-after-free, then the corresponding resource must be deallocated before the use of the noema. Since a use of a noema does not deallocate its content (remember that noetic variable is read-only), if a use of a noema causes a use-after-free, then the original, non-noetic variable must be used to deallocate the resource, before the use of the noema. Since the non-noetic variable is shadowed inside =with-subject=, such situation can only be happen outside the =with-subject=. That is, such situation can only be realized by returning a noema as a result of =with-subject=. However, this cannot happen by the very nature of =noesis.run=. Remember the type of =noesis.run=. That is, =Π (a : tau). (Π (s : subject). noesis s a) -> a=. For this =noesis.run= to return a =noema=, the =a= in the type of =noesis.run= must be something like =noema s b=. Thus, the following type must be well-formed: =(Π (s : subject). noesis s (noema s b)) -> noema s b=. However, this type has an unbounded variable =s=. Therefore, =with-subject= cannot return a =noema=. That's why no use-after-free is possible.

This concludes the latter part. By the way, if you want to use the content of a noema, you can copy the content of the noema according to its type. This is what =noema.incarnate= does. This function can be used to, for example, compute the sum of a list:

#+begin_src text
-- noema.incarnate : (s : subject, a : tau, x : noema s a) -> (noema s a) * a

-- sum-internal : (s : subject, xs : noema s (list i64)) -> i64
define sum-internal (s : subject) (xs : noema s (list i64)) :=
  case-noetic xs of
    nil ->
      0
    cons y ys ->
      let value = noema.incarnate s i64 &y
      value + sum-internal s a ys

-- sum : (_ : list i64) -> (list i64) * i64
define sum (xs (list i64)) :=
  with-subject s (xs)
    ((noesis.return s) i64 (sum-internal s a xs))
#+end_src

To sum up, we can avoid copying operations by combining the resource management system of neut and the idea of ST monad.

Firstly, let us add the following constants to the language:
#+begin_src text
subject    : tau
noesis     : Π (s : subject, a : tau). tau
noema      : Π (s : subject, a : tau). tau
noema.new  : Π (s : subject, a : tau, value : a). noesis s (a * (noema s a))
noesis.run : Π (a : tau). (Π (s : subject). noesis s a). a
#+end_src
A =subject= is just a tag that is used by =noesis=. =noesis= is the identity monad with additional tag =s : subject=. =noema= is the "unconsumable" version of the original value, which can only be constructed within a noesis monad. =noema.new= is the only way to create a =noema=. =noesis.run= executes the =noesis= monad by applying fake value of type =subject= (like running IO monad).

(If you are familiar with Haskell, you can think of =noesis= as the ST monad, =noema= as the =STRef=, =noema.new= as =newSTRef=, and =noesis.run= as =runST=)

Let me explain the "unconsumable" part. The code below is non-noetic one:
#+begin_src text
let xs : list a := (some-initialization) in
let a := f xs in
let b := g xs in
(...)
#+end_src
In the code, =xs= is used twice, and thus it is copied. Let's compare the code above to the code below:
#+begin_src text
let xs' : noema s (list a) := (some-initialization) in
let a := f xs' in
let b := g xs' in
(...)
#+end_src
In this time, the =xs'= is not copied despite the fact that it is used twice. A noema is not copied, nor discarded; It is used as if it were an integer. More specifically, =noema s a= is compiled into the following exponentializer:
#+begin_src text
noema s a ~>
  λ (i, e).
    if i == 0
    then ()
    else (e, e)  # note that `a` is not used in the exponentializer
#+end_src
By the way, the internal memory representation of =xs= and =xs'= is exactly the same. That is, =xs'= is not a reference to =xs=, but is =xs= itself.

Of cousre, we need a way to use noema. This is =case-noetic=.

#+begin_src neut
(define length-internal
  ((s subject)
   (a tau)
   (xs (noema s (list a)))
   (acc i64))
  (witness i64
    (case-noetic xs
      ((list.nil)
        acc)
      ((list.cons _ ys)
        (length-internal s a ys (add-i64 acc 1))))))

(define length
  ((a tau)
   (xs (list a)))
  (with-region s
    (let xs-noema (noema.new s (list a) &xs))
    ((noesis.return s) (product (list a) i64) (tuple xs (length-internal s a xs-noema 0)))))
#+end_src


TBD (write about the efficient implementation of =list.length= via case-noetic)

#+begin_quote
The tree simpliciter can burn up, be resolved into its chemical elements, etc. But the sense — the sense of this perception, something belonging necessarily to its essence — cannot burn up; it has no chemical elements, no forces, no real properties. —— Edmund Husserl
#+end_quote


As you may have already noticed, this is an approach that uses ST monad to realize named scope.

The =xs= can be deallocated (burn up). But the noema of =xs= can't be deallocated.

** Automatic Optimization via malloc/free Cancellation
neut's static memory management enables not only the "manual" optimization we have just seen, but also another "automatic" optimization. Remember the first example:
#+BEGIN_SRC neut
(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (let _ (string.print str))
  (i64 0))
#+END_SRC
and the output IR of this example code:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ; Repeat the following for the 3 times:
  ;   <memory allocation for the string>
  ;   <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;   <write the string into stdout>
  ;   <memory deallocation for the string>
}
#+END_SRC
The code is already judged to be inefficient in that it allocates/deallocates memory unnecessarily. More specifically, it is inefficient in that it deallocates the memory that can actually be reused.

Now you might think: If the sizes of allocations/deallocations are known at compile-time, isn't it possible to compare the sizes of them at compile-time and emit a code that reuses the allocated memory?

It is indeed possible. When the option =--no-alloc-cancellation= is not passed, the compiler translates code pieces something like this:
#+BEGIN_SRC llvm
define TYPE @FUNCTION_NAME(...) {
  (...)
  ; <memory allocation for the string>
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ; <write the string into stdout>
  ; <memory deallocation for the string>    -- (*1)
  ; <memory allocation for the string>      -- (*2)
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ; <write the string into stdout>
  ; <memory deallocation for the string>
  (...)
}
#+END_SRC
into something like this:
#+BEGIN_SRC llvm
define TYPE @FUNCTION_NAME(...) {
  (...)
  ; <memory allocation for the string>
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ; <write the string into stdout>
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ; <write the string into stdout>
  ; <memory deallocation for the string>
  (...)
}
#+END_SRC
In other words, the compiler can cancel the memory deallocation at =(*1)= and the allocation at =(*2)=, reusing the allocated memory in its continuation. This is automatic malloc/free cancellation. By this fallback optimization, the compiler can emit somewhat more performant code even if a user wrote code in an inefficient way.

Note that the "create the string" parts are not optimized away from the resulting LLVM IR, in contrast to the one of borrowing:
#+BEGIN_SRC llvm
define i64 @main() {
  ; <memory allocation for the string>
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ; <write the string into stdout>
  ; <write the string into stdout>
  ; <write the string into stdout>
  ; <memory deallocation for the string>
  ; <return 0>
}
#+END_SRC
Although the compiler can cancel memory allocations/deallocations, it cannot cancel their accompanying initialization processes (at least for now). If you do need performance, you need to write code in the linear/borrowing style.

** Summary
- neut statically determines malloc/free at compile-time via type information
- The content of a variable is
  - discarded if and only if the variable isn't used at all
  - untouched if and only if the variable is used exactly once (i.e. used linearly)
  - copied if and only if the variable is used more than once
- Linearity tends to result in an efficient code
- Non-linearity tends to result in an inefficient code
- Borrowing can be used as a convenient syntactic tool when accomplishing linearity
- Redundant malloc/free can be reduced by automatic malloc/free cancellation
- Borrowing-based, or "manually" optimized code is faster than cancellation-based, or "automatically" optimized code

* Installation
The currently supported platforms are: Linux (x64), macOS (x64).

Make sure that you have already installed [[https://zlib.net/][zlib]] (>= 1.2.11), [[https://wiki.openssl.org/index.php/Libssl_API][libssl]] (>= 1.1.1), [[https://docs.haskellstack.org/en/stable/README/][stack]] (>= 2.3.0) and [[https://clang.llvm.org/][clang]] (>= 10.0.0). On Debian, for example, the first three can be installed as follows:
#+BEGIN_SRC shell
sudo apt install zlib1g-dev libssl-dev haskell-stack
stack upgrade --binary-only # not required if your stack is already up-to-date
#+END_SRC
=clang= can be installed in the way described [[https://apt.llvm.org/][here]].

Also make sure that you have =~/.local/bin= in your =$PATH=.

Then, clone the repository and build it:
#+BEGIN_SRC shell
git clone https://github.com/u2zv1wx/neut
cd neut
git checkout 0.1.0.0
# the following builds the project and tests its behavior
# it also checks memory sanity via the clang option "-fsanitize=memory"
stack test --test-arguments test/data --test-arguments test/compiler
# this installs the executable `neut` into `~/.local/bin`
stack install
#+END_SRC
To uninstall, you just have to remove the binary =~/.local/bin/neut= and the directory =~/.local/share/neut=.

As for editor support, you can currently try [[https://github.com/u2zv1wx/neut-mode][neut-mode]] and [[https://github.com/u2zv1wx/flycheck-neut][flycheck-neut]] if you're using Emacs. The former package is for syntax highlighting, and the latter one for linting.

* Language Overview

** Basic Structure
You can find a detailed description of the syntax, the logic, and the semantics of neut in the succeeding sections. Those should suffice to read/write a program of neut. Having said that though, some might prefer learning from actual source code after taking a brief look at this and that basic stuff. So here I introduce you some necessities that would be required to understand - or guess the meaning of - a program of neut.

Let's start. Notes on programs. (0) A program of neut is a list of statements, processed one by one. (1) [[#ensure][ensure]] and [[#include][include]] are the ones that use codes written in other files. I recommend you to read the linked notes; both of them are not so long. (2) [[#useunuse][use/unuse]] and [[#sectionend][section/end]] are the ones that handle namespace. Again I recommend you to read them.

Next. Notes on terms. (0) Note that what follows presupposes the =notation.neut= in [[https://github.com/u2zv1wx/neut-core][the core library]]; Some of these won't work without including the file. (1) =tau= is the type of types. (2) =Π= is the universal quantification. Note that =Π (x : A). B= is the same as the arrow type =A -> B= if =x ∉ freevar(B)=. Also note that a lambda-abstraction in neut is n-ary; =(λ ((x A) (y B)) e)= is not the same as =(λ ((x A)) (λ ((y B)) e))=. (3) If you want to create a tuple, you can use =(sigma-introduction e1 ... en)= or =(tuple e1 ... en)=. You can destruct a tuple by =(sigma-elimination (x1 ... xn) e cont)=. (4) You can write =(question e)= or =?x= when you want the compiler to show the type of =e= or =x=. (5) You can write =*= to have the compiler infer the specified part. For example, assuming =(define id ((a tau) (x a)) x)=, you can write =(id * bool.true)= instead of =(id bool bool.true)=. (6) You will notice that =(witness t e)= is used here and there. This is a notation defined by =(notation (witness t e) ((λ ((x t)) x) e))=; A notation that tells the compiler that the term of =e= is =t=.

Next. Notes on primitives: (0) The following primitive types are available: =i1=, =i2=, =i3=, ..., =i64=. These are the same as the corresponding integer types in LLVM. (1) You can also use =f16=, =f32=, and =f64=. These are LLVM's =half=, =float=, and =double=, respectively. (2) You will soon come to want primitive instructions - like =add=, =mul=, or =xor= - that can operate on terms of these types. You can find information on them [[#primitives][in this section]]. (3) In the section you can also find notes on unsafe casting, array accessing, and syscall. I think these should also count as necessities. (4) When you use an effectful primitive like =os.write= in a type, the behavior of the resulting executable is undefined.

Next. Notes on the compiler subcommands. (0) You can build a program with =neut build path/to/file.neut=. (1) You can create an =tar.gz= archive of a project via =neut archive path/to/dir=. Then you can upload the archive to somewhere, allowing others to =ensure= and =include= it.

Now I think you are basically ready to, for example, start reading [[https://github.com/u2zv1wx/neut/tree/master/test/data][the files in the test directory]], or [[https://github.com/u2zv1wx/neut-core][the files in the core library]], referring the sections below as necessary. After that you should know how to write lambdas, recursive functions, inductive types, tuples. You need a state? You can use the state monad. Multiple effects? The free monad. You have the full power of lambda calculus.

That pretty much should do it. I hope you enjoy this language.

** Example Code

* Syntax and Semantics of the Meta Language
** Statements

*** define-macro, define-macro-variadic
TBD

*** define-prefix, remove-prefix
TBD

*** dry-expand
TBD

*** ensure
=ensure= fetches the content of the specified URL for later use.

**** Example
#+BEGIN_SRC neut
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(ensure LEAF STRING)
#+END_SRC
**** Semantics
=(ensure path URL)= fetches the content of the specified URL, extracts the content into =~/.local/share/neut/NEUT_VERSION/path=, assuming that the format of the archive is =tar.gz=. The =path= must be a valid path string. Every path separator in =path= is treated "literally". For example, if the =path= is =some-library/0.2.0.0=, the content of the archive is extracted into =~/.local/share/neut/NEUT_VERSION/some-library/0.2.0.0=.

If the target directory of archive extraction already exists, =ensure= does nothing.

This statement is intended to be used in harmony with [[#include][include]].

Archives specified in =ensure= is expected to be the ones created via [[#archive][archive]].


*** include
=include= "pastes" the content of the specified file.
# temporary transfers the parsing process to the file specified by given path, if necessary.
**** Example
#+BEGIN_SRC neut
(include "core/0.1.0.0/free.neut")

(include "./relative/path/from/the/dir/path/of/this/file.neut")
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(include STRING)
#+END_SRC
**** Semantics
#+BEGIN_SRC neut
{CODE_1}

(include STRING)

{CODE_2}

~>

{CODE_1}

{THE_CONTENT_OF_THE_FILE_SPECIFIED_BY_THE_STRING}

{CODE_2}
#+END_SRC
With the following notes:

(1) If the first character of the path is dot ("."), the path is interpreted as a relative one. That is, the path is calculated using the current file's directory as the base path. Otherwise, the base path is set to be the library path (i.e. =~/.local/share/neut/NEUT_VERSION/library=).

(2) If the file is already included, =include= does nothing.

(3) When including a file, [[#useunuse][the prefix environment]] must be empty.

(4) Cyclic inclusion is invalid.




*** introspect
=introspect= introspects the state of the compiler and selects statements by those information.
**** Example
#+BEGIN_SRC neut
(introspect OS
  (linux
    (include library "constant/linux.neut"))
  (darwin
    (include library "constant/darwin.neut")))
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(introspect LEAF (LEAF TREE ... TREE) ... (LEAF TREE ... TREE))
#+END_SRC
**** Semantics
#+BEGIN_SRC text
(introspect VAR
  (VAR-1 stmt-1-1 ... stmt-1-n{1})
  ...
  (VAR-m stmt-m-1 ... stmt-m-n{m}))

~>

(stmt-i-1)
...
(stmt-i-n)

[where VAR == VAR-i]
#+END_SRC
If the corresponding value is not found in the clause list, this statement does nothing.

The =var= in =(introspect var (...))= must be a valid compile-time variable. The valid compile-time variables and its possible values are currently as in the table below:

| compile-time variable | possible values         |
|-----------------------+-------------------------|
| OS                    | linux, darwin           |
| architecture          | x86_64, aarch64, (etc.) |

*** section/end
TBD

*** statement
TBD

*** use/unuse
TBD


** Terms
*** variable

*** implication

*** if

*** constant

*** integer

*** leaf/node

** Notes on Quote, Unquote and Splice

* Syntax and Semantics of the Object Language

** Statements
(fixme: the content below is out-of-date)

A program of neut is a list of statements. Each statement is one of the following statements described in this section.

Please note that the descriptions in the followings are not that formal yet.

In the following, I use the symbols =LEAF= and =TREE= defined as follows:
#+BEGIN_SRC text
LEAF ::= {a sequence of character that doesn't contain '(', ')', ' ', '\n', or '"'}
TREE ::= LEAF | (TREE ... TREE)
#+END_SRC
I also define the symbol =STRING= to be a double-quoted string.

Note that the examples codes below usually assumes that the core library is already included.


*** enum
=enum= declares a new enum-type and its values.
**** Example
#+BEGIN_SRC neut
(enum choice left right) ; defines choice : tau, choice.left : choice, and choice.right : choice

(let x choice.left)

(i64.print
  (enum-elimination x
    (choice.left
      (i64 1))
     choice.right
      (i64 2))) ; ~> 1

(i64.print (unsafe.cast choice i64 choice.left)) ; ~> 0

(i64.print (unsafe.cast choice i64 choice.right)) ; ~> 1

(enum foo
  (a 100)
  b
  (c 20)
  d
  e
  (f 103))

(i64.print (unsafe.cast foo i64 foo.a)) ; ~> 100
(i64.print (unsafe.cast foo i64 foo.b)) ; ~> 101
(i64.print (unsafe.cast foo i64 foo.c)) ; ~> 20
(i64.print (unsafe.cast foo i64 foo.d)) ; ~> 21
(i64.print (unsafe.cast foo i64 foo.e)) ; ~> 22
(i64.print (unsafe.cast foo i64 foo.f)) ; ~> 103
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(enum LEAF LEAF_INT ... LEAF_INT)

LEAF_INT := LEAF | (LEAF INT)
#+END_SRC
**** Semantics
=(enum x a1 ... an)= updates the state of the compiler so that the specified enum-type =x : tau= and the enum-values =x.a1, ..., x.an : x= can be used in its continuation.

Every enum-value has its internal i64 value (discriminant). Those discriminant values can be extracted by using the constant =unsafe.cast=, though usually not recommended.

Discriminant value starts from =0= by default, and increments one by one. The "current" value of this process can be modified by writing, e.g. =(enum foo a (b 100) c d)=. In this example, the discriminant value of =c= is set to be =101=.

All the discriminant values of an enum-type must be distinct.


*** define
# =define= evaluates given term and binds the result to the specified variable.
TBD

# *** Example
# #+BEGIN_SRC neut
# (let foo (i64 10)) ; define a variable `foo` to be `10`

# (i64.print foo) ; ~> 10 (this is equivalent to `(let _ (i64.print foo))`)

# (let (bar i64) 20) ; `let` with type annotation

# (i64.print bar) ; ~> 20

# ; `define` is defined in `core/<VERSION>/notation.neut` as follows:
# ; (notation (define f xts e)
# ;   (let f (fix f xts e)))
# ;
# ; (notation (define f e)
# ;   (let f e))
# ;

# ; ordinary definition (i.e. 1-mutual definition)
# (define fact ((x i64))
#   (if (icmp-sle-i64 x 0) ; compare (by less-than-or-equal) two `i64`s as signed integers
#     1
#     (mul-i64 x (fact (sub-i64 x 1)))))

# (i64.print (fact foo)) ; ~> 3628800 (= 10!)

# ; mutual recursion can be realized as in the ordinary way:
# (define even-f ((f (hom i64 bool)) (n i64))
#   (if (icmp-eq-i64 n 0)
#     true
#     (f (sub-i64 n 1))))

# (define odd ((n i64))
#   (if (icmp-eq-i64 n 0)
#     false
#     (even-f odd (sub-i64 n 1))))

# (define even ((n i64))
#   (even-f odd n))

# (i64.print
#   (if (even 10)
#     100
#     1000)) ; ~> 100
# #+END_SRC
# *** Syntax
# #+BEGIN_SRC neut
# (let LEAF_PLUS TREE)

# LEAF_PLUS ::= LEAF | (LEAF TREE)
# #+END_SRC
# *** Semantics
# =(let x e)= checks the type of the term =e=, evaluates the term =e=, then defines a variable =x= with =e= as its content. =x= is available in the continuation. The type of =x= can be annotated to be =t= by writing =(let (x t) e)=.

# If a user input =e= is not parsed as a statement when it is supposed to be, the compiler interprets it as =(let _ e)=.

*** define-prefix, remove-prefix
TBD

*** reduce
TBD

*** use/unuse
=use= inserts a prefix to the prefix environment. =unuse= removes a prefix from the prefix environment.
**** Example
#+BEGIN_SRC neut
(let foo.bar.buz (i64 10))

(i64.print buz)         ; ~> undefined variable: `buz`
(i64.print bar.buz)     ; ~> undefined variable: `bar.buz`
(i64.print foo.bar.buz) ; ~> 10

(use foo)

(i64.print buz)         ; ~> undefined variable: `buz`
(i64.print bar.buz)     ; ~> 10
(i64.print foo.bar.buz) ; ~> 10

(use foo.bar)

(i64.print buz)         ; ~> 10
(i64.print bar.buz)     ; ~> 10
(i64.print foo.bar.buz) ; ~> 10

(unuse foo)

(i64.print buz)         ; ~> 10
(i64.print bar.buz)     ; ~> undefined variable: `bar.buz`
(i64.print foo.bar.buz) ; ~> 10
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(use LEAF)

(unuse LEAF)
#+END_SRC
**** Semantics
When parsed, the statement =(use PREFIX)= inserts =PREFIX= at the head of the prefix environment, which is a list of prefixes.

When parsed, the statement =(unuse PREFIX)= removes =PREFIX= from the prefix environment. If the =PREFIX= is not contained in the environment, the =unuse= statement does nothing.

The prefix environment modifies [[#upsilon][how the compiler interprets a variable]].

*** section/end
=section= - =end= automatically adds the specified prefix to the variables defined by =let=.

**** Example
#+BEGIN_SRC neut
(section pohe)

(let foo (i64 10))

(section qux)

(let bar (i64 20))

(i64.print foo)          ; ~> 10
(i64.print pohe.foo)     ; ~> 10

(i64.print bar)          ; ~> 20
(i64.print qux.bar)      ; ~> 20
(i64.print pohe.qux.bar) ; ~> 20

(end qux)

(i64.print foo)          ; ~> 10
(i64.print pohe.foo)     ; ~> 10

(i64.print bar)          ; ~> undefined variable
(i64.print qux.bar)      ; ~> 20
(i64.print pohe.qux.bar) ; ~> 20

(end pohe)

(i64.print foo)          ; ~> undefined variable
(i64.print pohe.foo)     ; ~> 10

(i64.print bar)          ; ~> undefined variable
(i64.print qux.bar)      ; ~> undefined variable
(i64.print pohe.qux.bar) ; ~> 20
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(section LEAF)

(end LEAF)
#+END_SRC
**** Semantics
The list of statement
#+BEGIN_SRC neut
(section FOO)
(let x1 e1)
...
(let xn en)
(end FOO)
#+END_SRC
is equivalent to:
#+BEGIN_SRC neut
(use FOO)
(let FOO.x1 e1)
...
(let FOO.xn en)
(unuse FOO)
#+END_SRC
In other words, the =section= - =end= statement
- inserts [[#useunuse][use / unuse]] at the beginning and the end of the section
- adds the name of the section as a prefix of the variables defined by =let=
- keeps all the other statements in the section intact

Each =section= must be paired with an =end= with the corresponding name.

** Terms
*** tau
=tau= is the type of types.
**** Example
#+BEGIN_SRC neut
(define id ((a tau) (x a)) x)

(id i64 10)
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
tau
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text

-------------------(empty)
well-formed(EMPTY)


well-formed(Γ)
--------------- (tau)
Γ |- tau : tau
#+END_SRC
**** Semantics
=tau= doesn't have any operational semantics.

*** variable
**** Example
#+BEGIN_SRC neut
(let x (i64 10))

(i64.print x) ; ~> 10

(let _ (i64 20)) ; anonymous variable
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
LEAF
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
    Γ |- A : tau
------------------------- (ext)
well-formed(Γ, x : A)


well-formed(Γ)  (x : A) ∈ Γ
---------------------------- (var)
       Γ |- x : A
#+END_SRC
**** Semantics
A variable doesn't have any operational semantics by itself.

**** Notes
If a leaf is not parsed into any other syntactic construct, the leaf =x= is regarded as a variable.

The name of a variable is interpreted in relation with the keyword environment. For example, if the keyword environment is =["foo", "bar", "buz"]=, the name =qux= is interpreted in the following way:
1. Look up a bound variable named =qux= in current scope.
2. If not found, look up a bound variable named =foo.qux= in current scope.
3. If not found, look up a bound variable named =bar.qux= in current scope.
4. If not found, look up a bound variable named =buz.qux= in current scope.
5. If not found, report the error: "undefined variable".

*** Π
=Π= is the universal quantification.
**** Example
#+BEGIN_SRC neut
; unary Π-introduction
(let f2
  (Π-introduction ((x i64)) x))

; Π-elimination
(Π-elimination i64.print (Π-elimination f2 2))

; Π-elimination with the familar (or, implicit) syntax
(i64.print (f2 2))

; nullary Π-introduction
(let f1
  (lambda () (i64 1))) ; 'lambda' can be used instead of 'Π-introduction'

; binary Π-introduction
(let f3
  (λ ((x i64)   ; an argument with type annotation
      y)        ; an argument without type annotation
    (i64.add x y)))

(i64.print (f3 1 2))
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(Π (LEAF_PLUS*) B)
(Π-introduction (LEAF_PLUS*) e)
(Π-elimination TREE+)
(TREE+)

LEAF_PLUS ::= LEAF | (LEAF TREE)
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
Γ |- A1 : tau    Γ, x1 : A1 |- A2 : tau    (...)    Γ, x1 : A1, ..., xn : An |- B : tau
---------------------------------------------------------------------------------------- (Π)
                    Γ |- (Π ((x1 A1) ... (xn An)) B) : tau


             Γ, x1 : A1, ..., xn : An |- e : B
------------------------------------------------------------------------------- (Π-introduction)
 Γ |- (Π-introduction ((x1 A1) ... (xn An)) e) : (Π ((x1 A1) ... (xn An)) B)


Γ |- e : (Π ((x1 A1) ... (xn An)) B)   Γ |- e1 : A1   (...)   Γ |- en : An {xi := ei}
-------------------------------------------------------------------------------------- (Π-elimination)
              Γ |- (Π-elimination e e1 ... en) : B {xi := ei}
#+END_SRC
**** Semantics
#+BEGIN_SRC neut
(Π-elimination e e1 ... en)
~> (Π-elimination v v1 ... vn)  [i.e. reduce e and ei into the values v and vi, from left to right]

(Π-elimination (Π-introduction ((x1 A1) ... (xn An)) e) v1 ... vn)
~> e {x1 := v1, ..., xn := vn}
#+END_SRC
**** Notes
If a tree =(e e1 ... en)= is not parsed into any other terms, the tree is regarded as =(Π-elimination e e1 ... en)=.

If the name of an argument of a Π-introduction is "_", the compiler automatically generates a fresh name so that the variable cannot be used in its scope.

Note that the arguments of a lambda-abstraction is generalized from unary to n-ary. This enables the compiler to emit more performant code when a lambda-abstraction receives multiple arguments; Without that generalization, the arguments must be represented as a tuple, discarding the possibility to pass the arguments of a function using multiple registers.

Some additional notations for Π are defined in =core/VERSION/notation.neut=:
#+BEGIN_SRC neut
(notation forall Π)

(notation Pi Π)

(notation lambda Π-introduction)

(notation λ Π-introduction)

; tells the compiler that the type of `e` is `t`
(notation (witness t e)
  ((λ ((x t)) x) e))
#+END_SRC
Incidentally, I personally recommend you to use the =witness= notation above when defining a function to write the resulting type of the function explicitly. For example, the code
#+BEGIN_SRC neut
(define fact ((x i64))
  (witness i64
    (if (icmp-sle-i64 x 0)
      1
      (mul-i64 x (fact (sub-i64 x 1))))))
#+END_SRC
is preferred to:
#+BEGIN_SRC neut
(define fact ((x i64))
  (if (icmp-sle-i64 x 0)
    1
    (mul-i64 x (fact (sub-i64 x 1)))))
#+END_SRC

*** COMMENT Π-introduction-fix
=Π-introduction-fix= is for recursion.
**** Example
#+BEGIN_SRC neut
(let fact
  (fix self ((x i64))
    (if (icmp-sle-i64 x 0) ; i.e. if x <= 0
      1
      (mul-i64 x (self (sub-i64 x 1))))))
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(fix LEAF_PLUS (LEAF_PLUS ... LEAF_PLUS) TREE)

LEAF_PLUS ::= LEAF | (LEAF TREE)
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
Γ, f : (Π ((x1 A1) ... (xn An)) B), x1 : A1, ..., xn : An |- e : B
-------------------------------------------------------------------- (fix)
Γ |- (fix f ((x1 A1) ... (xn An)) e) : (Π ((x1 A1) ... (xn An)) B)
#+END_SRC
**** Semantics
#+BEGIN_SRC neut
(Π-elimination (fix self ((x1 A1) ... (xn An)) e) v1 ... vn)
~> e {x1 := v1,
      ...,
      xn := vn,
      self := (fix self ((x1 A1) ... (xn An)) e)}
#+END_SRC
**** Notes
Every tail call is optimized into a loop.

The logic of neut doesn't adopt the universe hierarchy, and thus inconsistent. This means that the Z combinator can be written in the source language as an ordinary term. In other words, from the viewpoint of expressive power, =fix= is simply redundant. The existence of =fix= is just for optimization purpose.

# (By the way, can it be said that the weakly-normalizing fragment of CoC-without-universe-hierarchy (CoC-) is consistent? If it is true, it seems to me that we can prove a theorem by taking a proof term of CoC- and check if it halts by trying to reduce the term into its normal form; Or just a delusion?)

*** constant
=constant= is for external constants.
**** Example
#+BEGIN_SRC neut
((constant add-i64) 1 3) ; ~> 4
(add-i64 1 3)            ; ~> 4
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(constant LEAF)
LEAF
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
Γ |- A : tau          {`c` is declared to be a constant of type `A`}
--------------------------------------------------------------------- (constant)
         Γ |- (constant c) : A
#+END_SRC
**** Semantics
The =constant= rule doesn't have any operational semantics by itself; Each constant has its own dedicated semantics.
**** Notes
If a leaf is declared to be a constant using the [[#constant][constant]] statement beforehand, the leaf is interpreted as =(constant LEAF)=.

*** int
=i{n}= is the integer type in LLVM.
**** Example
#+BEGIN_SRC neut
(add-i64 (i64 1) 2)
(i32 10)
23456789
(mul-i2 (i2 100) 3)
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
; the integer type i{n}
i{n} [where n is one of 1, 2, ..., 64]

; an integer of type i{n}
(i{n} LEAF)  [where n is one of 1, 2, ..., 64]

; an integer without explicit type info
LEAF [where this LEAF can be parsed as integer]
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
well-formed(Γ)     {`l` is an integer}     {i{n} is a valid integer type}
--------------------------------------------------------------------------- (integer)
                  Γ |- (i{n} l) : i{n}
#+END_SRC
**** Semantics
The terms of an integer type don't have any operational semantics by themselves.
**** Notes
The =int= type in neut is the same as the one of LLVM, restricted into =i1=, =i2=, ..., =i64=.

Every integer of type =i{n}= is interpreted modulo =2^n=, just as in the same way of LLVM. For example, =(i2 10)= is the same as =(i2 6)=, =(i2 2)=, =(i2 -2)=, or =(i2 -6)=, since all of these are equivalent modulo =2^2=.

An integer without explicit type information is overloaded; it's type is firstly set to be unknown, and then inferred.

*** float
=f{n}= is the float type in LLVM.
**** Example
#+BEGIN_SRC neut
(f16 3.8)
(f32 9.22888)
(f64 1.23456789)
(fadd-f64 1.23456 (f64 7.89))
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
; the float type f{n}
f{n}   [where n is one of 16, 32, 64]

; a float of type f{n}
(f{n} LEAF) [where n is one of 16, 32, 64]

LEAF [where this LEAF can be parsed as float]
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
well-formed(Γ)     {`l` is a float}      {f{n} is a valid float type}
------------------------------------------------------------------------ (float)
                  Γ |- l : f{n}
#+END_SRC
**** Semantics
The terms of a float type don't have any operational semantics by themselves.
**** Notes
The =float= type in neut is the same as the one of LLVM. Specifically, LLVM's =half= corresponds to neut's =f16=, =float= to =f32=, and =double= to =f64=.

An float without explicit type information is overloaded; it's type is firstly set to be unknown, and then inferred.

*** enum
=enum= is the enumeration type.
**** Example
See the example in [[#enum][the section about the enum statement]].
**** Syntax
#+BEGIN_SRC neut
(enum LEAF)

(enum-introduction LEAF)
LEAF

(enum-elimination TREE
  (ENUM_CASE TREE)
  ...
  (ENUM_CASE TREE))

ENUM_CASE ::= LEAF | default
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
well-formed(Γ)  {`E` is declared to be an enum type}
----------------------------------------------------- (enum)
                 Γ |- (enum E) : tau


well-formed(Γ)   {`l` is a value of enum-type `(enum E)`}
----------------------------------------------------------- (enum-introduction)
       Γ |- (enum-introduction l) : (enum E)


Γ |- e : (enum E)       (Γ |- e_l : A) for all l ∈ E = {l1, ..., ln}
---------------------------------------------------------------------- (enum-elimination)
       Γ |- (enum-elimination e (l1 e1) ... (ln en)) : A
#+END_SRC
**** Semantics
#+BEGIN_SRC neut
(enum-elimination (enum-introduction c)
  (c1 e1)
  ...
  (cn en))
~> ei [where c = ci]

(enum-elimination (enum-introduction c)
  (c1 e1)
  ...
  (cn en)
  (default e)
  ...)
~> e [where e != e1, ..., en]
#+END_SRC

**** Notes
The cases of an enum-elimination must be exhaustive.

# ** array
# =array= is the array type in LLVM.
# *** Example
# #+BEGIN_SRC neut
# ; float array
# (let _
#   (array-introduction f16 3.28 2.14 2.0 9.82))

# (let xs
#   (array-introduction i64 1 2 -30 20))

# (let k
#   (with identity.bind
#     (let a (i64.array-access 0 4 &xs))
#     (let b (i64.array-access 1 4 &xs))
#     (let c (i64.array-access 2 4 &xs))
#     (let d (i64.array-access 3 4 &xs))
#     (erase xs)
#     (i64.add a (i64.add b (i64.add c d)))))

# (i64.print k) ; -7

# (i64.print
#   (array-elimination i64 (a b c d) xs
#     (i64.add a (i64.add b (i64.add c d))))) ; -7
# #+END_SRC
# *** Syntax
# #+BEGIN_SRC text
# ; the array type
# (array TREE LOWTYPE)

# (array-introduction LOWTYPE TREE ... TREE)

# (array-elimination LOWTYPE (LEAF_PLUS ... LEAF_PLUS) TREE TREE)

# LOWTYPE ::= i{n} | f{n}

# LEAF_PLUS ::= LEAF | (LEAF TREE)
# #+END_SRC
# *** Inference Rule
# #+BEGIN_SRC text
# Γ |- len : i64    {`k` is an integer type or a float type}
# ----------------------------------------------------------- (array)
#               Γ |- (array len k) : tau


# Γ |- l1 : k   ...  Γ |- ln : k      {`k` is an integer type or a float type}
# ----------------------------------------------------------------------------- (array-introduction)
#        Γ |- (array-introduction k l1 ... ln) : (array (i64 n) k)


# Γ |- e1 : (array (i64 n) k)     Γ, x1 : k, ..., xn : k |- e2 : B
# ------------------------------------------------------------------- (array-elimination)
#  Γ |- (array-elimination k (x1 ... xn) e1 e2) : B
# #+END_SRC
# *** Semantics
# #+BEGIN_SRC neut
# (array-elimination _ (x1 ... xn) (array-introduction _ e1 ... en) e)
# ~> e {x1 := e1,
#       ...,
#       xn := en}
# #+END_SRC
# *** Notes
# The type of elements of an array must be the integer type, or the float type.

# The memory layout of an array is the same as the one of LLVM; For example, an array of type =i8= is aligned as in the array =[0 x i8]= in LLVM.

# The array type can be used, for example, to implement string.

# You won't use =array-elimination= in actual code; You would use the constant =array-access= instead.

# ** struct
# =struct= is the struct type in LLVM.
# *** Example
# #+BEGIN_SRC neut
# (let st
#   (struct-introduction
#     (f16 3.8)
#     (i8 8)
#     (i16 -300)
#     (f32 33.0)
#     (i64 30)
#     (i64 10)
#     (f64 -329444.4444444)
#     (i8 9)))

# (i64.print
#   (struct-elimination
#     ((_ f16) (_ i8) (_ i16) (_ f32) (z i64) (w i64) (_ f64) (_ i8))
#     st
#     (i64.add z w))) ; ~> 40
# #+END_SRC
# *** Syntax
# #+BEGIN_SRC neut
# ; the struct type
# (struct LOWTYPE ... LOWTYPE)

# (struct-introduction (LOWTYPE TREE) ... (LOWTYPE TREE))

# (struct-elimination ((LEAF LOWTYPE) ... (LEAF LOWTYPE)) TREE TREE)

# LOWTYPE ::= i{n} | f{n}
# #+END_SRC
# *** Inference Rule
# #+BEGIN_SRC text
# well-formed(Γ)    {Every `ki` in {`k1`, ..., `kn`} is either an integer type or a float type}
# ---------------------------------------------------------------------------------------------- (struct)
#                          Γ |- (struct k1 ... kn) : tau


# Γ |- e1 : k1   (...)   Γ |- en : kn      Γ |- (struct k1 ... kn) : tau
# -------------------------------------------------------------------------- (struct-introduction)
#    Γ |- (struct-introduction (e1 k1) ... (en kn)) : (struct k1 ... kn)


# Γ |- e1 : (struct k1 ... kn)       Γ, x1 : k1, ..., xn : kn |- e2 : B
# --------------------------------------------------------------------------- (struct-elimination)
#     Γ |- (struct-elimination ((x1 k1) ... (xn kn)) e1 e2) : B
# #+END_SRC
# *** Semantics
# #+BEGIN_SRC text
# (struct-elimination (x1 _) ... (xn _) (struct-introduction (_ e1) ... (_ en)) e)
# ~> e {x1 := e1,
#       ...,
#       xn := en}
# #+END_SRC
# *** Notes
# Note that an element of a struct type in neut is restricted into an integer or a float. This means, among others, that you can't write a struct that contains another struct, or a memory region. This might get in the way when you implement an interface of a syscall; You might want to use the constant =unsafe.cast= in that case, or "flatten" the struct.

# The memory layout of a struct is the same as the one of LLVM; For example, a struct of type =(struct i8 f16 i32)= is aligned as in a struct of type ={i8, f16, f32}= in LLVM.

# The struct type is intended to be used for implementation of interfaces of syscalls.

*** question
=question= requests the compiler to show the type of a term.
**** Example
#+BEGIN_SRC neut
(let x top.unit)

(question x)
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(question TREE)

?TREE
#+END_SRC
**** Inference Rule
#+BEGIN_SRC text
     Γ |- e : A
----------------------- (question)
Γ |- (question e) : A
#+END_SRC
**** Semantics
#+BEGIN_SRC neut
(question e)
~> e
#+END_SRC
**** Notes
The type of a term wrapped by =question= is reported by the compiler. This might be useful when used in harmony with a linter like flycheck.

*** derangement
TBD
# ** LLVM-Based Primitives
# neut currently supports the following LLVM instructions: =fneg, add, fadd, sub, fsub, mul, fmul, udiv, sdiv, fdiv, urem, srem, frem, shl, lshr, ashr, and, or, xor, trunc, zext, sext, fptrunc, fpext, fptoui, fptosi, uitofp, sitofp, icmp, fcmp=.

# Each instruction is "separated" according to its type. Let us take the instruction =fneg= for example. This instruction can be applied to =half=, =float=, and =double= in LLVM. Thus, neut has the following three constants as primitives: =fneg-f16, fneg-f32, fneg-f64=. For the instruction =add=, the constants =add-i1, add-i2, ..., add-i64= is available.

# The instructions with two type arguments like =fptosi= is named as =fptosi-f64-i32, fptosi-f32-i1, fptosi-f16-i5=, etc.

# As for the comparison operators =icmp= and =fcmp=, the names are of the form ={icmp, fcmp}-{CONDITION}-{TYPE}=. For example, =icmp-eq-i16, icmp-ult-i32, icmp-sge-i64, fcmp-ogt-f32, fcmp-ord-f16, fcmp-ueq-f64= are all valid.

# The semantics of these instructions is as specified in the [[https://llvm.org/docs/LangRef.html][LLVM Language Reference Manual]].

# ** Syscalls
# neut supports syscalls, although its current support is far from complete. As you can see in =core/VERSION/constant/{linux, darwin}.neut=, only basic syscalls like =read, write, exit, open, close= are supported. This is not something that is caused by theoretical difficulties; Rather, this is simply because of my limited resource of time.

# It would be worth noting that a syscall can't produce/consume a resource. For example, the syscall =write= is declared to have the following type in neut:
# #+BEGIN_SRC neut
# (constant os.write
#   (Π
#     ((len i64)
#      (out file-descriptor)
#      (buf (array len i8))
#      (nbyte i64))
#     (product (array len i8) i64)))
# #+END_SRC
# Compare the type above with the C signature of =write=:
# #+BEGIN_SRC c
# ssize_t write(int fildes, const void *buf, size_t nbyte);
# #+END_SRC
# Ignoring the =(len i64)= part that is necessary to receive an array of arbitrary length, the crucial difference here is the types of the codomains. While the latter one returns ordinary =ssize_t= (integer), the former one also returns the original array. This is because the syscall =write= doesn't consume (i.e. deallocate) given string. If =write= in neut didn't return the original string, the string would be never freed in the succeeding program, causing space leak.

# Regarding macOS: You may note that the "syscalls" are lowered to some external interface functions on macOS. This is because macOS doesn't support a direct use of a syscall; Indeed, for example, if we were to use the syscall =fork= directly (0x2000002), a succeeding =malloc= causes a fatal error, saying something like =mach_vm_map(size=1048576) failed (error code=268435459)=.

# Implementation note: A syscall can be added via the following procedure:
# 1. Declare corresponding constant (like =os.write=) using the [[#constant][constant]] statement
# 2. Register its argument information and the syscall number in =src/Data/Syscall.hs=
# 3. Rebuild the compiler and run some test codes to check if it really works
# Here, the "argument information" is a list consists of one of the following tags: "immediate", "struct", "array", and "unused". This information is necessary to generate a corresponding syscall without writing each function definition explicitly. For example, consider you add a syscall =foo= with its argument information ["unused", "immediate", "struct", "array"]. This creates a function with 4 arguments. Let us call these arguments =x1=, =x2=, =x3=, and =x4=. The compiler then generates a function that calls the syscall, assuming that the "struct"- and "array"-tagged arguments are borrowed one. That is, the compiler generates a function that is defined schematically as follows:
# #+BEGIN_SRC haskell
# syscall-foo x1 x2 x3 x4 :=
#   let result := CALL_SYSCALL(foo, x2, x3, x4) in
#   return (x2, x3, result)
# #+END_SRC
# Using this mechanism, for example, the actual implementation of the syscall =os.write= above can be generated from ["unused", "immediate", "array", "immediate"]:
# #+BEGIN_SRC haskell
# syscall-os.write A out buf nbyte :=
#   let result := CALL_SYSCALL(write, out, buf, nbyte) in
#   return (buf, result)
# #+END_SRC

# ** Array Indexing
# neut offers a family of constants that allows us to access an element of an array. The names of these constants are of the form ={LOWTYPE}.array-access=, where the ={LOWTYPE}= is either =i{n}= or =f{n}=. For example, =i8.array-access= can be used for indexing of an array of type =(array N i8)=.

# The types of these accesser are of the following form:
# #+BEGIN_SRC neut
# (Π
#   ((i i64)
#    (n i64)
#    (_ (array n LOWTYPE)))
#   (product (array n LOWTYPE) LOWTYPE))
# #+END_SRC
# where the first argument =i= specifies the index of the array, and the second argument =n= specifies the length of the array. Using this constant, one can use an element of an array without consuming the array as follows:
# #+BEGIN_SRC neut
# (let xs
#   (array-introduction i64 1 2 -30 20))

# (with identity.bind
#   (let a (i64.array-access 0 * &xs)) ; the `*` is inferred to be `4`, since the length of `xs` is 4
#   (let b (i64.array-access 1 * &xs))
#   (let c (i64.array-access 2 * &xs))
#   (let d (i64.array-access 3 * &xs))
#   (i64.add a (i64.add b (i64.add c d)))) ; 1 + 2 + (-30) + 20
# #+END_SRC

# ** Unsafe Cast
# The constant =unsafe.cast : Pi (A : tau, B : tau, x : A). B= is available (assuming that the constant is declared using the statement [[#constant][constant]]). The semantics of this constant is the no-op cast:
# #+BEGIN_SRC neut
# (unsafe.cast t1 t2 e)
# ~> e
# #+END_SRC

# You can easily break the resource management system of neut using this constant. Consider the following example:
# #+BEGIN_SRC neut
# (ensure core/0.1.0.0
#   "https://github.com/u2zv1wx/neut-core/raw/master/release/0.1.0.0.tar.gz")

# ; (note that this declares the constant unsafe.cast)
# (include "core/0.1.0.0/core.neut")

# (let z (unsafe.cast i64 (Π ((_ i64)) i64) 1))

# (let foo z) ; (*1)

# (let bar z) ; (*2)
# #+END_SRC
# The code above uses the variable =z= for the two times. Since =z= is casted to a Π-type, The resulting code tries to copy the integer =1= as if it were a closure. Since the internal representation of a closure at least uses 3 words, this causes an access to an invalid memory region, that is, a segmentation fault.

** Auxiliary Statements

*** define-data
TBD
# =inductive= defines an inductive type, its introduction rules (constructors), and its pattern match function.
# *** Example
# #+BEGIN_SRC neut
# (inductive list ((a tau))
#   (nil ()
#     (list a))
#   (cons ((_ a) (_ (list a)))
#     (list a)))

# (define length
#   ((a tau)
#    (xs (list a)))
#   (list.case i64 a xs
#     (λ ()
#       0)
#     (λ (_ ys)
#       (add-i64 1 (length a ys)))))

# (let xs (list.cons * 10 (list.cons * 20 (list.nil i64))))

# (i64.print (length xs)) ; ~> 2

# ; mutually inductive types
# (inductive
#   (even ((_ (nat)))
#     (zero-is-even
#       ()
#       (even (nat.zero)))
#     (succ-of-odd-is-even
#       ((n (nat))
#        (_ (odd n)))
#       (even (nat.succ n))))
#   (odd ((_ (nat)))
#     (succ-of-even-is-odd
#       ((n (nat))
#        (_ (even n)))
#       (odd (nat.succ n)))))
# #+END_SRC
# *** Syntax
# #+BEGIN_SRC neut
# (inductive LEAF ((LEAF TREE) ... (LEAF TREE))
#   (LEAF ((LEAF TREE) ... (LEAF TREE))
#     TREE)
#   ...
#   (LEAF ((LEAF TREE) ... (LEAF TREE))
#     TREE))

# ; n-mutual inductive type
# (inductive
#   (LEAF ((LEAF TREE) ... (LEAF TREE))
#     (LEAF ((LEAF TREE) ... (LEAF TREE))
#       TREE)
#     ...
#     (LEAF ((LEAF TREE) ... (LEAF TREE))
#       TREE))
#   ...
#   (LEAF ((LEAF TREE) ... (LEAF TREE))
#     (LEAF ((LEAF TREE) ... (LEAF TREE))
#       TREE)
#     ...
#     (LEAF ((LEAF TREE) ... (LEAF TREE))
#       TREE)))
# #+END_SRC
# *** Semantics
# When parsed, the =inductive= statement is translated into the =let= statements that defines (1) the inductive type, (2) the introduction rules (or the constructors of the inductive type), and (3) the pattern match function. For example, consider the following =inductive= statement:
# #+BEGIN_SRC neut
# (inductive list ((a tau))
#   (nil ()
#     (list a))
#   (cons ((_ a) (_ (list a)))
#     (list a)))
# #+END_SRC
# Given this statement, the compiler generates the =let= statements that define the followings:
# 1. The inductive type =list : Pi (a : tau). tau=
# 2. The introduction rules (constructors) of the type:
#    - =list.nil : Pi (a : tau). list a=
#    - =list.cons : Pi (a : tau, _ : a, _ : list a). list a=
# 3. The pattern matching function of the type:
#    - =list.case : Π (z : tau, a : tau, _ : list a, on-nil : Π (). z, on-cons : Π (_ : a, _ : list a). z). z=
# The structure of a pattern matching function is: =Π (RESULT_TYPE : tau, {ARGUMENTS_OF_THE_INDUCTIVE_TYPE}, {THE_TERM_BEING_MATCHED}, {LIST_OF_CLAUSES}). RESULT_TYPE=.

# The codomain of each constructor must be of the form =(a e1 ... en)=, where the =a= is the inductive type being defined. For example,
# #+BEGIN_SRC neut
# (inductive foo ((x bool))
#   (bar () i64))
# #+END_SRC
# is an invalid =inductive= statement, since the codomain of =bar= is not of the form =(foo _)=, but =i64=.

*** define-codata
TBD
# The =record= statement creates a record type, its elimination rules (destructors), and its introduction rule.
# *** Example
# #+BEGIN_SRC neut
# (record my-record ((a tau))
#   (item-1
#     a)
#   (item-2
#     i64)
#   (item-3
#     top))

# (let item
#   (my-record.new
#     i64
#     10
#     20
#     top.unit))

# (i64.print (my-record.item-1 i64 item)) ; ~> 10

# (i64.print (my-record.item-2 i64 item)) ; ~> 20
# #+END_SRC
# *** Syntax
# #+BEGIN_SRC neut
# (record LEAF ((LEAF TREE) ... (LEAF TREE))
#   (LEAF TREE)
#   ...
#   (LEAF TREE))
# #+END_SRC
# *** Semantics
# When parsed, the =record= statement is translated into =let= statements that defines (1) the record type, (2) the elimination rules (or the destructors of the record type), and (3) the introduction rule. For example, consider the following =record= statement:
# #+BEGIN_SRC neut
# (record my-record ((a tau))
#   (item-1
#     a)
#   (item-2
#     i64)
#   (item-3
#     top))
# #+END_SRC
# Given this statement, the compiler generates [[#definelet][let]] statements that define the followings:
# 1. The record type =my-record : Pi (a : tau). tau=
# 2. The elimination rules (destructors) of the type:
#    - =my-record.item-1 : Pi (a : tau, _ : my-record a). a=
#    - =my-record.item-2 : Pi (a : tau, _ : my-record a). i64=
#    - =my-record.item-3 : Pi (a : tau, _ : my-record a). top=
# 3. The introduction rule of the type:
#    - =my-record.new : Π (a : tau, item-1 : a, item-2 : i64, item-3 : top). my-record a=

# Internally, every record statement is translated into the corresponding [[#inductive][inductive]] statement. For example, given the =record= statement above, the compiler translates it into the following =inductive= statement:
# #+BEGIN_SRC neut
# (inductive my-record ((a tau))
#   (new
#     ((item-1 a)
#      (item-2 i64)
#      (item-3 top))
#     (my-record a)))
# #+END_SRC
# The compiler then processes this statement in the same way ordinary =inductive= statement, generating the record type =my-record= and the introduction rule =my-record.new=, and the pattern matching function =my-record.case=. After that, the compiler automatically generates destructors from this definition via =my-record.case=. For example, the generated definition of =my-record.item-1= is as follows:
# #+BEGIN_SRC neut
# (define my-record.item-1 ((a tau) (record-value (my-record a)))
#   (my-record.case a record-value
#     (λ (item-1 item-2 item-3) item-1)))
# #+END_SRC
# The other destructors are defined similarly.

*** define-resource-type
TBD


** Auxiliary Terms
*** asterisk
=*= is a placeholder that must be inferred.
**** Example
#+BEGIN_SRC neut
(define id ((a tau) (x a)) x)

(enum foo value)

(id foo foo.value) ; ~> foo.value

(id * foo.value) ; ~> foo.value (`*` is inferred to be `foo`)
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
**
#+END_SRC
**** Semantics
=*= doesn't have any operational semantics.
**** Notes
=*= can be used as a placeholder that must be resolved by the compiler using the constraints generated in its type inference procedure.

If the type is not determined, the compiler raises an error; For example, the type of =x= in the following code is not determined:
#+BEGIN_SRC neut
(let x 10)
#+END_SRC
since the =10= cannot be determined to be =i32=, =i16=, or =i64=, etc.

*** sigma
=sigma= is the existential quantification.
**** Example
#+BEGIN_SRC neut
; binary sigma-intro without dependence
(let pair
  (sigma-introduction (i64 2) (λ ((x tau)) x)))

; binary sigma-elim without dependence
(sigma-elimination (x _) pair
  (i64.print x))

(let n-pair
  (sigma-introduction
    (i64 1)
    (λ ((x tau)) x)
    (f32 10.82)
    top.unit
    top.unit
    top
    tau))

(let 0-pair
  (sigma-introduction)
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(sigma ((x1 A1) ... (xn An)) B)

(sigma-introduction e1 ... en)

(sigma-elimination (LEAF_PLUS ... LEAF_PLUS) e1 e2)

LEAF_PLUS ::= LEAF | (LEAF TREE)
#+END_SRC
**** Semantics
#+BEGIN_SRC text
(sigma ((x1 A1) ... (xn An)) B)
~> (Π ((Z tau)
        (_ (Π ((x1 A1) ... (xn An) (_ B)) Z)))
       Z))

(sigma-introduction e1 ... en)
~> (Π-introduction
     ((Z tau)
      (k (Π ((x1 hole) ... (xn hole)) Z)))
     (k e1 ... en))

(sigma-elimination ((x1 A1) ... (xn An)) e1 e2)
~> (e1 hole (lambda ((x1 A1) ... (xn An)) e2))
#+END_SRC
**** Notes
Actual definition of =sigma= is found in =core/VERSION/notation.neut=; =sigma= is just a convenient notation of a certain use of =Π=. This encoding is the ordinary one in CoC.

Sigma-type with dependence can be used, for example, to realize the type of string as follows:
#+BEGIN_SRC text
(define string
  (sigma ((len i64)) (array len i8)))
#+END_SRC
In this case, a term of this =string= type is something like =(3, [10, 20, 30])=. The first element is the =len : i64= part. This part contains the length information of a string. The second element is the actual content of the string.

A sigma-type without dependence is the familiar product type; =(sigma ((_ A1) ... (_ An)) B)= is =(product A1 ... An B)=.

*** with
=with= is a do-notation with the bind operation made explicit.
**** Example
#+BEGIN_SRC neut
(with identity.bind
  (let str "foo")
  (let _ (string.print &str))
  (string.print &str) ; the same as (let _ (string.print &str))
  (let x (i64 10))
  (let y (add-i64 100 x))
  (i64.print y))

(with identity.bind
  (let str "foo")
  (let _
    (let _ (i64 100)) ; each `e` in `(let x e)` is implicitly wrapped by `with`
    (string.print &str)
    (string.print &str))
  (string.print &str)
  (let len (string.print &str))
  len)
#+END_SRC
**** Syntax
#+BEGIN_SRC neut
(with TREE TREE ... TREE)
#+END_SRC
**** Semantics
#+BEGIN_SRC text
(with bind (let x (e e1 ... en)) rest+)
~> (bind * * (with (e e1' ... en'))
     (lambda (sig)
       (sigma-elimination (x1 ... xj) sig (with rest+))))
where:
  ei' := if ei == &x then x else ei
  x1, ..., xj := (all the "borrowed" variables in e1, ..., en)
  sig : a fresh variable

(with bind (let x e) rest+)
~> (bind * * (with e)
     (lambda (x) (with rest+)))

(with bind e rest+)
~> (with bind (let _ e) rest+)

(with bind (erase x1 ... xn) rest+)
~> (erase (x1 ... xn) (with bind rest+))

(with e)
~> e
#+END_SRC
**** Notes
=with= can be understood as a generalization of =begin= in Scheme, or an explicit version of the =do= notation in Haskell.

The "borrowing" is covered by the first rule of the semantics; As you can see from the definition, this realization of borrowing works for any =bind= operation.

Note that the =bind= operator is not restricted to monadic bind; You can set any term there as long as the resulting term of this syntactic translation is well-typed.

The =e= in =(let x e)= is automatically surrounded by =with=.

*** case, case-noetic
TBD

*** Partial Application
**** Example
#+BEGIN_SRC neut
(define id ((a tau) (x a)) x)

; ordinary application
(id bool bool.true)

; partial application
((id bool _) bool.true)

; of course you can bind the partially-applied function to a variable
(let id-bool (id bool _))

(id-bool bool.true)
#+END_SRC

**** Sematics
#+BEGIN_SRC text
(e e1 ... en)  [where e_{i1} = _, ..., e_{im} = _]
~> (λ (x1 ... xm) (e e1 ... en)) [replacing e_{ik} with xk]
#+END_SRC

* Compiler Subcommands
The =neut= binary provides the subcommands in this section.

** archive
*** Example
#+BEGIN_SRC shell
neut archive path/to/source/directory -o path/to/release/directory/0.1.0.0.tar.gz
#+END_SRC
*** Notes
The =archive= subcommand creates a tar.gz archive from the specified directory. The [[#ensure][ensure]] statement expects an archive created by this subcommand.

** build
*** Example
#+BEGIN_SRC shell
neut build path/to/file.neut             # create an executable ./file
neut build -o output path/to/file.neut --clang-option "-fsanitize=memory -g"   # create an executable ./output, using clang's option "-fsanitize=memory -g"
neut build --emit llvm path/to/file.neut # create a LLVM IR file ./file.ll
neut build --emit asm path/to/file.neut  # create an assembly code ./file.s
#+END_SRC
*** Notes
The =build= subcommand builds given source code and emits resulting code.

Internally, these command firstly creates an LLVM IR, then passes it to =clang= (if necessary).

** check
*** Example
#+BEGIN_SRC shell
neut check path/to/file.neut
neut check --no-color path/to/file.neut
neut check --end-of-entry EOE path/to/file.neut
#+END_SRC
*** Notes
The =check= subcommand type-checks given file.

If =--no-color= option is specified, the result of type checking is printed without console color.

If =--end-of-entry SEPARATOR= is specified, each entry of the result of type checking is followed by =SEPARATOR=.

This subcommand is intended to be used with an editor-side syntax checker like [[https://www.flycheck.org/en/latest/][flycheck]].

* Contribution

** Development
*** The Structure of the Compiler

** Donation

* Contact
veka41@protonmail.ch (english/japanese)

* Things Left Undone
- sophistication on library-related things
- incremental compilation
- track the location of a code piece when expanding macros more acculately
- better pattern matching syntax (like nested pattern)
- syntax highlighter for editors other than Emacs
- primitive-level exception
- wrapper library for parallel computation
- etc.

* Appendix

** LLVM IR for the First Example
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ; <REPETITION 1>
  ; <memory allocation for the string>
  %_11875 = getelementptr i8, i8* null, i64 1
  %_11876 = ptrtoint i8* %_11875 to i64
  %_11877 = call fastcc i8* @malloc(i64 %_11876)
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  %_11878 = bitcast i8* %_11877 to [1 x i8]*
  %_11879 = inttoptr i8 97 to i8*
  %_11880 = ptrtoint i8* %_11879 to i8
  %_11881 = getelementptr [1 x i8], [1 x i8]* %_11878, i32 0, i64 0
  store i8 %_11880, i8* %_11881
  ; <write the string into stdout>
  %_11882 = inttoptr i64 1 to i8*
  %_11883 = inttoptr i64 1 to i8*
  %_11884 = call fastcc i8* @write(i8* %_11882, i8* %_11877, i8* %_11883)
  %_11885 = bitcast i8* %_11877 to [1 x i8]*
  %_11886 = getelementptr [1 x i8], [1 x i8]* %_11885, i32 0, i32 0
  %_11887 = load i8, i8* %_11886
  %_11888 = bitcast [1 x i8]* %_11885 to i8*
  ; <memory deallocation for the string>
  call fastcc void @free(i8* %_11888)
  %_11889 = inttoptr i8 %_11887 to i8*
  ; <REPETITION 2>
  ; <memory allocation for the string>
  %_11890 = getelementptr i8, i8* null, i64 1
  %_11891 = ptrtoint i8* %_11890 to i64
  %_11892 = call fastcc i8* @malloc(i64 %_11891)
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  %_11893 = bitcast i8* %_11892 to [1 x i8]*
  %_11894 = inttoptr i8 97 to i8*
  %_11895 = ptrtoint i8* %_11894 to i8
  %_11896 = getelementptr [1 x i8], [1 x i8]* %_11893, i32 0, i64 0
  store i8 %_11895, i8* %_11896
  ; <write the string into stdout>
  %_11897 = inttoptr i64 1 to i8*
  %_11898 = inttoptr i64 1 to i8*
  %_11899 = call fastcc i8* @write(i8* %_11897, i8* %_11892, i8* %_11898)
  %_11900 = bitcast i8* %_11892 to [1 x i8]*
  %_11901 = getelementptr [1 x i8], [1 x i8]* %_11900, i32 0, i32 0
  %_11902 = load i8, i8* %_11901
  %_11903 = bitcast [1 x i8]* %_11900 to i8*
  ; <memory deallocation for the string>
  call fastcc void @free(i8* %_11903)
  %_11904 = inttoptr i8 %_11902 to i8*
  ; <REPETITION 3>
  ; <memory allocation for the string>
  %_11905 = getelementptr i8, i8* null, i64 1
  %_11906 = ptrtoint i8* %_11905 to i64
  %_11907 = call fastcc i8* @malloc(i64 %_11906)
  ; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  %_11908 = bitcast i8* %_11907 to [1 x i8]*
  %_11909 = inttoptr i8 97 to i8*
  %_11910 = ptrtoint i8* %_11909 to i8
  %_11911 = getelementptr [1 x i8], [1 x i8]* %_11908, i32 0, i64 0
  store i8 %_11910, i8* %_11911
  ; <write the string into stdout>
  %_11912 = inttoptr i64 1 to i8*
  %_11913 = inttoptr i64 1 to i8*
  %_11914 = call fastcc i8* @write(i8* %_11912, i8* %_11907, i8* %_11913)
  %_11915 = bitcast i8* %_11907 to [1 x i8]*
  %_11916 = getelementptr [1 x i8], [1 x i8]* %_11915, i32 0, i32 0
  %_11917 = load i8, i8* %_11916
  %_11918 = bitcast [1 x i8]* %_11915 to i8*
  ; <memory deallocation for the string>
  call fastcc void @free(i8* %_11918)
  %_11919 = inttoptr i8 %_11917 to i8*
  ; <return 0>
  %_11920 = inttoptr i64 0 to i8*
  %_11921 = ptrtoint i8* %_11920 to i64
  ret i64 %_11921
}
#+END_SRC

** LLVM IR for the Second Example
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ; memory allocation
  %_12034 = getelementptr i8, i8* null, i64 1
  %_12035 = ptrtoint i8* %_12034 to i64
  %_12036 = call fastcc i8* @malloc(i64 %_12035)
  ; create the string "a" (i.e. write the character 'a' to the allocated memory)
  %_12037 = bitcast i8* %_12036 to [1 x i8]*
  %_12038 = inttoptr i8 97 to i8* ; a = 97
  %_12039 = ptrtoint i8* %_12038 to i8
  %_12040 = getelementptr [1 x i8], [1 x i8]* %_12037, i32 0, i64 0 ; where to write 'a'
  store i8 %_12039, i8* %_12040 ; write a
  ; write the string into stdout for the three times
  %_12041 = inttoptr i64 1 to i8* ; this `1` stands for stdout
  %_12042 = inttoptr i64 1 to i8* ; this `1` is the length of the string in bytes
  %_12043 = call fastcc i8* @write(i8* %_12041, i8* %_12036, i8* %_12042)
  %_12044 = inttoptr i64 1 to i8*
  %_12045 = inttoptr i64 1 to i8*
  %_12046 = call fastcc i8* @write(i8* %_12044, i8* %_12036, i8* %_12045)
  %_12047 = inttoptr i64 1 to i8*
  %_12048 = inttoptr i64 1 to i8*
  %_12049 = call fastcc i8* @write(i8* %_12047, i8* %_12036, i8* %_12048)
  ; memory deallocation
  %_12050 = bitcast i8* %_12036 to [1 x i8]*
  %_12051 = getelementptr [1 x i8], [1 x i8]* %_12050, i32 0, i32 0
  %_12052 = load i8, i8* %_12051
  %_12053 = bitcast [1 x i8]* %_12050 to i8*
  call fastcc void @free(i8* %_12053)
  %_12054 = inttoptr i8 %_12052 to i8*
  ; return 0
  %_12055 = inttoptr i64 0 to i8*
  %_12056 = ptrtoint i8* %_12055 to i64
  ret i64 %_12056
}
#+END_SRC
