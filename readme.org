#+TITLE: Neut
Neut is a dependently-typed programming language based on [[https://en.wikipedia.org/wiki/Calculus_of_constructions][the Calculus of Constructions (CoC)]]. The interesting point I believe is that this language determines how to allocate/free memory at compile-time, without extra annotations to the source language. In other words, Neut in its source language is an ordinary lambda-calculus after all (imagine something like Haskell, Coq, Agda, Lean), and at the same time it handles memory without using:

- explicit malloc/free,
- garbage collection,
- region-based memory management.

Theoretically, this is made possible by translating the source language into a dependent-and-linear variant of [[https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf][Call-by-Push-Value]]. The crucial point of the translation is to see that knowing the type of a term is knowning how to eta-expand the term, which in turn means knowing how to copy/discard the term. In the translation, a type is not erased, but *translated into a computationally-meaningful term that copies/discards the terms of the type*. Those who are interested in these theoretical things can find further details <yet-to-be-written>.

Practically, this means that you can write your program in the ordinary lambda calculus without any extra restrictions/annotations, and at the same time are allowed to pursue performance in the language via e.g. borrowing or linearity. The source code doesn't need esoteric annotations for the compiler to infer how to use resources. Nor does the world stop all of a sudden by GC. You have full control over resource allocation.

Here I briefly summerize the basic characteristics of Neut before diving into the details:

- Neut is a compiled language
- The output of Neut is LLVM IR / assembly / object binary (the last two are via clang)
- The type system is CoC + recursion + int + float + enum + array + struct
- The evaluation strategy is call-by-value
- The Memory management is statically determined at compile time (Can be optimized via borrowing and linearity)
- Has inductive/coinductive type (despite the fact that core logic is not CoIC but CoC)

* Table of Contents                                                    :TOC:
- [[#hopefully-illuminating-examples][Hopefully Illuminating Examples]]
  - [[#automatic-memory-management-with-resulting-x64-assembly][Automatic Memory Management (with resulting x64 assembly)]]
  - [[#borrowing-and-its-resulting-assembly][Borrowing (and its resulting assembly)]]
  - [[#memory-reuse-via-linearity][Memory Reuse via Linearity]]
  - [[#hello-world][Hello World]]
  - [[#inductive-type-algebraic-data-type][Inductive type (algebraic data type)]]
  - [[#summary-or-mental-model-of-memory-management-in-neut][Summary, or Mental Model of Memory Management in Neut]]
- [[#installation][Installation]]
- [[#syntax-and-semantics][Syntax and Semantics]]
  - [[#tau][tau]]
  - [[#pi-forall--lambda--apply][Pi (forall / lambda / apply)]]
  - [[#iterate-recursion][Iterate (recursion)]]
  - [[#int][Int]]
  - [[#float][Float]]
  - [[#enum][Enum]]
  - [[#array][Array]]
  - [[#struct][Struct]]
- [[#inductive-and-coinductive-types][Inductive and Coinductive types]]
- [[#universe-hierarchy-and-the-weakly-normalizing-fragment][Universe Hierarchy and the Weakly-Normalizing Fragment]]
- [[#writing-library][Writing Library]]
- [[#where-is-][Where is ...?]]
  - [[#where-is-typeclass][Where is typeclass?]]
- [[#hacking-the-compiler][Hacking the Compiler]]
- [[#references][References]]

* Hopefully Illuminating Examples

** Automatic Memory Management (with resulting x64 assembly)
Let us move on to the interesting part. Here we will see an "inefficient" version of string printing. After that, we will see an efficient version of that code, and compare resulting assembly code.

The `with identity:bind` is the same as so-called do-notation specilized to the identity monad.
#+BEGIN_SRC scheme
(use string)

(with let-bind
  (let str "hello")
  (print str) ;; equivalent to: `(string.print str)`
  (print str)
  (print str))
#+END_SRC
You may note that the language doesn't require the IO monad. This is because the evaluation strategy of Neut is CBV.

** Borrowing (and its resulting assembly)
#+BEGIN_SRC scheme
(with let-bind
  (let str "hello")
  (string.print &str)
  (string.print &str)
  (string.print &str))
#+END_SRC

** Memory Reuse via Linearity

** Hello World
#+BEGIN_SRC neut
(string.print "Hello, world!\n")
#+END_SRC

** Inductive type (algebraic data type)
You can declare an inductive type as follows:
#+BEGIN_SRC scheme
(inductive list ((a type))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))
#+END_SRC
where the haskell equivalent of the code above is:
#+BEGIN_SRC haskell
data List a where
  Nil  :: () -> List a
  Cons :: (A, List a) -> List a
#+END_SRC
You can then pattern match on the term of the type:
#+BEGIN_SRC scheme
(define length
  ((a tau)
   (xs (list a)))
  (case xs
    ((nil)
      0)
    ((cons _ ys)
      (add-i64 1 (length a ys))))) ;; this `add-i64` is lowered to LLVM's instruction 'add` over i64
#+END_SRC
and use it as in the expected way:
#+BEGIN_SRC scheme
(let xs (list.cons (i64 1) (list.cons 2 (list.cons 3))))

(i64.print (length i64 xs)) ;; ~> 3
#+END_SRC
In actual code, you don't have to be that verbose as in the example above, thanks to implicit terms and notations (like Coq, Agda, and Lean). We will see it later.

** Summary, or Mental Model of Memory Management in Neut
- The content of a variable is
  - discarded if and only if the variable isn't used at all.
  - untouched if and only if the variable is used exactly once.
  - copied if and only if the variable is used more than once.
- You can avoid variable copying by borrowing.

* Installation
The currently supported platforms are: Linux (x64), macOS (x64).

Ensure you have already installed =stack= and =clang=. Then, clone the repository and build it:
#+BEGIN_SRC shell
$ git clone https://github.com/u2zv1wx/neut
$ git checkout XXXXXX
$ stack build
$ stack install # installs the binary `neut` into ~/.local/bin
#+END_SRC
Make sure that you have =~/.local/bin= in your =$PATH=.

* Syntax and Semantics

** tau

** Pi (forall / lambda / apply)

** Iterate (recursion)

** Int

** Float

** Enum

** Array

** Struct


* Inductive and Coinductive types
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec eleifend tellus euismod erat accumsan, nec euismod sem placerat. Ut eu lacinia arcu, id imperdiet lacus. Integer feugiat lacus mattis, dictum nunc nec, interdum justo. Fusce sed dui id orci faucibus elementum. Vivamus sit amet sapien a lorem efficitur posuere suscipit in lacus. Praesent eget sagittis nisi, id vehicula elit. Vestibulum laoreet odio ex, a aliquet justo consectetur quis. Aenean laoreet vehicula libero id varius. Vivamus condimentum, sem sed sollicitudin placerat, nulla enim faucibus odio, gravida commodo velit mi ac sapien. Integer feugiat diam in lectus porttitor, sit amet viverra velit malesuada.


* Universe Hierarchy and the Weakly-Normalizing Fragment

* Writing Library

* Where is ...?

** Where is typeclass?

* Hacking the Compiler

* References
- L. de Moura, J. Avigad, S. Kong, and C. Roux, Elaboration in Dependent Type Theory, [[https://arxiv.org/abs/1505.04324]], 2015.
- P. Levy, Call-by-Push-Value: A Subsuming Paradigm, Ph. D. thesis, Queen Mary College, 2001.
