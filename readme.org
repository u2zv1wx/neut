#+TITLE: Neut
Neut is a dependently-typed programming language based on [[https://en.wikipedia.org/wiki/Calculus_of_constructions][the Calculus of Constructions (CoC)]]. The interesting point is that this language determines how to allocate/deallocate memory at compile-time, without extra annotations to the source language. In other words, Neut in its source language is the ordinary lambda-calculus after all (imagine something like Haskell, OCaml, Idris, Coq, Agda, or Lean), and at the same time it handles memory without using, for example:

- explicit malloc/free,
- garbage collection,
- region-based memory management.

Theoretically, this is made possible by translating the source language into a dependent variant of [[https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf][Call-By-Push-Value]]. The crucial point of this translation is to see that knowing the type of a term is knowing how to eta-expand the term, which in turn means knowing how to copy/discard the term. In the translation, a type is not erased, but *translated into a computationally-meaningful term that copies/discards the terms of the type*.

Practically, this means that you can write your program in ordinary lambda-calculus without any extra restrictions or annotations, and at the same time you are allowed to control how resources are used in the program. If you want an ordinary-lambda-calculus based programming language with a human-predictable semantics (including its memory management), this might be for you.

Here I briefly summerize the basic properties of Neut before diving into the details:

- A compiled language
- The output is [[https://llvm.org/docs/LangRef.html][LLVM IR]], assembly, and object binary (the last two are via clang)
- The type system is CoC + fix + int + float + enum + array + struct - universe hierarchy
- The type inference algorithm is based on [[https://arxiv.org/abs/1505.04324][the one of Lean]]
- The evaluation strategy is call-by-value
- Every tail call is optimized into a loop
- Memory allocation/deallocation is statically determined at compile time

* Table of Contents                                                    :TOC:
- [[#examples][Examples]]
  - [[#proof-theoretic-memory-management][Proof-Theoretic Memory Management]]
  - [[#manual-optimization-via-borrowing][Manual Optimization via Borrowing]]
  - [[#automatic-optimization-via-mallocfree-cancellation][Automatic Optimization via malloc/free Cancellation]]
  - [[#summary][Summary]]
- [[#installation][Installation]]
- [[#syntax-and-semantics-of-statements][Syntax and Semantics of Statements]]
  - [[#constant][constant]]
  - [[#ensure][ensure]]
  - [[#enum][enum]]
  - [[#include][include]]
  - [[#inductive][inductive]]
  - [[#introspect][introspect]]
  - [[#notation][notation]]
  - [[#let][let]]
  - [[#record][record]]
  - [[#useunuse][use/unuse]]
  - [[#sectionend][section/end]]
- [[#syntax-and-semantics-of-terms][Syntax and Semantics of Terms]]
  - [[#tau][tau]]
  - [[#upsilon][upsilon]]
  - [[#pi][pi]]
  - [[#fix][fix]]
  - [[#constant-1][constant]]
  - [[#int][int]]
  - [[#float][float]]
  - [[#enum-1][enum]]
  - [[#array][array]]
  - [[#struct][struct]]
- [[#auxiliary-syntax][Auxiliary Syntax]]
  - [[#hole][hole]]
  - [[#sigma][sigma]]
  - [[#with][with]]
- [[#compiler-subcommands][Compiler Subcommands]]
  - [[#archive][archive]]
  - [[#build][build]]
  - [[#check][check]]
- [[#appendix][Appendix]]
  - [[#llvm-ir-for-the-first-example][LLVM IR for the First Example]]
  - [[#llvm-ir-for-the-second-example][LLVM IR for the Second Example]]

* Examples

** Proof-Theoretic Memory Management
*** Basics
Let's see how Neut manages resources. The following code prints the string "a" for the three times:
#+BEGIN_SRC neut
;; download core library (if necessary)
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/archive/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
#+END_SRC
The =(with identity.bind (...))= is the same as so-called do-notation in Haskell or other languages, specilized to the identity monad.

By running =$ neut build --no-alloc-cancellation --emit llvm filename.neut=, we obtain schematically the following LLVM IR (the =--no-alloc-cancellation= is to disable certain optimization that we will see later):
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; Repeat the following for the 3 times:
  ;;   <memory allocation for the string>
  ;;   <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;;   <write the string into stdout>
  ;;   <memory deallocation for the string>
}
#+END_SRC
The non-schematic, actual output can also be found in the [[#llvm-ir-for-the-first-example][appendix]]. I chose not to write the IR here since the output is a bit long (59 lines).

The resulting LLVM IR creates a string in memory, print it, and free it for the three times. The point is that the resulting code creates 2 copies of the original string. This is because the variable =str= is used for the three times; The content of a variable is copied to create n instances when the variable is used for the n times (n > 1). If the variable isn't used at all (n < 1), the content of the variable is discarded (deallocated). If the variable is used exactly once, or linearly (n = 1), the content of the variable is used without any discarding/copying operation.

The way how a variable is copied is determined by the type of the variable. For example, if the type of a variable is the array type as in the example above, the copying operation is something that you would do in C to copy an array (memory allocation followed by value insertion). If the type is an immediate type like an integer type, the "copying" operation is the one that uses the original value for the cloned value. Every type is translated into a term that copies/discards the terms of the type, including the type of the type itself.

*** Types as Exponentials
Let us go a little deeper. Consider the following schematic user input:
#+BEGIN_SRC txt
let str : string := "a";
<A CODE THAT USES `str` for the 3 times>
#+END_SRC
Intuitively, what the compiler does is to translate the term above into the following term:
#+BEGIN_SRC txt
let str : string := "a";
let (discard-string, copy-string) := TRANSLATE(string);
let (str1, tmp) := copy-string(str);
let (str2, str3) := copy-string(tmp);
<THE CODE THAT USES `str1`, `str2`, AND `str3` LINEARLY>
#+END_SRC
Note that the second line translates the type =string= into a pair =(discard-string, copy-string)=. Every type =X= is translated in this manner; the pair of =discard-X= and =copy-X=. These resource controllers are used in its continuation so that every variable of this type (=str= in this example) is used linearly.

Incidentally, in the actual implementation, the result of =TRANSLATE(string)= is not a pair, but a function as in the pseudo-code below:
#+BEGIN_SRC txt
cartesian-string :: (i : Int, _ : string) -> (if i == 0 then () else string * string)
cartesian-string (i, e) :=
  if i == 0
  then discard-string(e)
  else copy-string(e)
#+END_SRC
which is used in the following manner:
#+BEGIN_SRC txt
let str : string := "a";
let cartesian-string := TRANSLATE(string);
let (str1, tmp) := cartesian-string(1, tmp);
let (str2, str3) := cartesian-string(1, tmp);
<THE CODE THAT USES `str1`, `str2`, AND `str3` LINEARLY>
#+END_SRC
By translating types in this way, we can omit creating tuples every time when we translate a type. Thus, in the actual implementation (you can find it in =src/Clarify.hs=), a type is translated into a closed function, which is represented in 1 word (a pointer to the function).

*** Notes on Polymorphic Functions
Or, you may be wondering now: "What if a function is polymorphic? If the size of an argument of a function is not fixed, how can that function copy the term?"

That is a valid question - And here comes dependent-type. Firstly, note that a polymorphic function in dependent-type theory is nothing but an ordinary function with an argument of type =tau=, where =tau= is the type of types. For example, the following is a polymorphic function that creates a pair of any type:
#+BEGIN_SRC neut
(define to-tuple ((a tau) (x a))
  (tuple x x))
#+END_SRC
This function =to-tuple= is, for example, used as follows:
#+BEGIN_SRC neut
(to-tuple i64 1)          ; ~> (tuple 1 1)
(to-tuple bool bool.true) ; ~> (tuple bool.true bool.true)
(to-tuple string "a")     ; ~> (tuple "a" "a")
#+END_SRC
Note that the type =i64= is used in exactly the same way as =1=; A type is nothing but an ordinary term of type =tau=. And these very type-terms =i64=, =bool=, and =string= in the example above are translated into ordinary closed functions that copies/discards terms of the type. Thus, the =to-tuple= function can copy the resource =x= of type =a= conceptually as follows:
#+BEGIN_SRC text
to-tuple :: Pi (a : tau, x : a). a * a
to-tuple a x :=
  let (discard-a, copy-a) := a in
  let (x1, x2) := copy-a(x) in
  (tuple x1 x2)
#+END_SRC
Thus the answer to the question is: Polymorphic functions can copy/discard its polymorphic argument since the type, which is guaranteed to be passed as an argument, contains information on how to copy/discard the terms of the type.

*** Summary
- A variable is copied/discarded so that the variable is used linearly
- A type is lowered into a function pointer that copies/discards the terms of the type
- Polymorphic function can copy resources thanks to the information provided by its type argument

This is the basics of the behavior of proof-theoretic memory management. As you might already be aware, this naive copying/discarding might result in an inefficient object code. We often use a variable more than once, as in the example of =str=. We can't say that code of =str= is efficient enough; We can't ignore those redundant copy operations.

Thankfully, there is a workaround for this performance problem.

** Manual Optimization via Borrowing
The point of the workaround is straightforward: If those copying/discarding result from using variables in non-linear way, we just have to use those variables in linear way. Let's go back to the first example code:
#+BEGIN_SRC neut
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/archive/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (string.print str))
#+END_SRC
We would like to use the variable =str= in linear way. To this end, we just have to request =string.print= to include the argument =str= in its return value. So, the type of =string.print= shouldn't be something like =string -> top= - where the =top= is the unit type - but should be =string -> top * string=, where the =A * B= means the product type of =A= and =B=. More specifically, the implementation of =string.print= should be something like (in pseudo-code):
#+BEGIN_SRC text
string.print :: string -> top * string
string.print str = do
  {print the string `str` without consuming it}
  return (unit, str)
#+END_SRC
With that definition of =string.print=, we can use the variable =str= linearly (again, in pseudo-code):
#+BEGIN_SRC text
let str1 = "a";
let (_, str2) := string.print str1;
let (_, str3) := string.print str2;
let (_, str4) := string.print str3;
unit
#+END_SRC
Note that the variables =str1=, =str2=, and =str3= are used exactly once, and =str4= for the 0 time. Therefore, the copying operation doesn't occur in the code above. Also, since the =str4= is defined but not used, the =str4= is discarded immediately after its definition.

Now we have seen that those redundant copying/discarding can be avoided by writing the code in the manner above. There still remains a problem: code cluttering. It would be much nicer to have more sophisticated notation of that code pattern. Towards that end, firstly note that we can use the same name for the variables =str1=, =str2=, =str3=, and =str4= thanks to variable shadowing:
#+BEGIN_SRC text
let str = "a";
let (_, str) := string.print str;
let (_, str) := string.print str;
let (_, str) := string.print str;
unit
#+END_SRC
Now, we just have to introduce a notation that translates:
#+BEGIN_SRC text
let foo := string.print &str;
#+END_SRC
into:
#+BEGIN_SRC text
let (foo, str) := string.print str;
#+END_SRC

With this notation, our running example is rewritten as follows:
#+BEGIN_SRC text
let str = "a";
let _ := string.print &str;
let _ := string.print &str;
let _ := string.print &str;
unit
#+END_SRC

And this is the notation that is implemented in Neut. Indeed, the following is a valid code of Neut:
#+BEGIN_SRC neut
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/archive/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print &str))
  (let _ (string.print &str))
  (let _ (string.print &str))
  top.unit) ;; ~> top.unit
#+END_SRC
Or,
#+BEGIN_SRC neut
(ensure core/0.1.0.0
  "https://github.com/u2zv1wx/neut-core/archive/0.1.0.0.tar.gz")

(include "core/0.1.0.0/core.neut")

(with identity.bind
  (let str "a")
  (let _ (string.print &str))
  (let _ (string.print &str))
  (string.print str)) ;; ~> (unit, "a")
#+END_SRC
This notation is "borrowing" in Neut. Note that borrowing in Neut is nothing but a syntactic translation. Borrowing has nothing to do with, for example, the type system, or the operational semantics, of Neut. Indeed, this syntactic translation is processed at the stage of parsing.

Let's see how the resulting LLVM IR changes. Is it faster now? We can compile the code above by running =$ neut build --no-alloc-cancellation --emit llvm filename.neut=. The output is schematically as follows:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout for the three times>
  ;; <memory deallocation for the string>
  ;; <return 0>
}
#+END_SRC
Again, the non-schematic output can be found in the [[#llvm-ir-for-the-second-example][appendix]]. The output in this time is actually short enough to include it here (36 lines including comments), though I chose not to. The point here is that the string "a" is reused without copying, as expected.

 The resulting assembly code is reasonably small too (works on macOS; when you compile the same code on Linux, =write= operations are lowered into syscalls):
#+BEGIN_SRC asm
	.section	__TEXT,__text,regular,pure_instructions
	.macosx_version_min 12, 15
	.globl	_main                   ## -- Begin function main
	.p2align	4, 0x90
_main:                                  ## @main
	.cfi_startproc
## %bb.0:
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset %rbx, -15
	movl	$1, %edi                 # 1-byte memory allocation (you can ignore the lines above this line)
	callq	_malloc
	movq	%rax, %rbx
	movb	$97, (%rax)              # write 'a' (= 97) to the allocated memory
	movl	$1, %edi                 # set the arguments for `_write`
	movl	$1, %edx
	movq	%rax, %rsi
	callq	_write                   # ... and call `_write` (i.e. print 'a')
	movl	$1, %edi                 # (repeat)
	movl	$1, %edx
	movq	%rbx, %rsi
	callq	_write
	movl	$1, %edi                 # (repeat)
	movl	$1, %edx
	movq	%rbx, %rsi
	callq	_write
	movq	%rbx, %rdi               # free the allocated memory
	callq	_free
	xorl	%eax, %eax
	popq	%rbx
	retq
	.cfi_endproc
                                        ## -- End function
.subsections_via_symbols
#+END_SRC
In short: the resulting code is faster in that it is free from the redundant copying operations we saw in the first example.

This is how Neut controls resources efficiently, without modifying the type system of the source language.

** Automatic Optimization via malloc/free Cancellation
Neut's static, proof-theoretic memory management enables not only the "manual" optimization we have just seen, but also another "automatic" optimization. Remember the first example:
#+BEGIN_SRC neut
(with identity.bind
  (let str "a")
  (let _ (string.print str))
  (let _ (string.print str))
  (let _ (string.print str))
  (i64 0))
#+END_SRC
and the output IR of this example code:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; Repeat the following for the 3 times:
  ;;   <memory allocation for the string>
  ;;   <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;;   <write the string into stdout>
  ;;   <memory deallocation for the string>
}
#+END_SRC
The code is already judged to be inefficient in that it allocates/deallocates memory unnecessarily. More specifically, it is inefficient in that it deallocates the memory that can actually be reused.

But, if the sizes of memory being allocated/deallocated are known at compile-time, isn't it possible to compare the sizes of them in compile-time and emit a code that reuses the allocated memory?

And it is indeed possible. When the option =--no-alloc-cancellation= is not passed, the compiler translates code pieces something like this:
#+BEGIN_SRC llvm
define TYPE @FUNCTION_NAME(...) {
  (...)
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>    -- (*1)
  ;; <memory allocation for the string>      -- (*2)
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>
  (...)
}
#+END_SRC
into something like this:
#+BEGIN_SRC llvm
define TYPE @FUNCTION_NAME(...) {
  (...)
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>
  (...)
}
#+END_SRC
In other words, the compiler can cancel the memory deallocation at =(*1)= and the allocation at =(*2)=, reusing the allocated memory in its continuation. This is automatic malloc/free cancellation. By this fallback optimization, the compiler can emit somewhat performant code even if a user wrote code in an inefficient way.

Note that the "create the string" parts are not optimized away from the resulting LLVM IR, in contrast to the one of borrowing:
#+BEGIN_SRC llvm
define i64 @main() {
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout>
  ;; <write the string into stdout>
  ;; <write the string into stdout>
  ;; <memory deallocation for the string>
  ;; <return 0>
}
#+END_SRC
Although the compiler can cancel memory allocations/deallocations, it cannot cancel their accompanying initialization processes (at least for now). If you do need performance, you need to write code in the linear/borrowing style.

** Summary
- Neut statically determines malloc/free at compile-time via type information.
- The content of a variable is
  - discarded if and only if the variable isn't used at all.
  - untouched if and only if the variable is used exactly once (i.e. used linearly).
  - copied if and only if the variable is used more than once.
- Linearity tends to result in an efficient code.
- Non-linearity tends to result in an inefficient code.
- Borrowing can be used as a convenient syntactic tool when accomplishing linearity.
- Redundant malloc/free can be reduced by automatic malloc/free cancellation.
- Borrowing-based, or "manually" optimized code is faster than cancellation-based, or "automatically" optimized code.

* Installation
The currently supported platforms are: Linux (x64), macOS (x64).

Make sure you have already installed [[https://docs.haskellstack.org/en/stable/README/][stack]] and [[https://clang.llvm.org/][clang]]. Then, clone the repository and build it:
#+BEGIN_SRC shell
$ git clone https://github.com/u2zv1wx/neut
$ cd neut
$ ./install.sh 0.1.0.0
#+END_SRC
Also make sure that you have =~/.local/bin= in your =$PATH=.

To uninstall, you just have to remove =~/.local/bin/neut= and =~/.local/share/neut=; Neut won't clutter your system.

* Syntax and Semantics of Statements
A program of Neut is a list of statements. Each statement is one of the following statements described in this section.

# Every example in this section is a valid program in itself. You can [[#build][build]] and run the code to check the behavior.

** constant
The =constant= statement declares an external constant.

*** Example
#+BEGIN_SRC neut
(constant os.file-descriptor tau)

(constant os.stdin os.file-descriptor)

(constant os.fork (pi () i64))
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(constant ID TERM)
#+END_SRC
*** Semantics
When evaluated, the =(constant x t)= statement modifies the state of the compiler so that a [[#constant][constant]] =x= of type =t= is available for later use. Declared constants can then be available for use as in the same way of ordinary [[#upsilon][variables]]. Every constant must have distinct names. This statement is currently intended for internal use, such as for implementation of syscalls. External constants (FFI) might also be supported in future release via this statement.

** ensure
The =ensure= statement fetches the content of the specified URL for later use.

*** Example
#+BEGIN_SRC neut
;; extracts the content of URL into ~/.local/share/neut/NEUT_VERSION/library/some-library/0.2.0.0
(ensure some-library/0.2.0.0
  "https://example.com/some-library-0.2.0.0.tar.gz")

(include library "some-library/0.2.0.0/some-file.neut")
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(ensure ID "URL_OF_LIBRARY")
#+END_SRC
*** Semantics
When parsed, the =(ensure path "URL")= statement fetches the content of the specified URL, extracts the content into =~/.local/share/neut/NEUT_VERSION/path=, assuming that the format of the archive is =tar.gz=. The =path= must be a valid path string. Every path separator in =path= is treated as "real" one. For example, if the =path= is =some-library/0.2.0.0=, the content of the archive is extracted into =~/.local/share/neut/NEUT_VERSION/some-library/0.2.0.0=. Incidentally, this means that users can choose where to install third-party libraries.

If the target directory of archive extraction already exists, the =ensure= statement does nothing.

This statement is intended to be used in harmony with the [[#include][include]] statement.

Archives specified in =(ensure path "URL")= is intended to be ones created via the [[#archive][archive]] subcommand.

** enum
The =enum= statement declares a new enum-type and its values.
*** Example
#+BEGIN_SRC neut
(enum choice left right) ;; defines choice : tau, choice.left : choice, and choice.right : choice

(let x choice.left)

(i64.print
  (enum-elimination x
    (choice.left
      (i64 1))
     choice.right
      (i64 2))) ;; ~> 1

(i64.print (unsafe.cast choice i64 choice.left)) ;; ~> 0

(i64.print (unsafe.cast choice i64 choice.right)) ;; ~> 1

(enum foo
  (a 100)
  b
  (c 20)
  d
  e
  (f 103))

(i64.print (unsafe.cast foo i64 foo.a)) ;; ~> 100
(i64.print (unsafe.cast foo i64 foo.b)) ;; ~> 101
(i64.print (unsafe.cast foo i64 foo.c)) ;; ~> 20
(i64.print (unsafe.cast foo i64 foo.d)) ;; ~> 21
(i64.print (unsafe.cast foo i64 foo.e)) ;; ~> 22
(i64.print (unsafe.cast foo i64 foo.f)) ;; ~> 103
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(enum ID ID_INT ... ID_INT)

ID_INT := ID | (ID INT)
#+END_SRC
*** Semantics
When parsed, a =(enum x a1 ... an)= statement updates the state of the compiler so that the specified enum-type =x : tau= and the enum-values =x.a1, ..., x.an : x= can be used in the succeeding code.

Every enum-value has its internal i64 value (discriminant). Those discriminant value can be extracted by using the unsafe cast, though not recommended in ordinary use.

Discriminant value starts from =0= by default, and increments one by one. The "current" value of this process can be modified by writing, e.g. =(enum foo a (b 100) c d)=. In this example, the discriminant value of =c= is defined to be =101=.

The discriminant values of an enum-type must be distinct.

** include
The =include= statement temporary transfers the parsing process to the file specified by given path, if necessary.
*** Example
#+BEGIN_SRC neut
(include "core/free.neut")

(include "some-library/some-file.neut")

(include "./relative/path/from/the/dir/path/of/this/file.neut")
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(include "PATH_TO_FILE")

(include library "PATH_TO_FILE")
#+END_SRC
*** Semantics
When parsed, the =(include path)= statement transfers current parsing process to the parsing process of the file specified by the =path=. After the transferred parsing process is finished, the suspended remaining parsing process is resumed.

The path is interpreted as a relative one, and is calculated using the current file's directory as the base path if the first character of the path is dot ("."). Otherwise, the base path of this path calculation is set to be the library path of Neut (i.e. =~/.local/share/neut/NEUT_VERSION/library=).

If the file at the =path= is already included, this statement does nothing.

When including a file, both [[#useunuse][the prefix environment]] and [[#sectionend][the section environment]] must be empty.

Cyclic inclusion is invalid.

** inductive
The =inductive= statement defines an inductive type, its introduction rules (constructors), and its elimination rule (fold).
*** Example
#+BEGIN_SRC neut
(inductive nat ()
  (zero () (nat))
  (succ (_ (nat)) (nat)))

(inductive list ((a tau))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))

(define length
  ((a tau)
   (xs (list a)))
  (case xs
    ((list.nil)
      0)
    ((list.cons _ ys)
      (add-i64 1 (length a ys)))))

(let (xs (list i64)) (list.cons 10 (list.cons 20 (list.nil))))

(i64.print (length xs)) ;; ~> 2
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(inductive LEAF ((LEAF TREE) ... (LEAF TREE))
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE)
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    TREE))

;; n-mutual inductive type
(inductive
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE))
  ...
  (LEAF ((LEAF TREE) ... (LEAF TREE))
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)
    ...
    (LEAF ((LEAF TREE) ... (LEAF TREE))
      TREE)))
#+END_SRC
*** Semantics
When parsed, the =inductive= statement is translated into =let= statements that defines (1) the inductive type, (2) the introduction rules (or the constructors of the inductive type), and (3) the elimination rule (or the "fold" of the type). For example, consider the following =inductive= statement:
#+BEGIN_SRC neut
(inductive list ((a tau))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))
#+END_SRC
Given this statement, the compiler generates [[#definelet][let]] statements that defines the followings:
1. The inductive type =list : Pi (a : tau). tau=
2. The introduction rules (constructors) of the type:
   - =list.nil : Pi (a : tau). list a=
   - =list.cons : Pi (a : tau, _ : a, _ : list a). list a=
3. The elimination rule of the type:
   - =list.fold : (Π ((a tau) (_ (list a)) (list (arrow (tau) tau)) (_ (arrow () (F a))) (_ (arrow (a (F a)) (F a)))) (F a))=
The elimination rule might seem intimidating. In the actual code, however, you don't have to use that generated term since the rule [[#case][case]] can be used in harmony with the rule [[#fix][fix]] to achieve the expressiveness of =fold=, as in the function =length= in the example code above.

When used in the domain of a constructor, the inductive type being defined must be occurred covariantly.

The codomain of each constructor must be of the form =(a e1 ... en)=, where the =a= is the inductive type being defined. If =e1, ..., en= are not the same as the argument of the inductive type, such a constructor is defined to be generalized. An inductive type with at least one generalized constructor is defined to be generalized.

Nested inductive type is allowed if and only if the outer, already-defined inductive type is neither mutual nor generalized.

** introspect
The =introspect= statement introspects the state of the compiler and selects statements by those information.
*** Example
#+BEGIN_SRC neut
(introspect OS
  (linux
    (include library "constant/linux.neut"))
  (darwin
    (include library "constant/darwin.neut")))
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(introspect COMPILE_TIME_VAR (ID STATEMENT ... STATEMENT) ... (ID STATEMENT ... STATEMENT))
#+END_SRC
*** Semantics
When parsed, the =(introspect var (v1 stmt-list-1) ... (vn stmt-list-n))= statement introspects the value of the compile-time variable =var= and select a list of statement according to it.

If the corresponding value is not found in the clause list, this statement does nothing.

The =var= must be a valid compile-time variable. Valid compile-time variables and its possible values currently available are as in the table below:

| compile-time variable | possible values |
|-----------------------+-----------------|
| OS                    | linux, darwin   |
| architecture          | x64             |

** notation
The =notation= statement registers a notation.
*** Example
#+BEGIN_SRC neut
(notation λ pi-introduction)

(notation (if b e1 e2)
  (enum-elimination b
    (bool.true e1)
    (bool.false e2)))
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(notation TREE TREE)
#+END_SRC
*** Semantics
When parsed, the statement =(notation FROM TO)= modifies the state of the compiler so that the mapping =FROM ~> TO= is recognized as a notation. This affects the result of macro expansion in the succeeding code.

# See [[#macroexpansion][the section on macro expansion]] for the details of keywords and notations.

*** Notes on Macro Expansion
Every source code of Neut is firstly translated into the corresponding trees that is conceptually defined as follows:
#+BEGIN_SRC text
tree ::= leaf STRING | node (LIST tree)
#+END_SRC
After this translation, the resulting ASTs are *macro-expanded*, and then interpreted as, for example, statements by the compiler. Here I will explain how this macro-expansion works.

In short, the macro-expansion of an AST in Neut is a call-by-value-like recursive application of the *step-expansion*.

I believe the step-expansion process is best explained by an example. Consider we have defined a notation as follows:
#+BEGIN_SRC text
(notation (if b e1 e2)
  (switch b
    (bool.true e1)
    (bool.false e2)))
#+END_SRC
Now, suppose we have an AST =(if some-condition (i64.print 10) (string.print "hello"))=. The compiler then creates the following substitution:
#+BEGIN_SRC text
b  ~> some-condition
e1 ~> (i64.print 10)
e2 ~> (string.print "hello")
#+END_SRC
and then replaces =b=, =e1=, and =e2= in the codomain of the notation according to this substitution. The resulting tree is:
#+BEGIN_SRC text
(switch some-condition
  (bool.true (i64.print 10))
  (bool.false (string.print "hello")))
#+END_SRC
# This translation is the step-expansion. The keyword environment here is required to determine whether a leaf of the domain of a notation is a variable or an opaque syntactic construct (i.e. "keyword"). In the example above, without the =(keyword if)= statement, we cannot determine if the =if= in =(if b e1 e2)= is a variable or a keyword.

Given this step-expansion, the macro-expansion proceeds as follows. Take =t= to be an input tree. If the tree =t= is of the form =(leaf STRING)=, the compiler returns the result of step-expansion of =t=. If a tree is of the form =(node t1 ... tn)=, the =t1=, ..., =tn= are firstly macro-expanded them into =t1'= , ..., =tn'= , and then the compiler step-expands the tree =(node t1' ... tn')=.

** let
The =let= statement evaluates given term and binds the result to a variable.

*** Example
#+BEGIN_SRC neut
(let foo (i64 10)) ;; define a variable `foo` to be `10`

(i64.print foo) ;; ~> 10 (this is equivalent to `(let _ (i64.print foo))`)

(let (bar i64) 20) ;; `let` with type annotation

(i64.print bar) ;; ~> 20

;; `define` is defined in `core/notation.neut` as follows:
;;
;; (keyword define)
;;
;; (notation (define f xts e)
;;   (let f (fix f xts e)))
;;
;; (notation (define f e)
;;   (let f e))
;;

;; ordinary definition (i.e. 1-mutual definition)
(define fact ((x i64))
  (if (icmp-sle-i64 x 0) ;; compare (by less-than-or-equal) two `i64`s as signed integers
    1
    (mul-i64 x (fact (sub-i64 x 1))))) ;; the self-referential variable "fact" is available in its function body

(i64.print (fact foo)) ;; ~> 3628800 (= 10!)

;; the definition of `fact` above is equivalent to the following:
(let fact
  (fix fact ((x i64))
    (if (icmp-sle-i64 x 0)
      1
      (mul-i64 x (fact (sub-i64 x 1))))))
;; which is alpha-equivalent to:
(let fact
  (fix self ((x i64))
    (if (icmp-sle-i64 x 0)
      1
      (mul-i64 x (self (sub-i64 x 1))))))

;; mutual recursion can be realized as in the ordinary way:
(define even-f ((f (hom i64 bool)) (n i64))
  (if (icmp-eq-i64 n 0)
    true
    (f (sub-i64 n 1))))

(define odd ((n i64))
  (if (icmp-eq-i64 n 0)
    false
    (even-f odd (sub-i64 n 1))))

(define even ((n i64))
  (even-f odd n))

(i64.print
  (if (even 10)
    100
    1000)) ;; ~> 100
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(let (ID TERM) TERM)

(let ID TERM)
#+END_SRC
*** Semantics
When parsed, the =(let x e)= statement does nothing.

When evaluated, the =(let x e)= statement checks the type of the term =e=, evaluates the term =e=, then defines a variable =x= with =e= as its content. =x= is available in the remaining program. The type of =x= can be specified to be =t= by writing =(let (x t) e)=.

If user input is not parsed as a statement when it is supposed to be, the compiler firstly interpret it as a term =e=, and then processes a statement =(let _ e)=.

** record
The =record= statement creates a record type, its elimination rules (destructors), and its introduction rule.
*** Example
#+BEGIN_SRC neut
(record my-record ((a tau))
  (item-1
    a)
  (item-2
    i64)
  (item-3
    top))

(let item
  (my-record.new
    i64
    10
    20
    top.unit))

(i64.print (my-record.item-1 i64 item)) ;; ~> 10

(i64.print (my-record.item-2 i64 item)) ;; ~> 20
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(inductive LEAF ((LEAF TREE) ... (LEAF TREE))
  (LEAF TREE)
  ...
  (LEAF TREE))
#+END_SRC
*** Semantics
When parsed, the =record= statement is translated into =let= statements that defines (1) the record type, (2) the elimination rules (or the destructors of the record type), and (3) the introduction rule. For example, consider the following =record= statement:
#+BEGIN_SRC neut
(record my-record ((a tau))
  (item-1
    a)
  (item-2
    i64)
  (item-3
    top))
#+END_SRC
Given this statement, the compiler generates [[#definelet][let]] statements that defines the followings:
1. The record type =my-record : Pi (a : tau). tau=
2. The elimination rules (destructors) of the type:
   - =my-record.item-1 : Pi (a : tau, _ : (my-record a)). a=
   - =my-record.item-2 : Pi (a : tau, _ : (my-record a)). i64=
   - =my-record.item-3 : Pi (a : tau, _ : (my-record a)). top=
3. The introduction rule of the type:
   - =my-record.new : (Π ((a tau) (_ a) (_ i64) (_ top)) (my-record a))=

Internally, every record statement is translated into the corresponding [[#inductive][inductive]] statement. For example, given the =record= statement above, the compiler translates it into the following =inductive= statement:
#+BEGIN_SRC neut
(inductive my-record ((a tau))
  (new
    ((item-1 a)
     (item-2 i64)
     (item-3 top))
    (my-record a)))
#+END_SRC
The compiler then processes this statement in the same way ordinary =inductive= statement, generating the record type =my-record= and the introduction rule =my-record.new=, and the elimination rule (as an inductive type) =my-record.fold=. After that, the compiler automatically generates destructors from this definition via =my-record.fold=. For example, the generated definition of =my-record.item-1= is as follows:
#+BEGIN_SRC neut
(define my-record.item-1 ((a tau) (record-value (my-record a)))
  (my-record.fold a record-value
    (lambda () a)
    (lambda (item-1 item-2 item3) item-1)))
#+END_SRC
The other destructors are defined similarly.

** use/unuse
The =use= / =unuse= statement registers a prefix for name resolution.
*** Example
#+BEGIN_SRC neut
(let foo.bar.buz (i64 10))

;; (i64.print buz)      ;; ~> undefined variable: `buz`
;; (i64.print bar.buz)  ;; ~> undefined variable: `bar.buz`
(i64.print foo.bar.buz) ;; ~> 10

(use foo)

;; (i64.print buz)      ;; ~> undefined variable: `buz`
(i64.print bar.buz)     ;; ~> 10
(i64.print foo.bar.buz) ;; ~> 10

(use foo.bar)

(i64.print buz)         ;; ~> 10
(i64.print bar.buz)     ;; ~> 10
(i64.print foo.bar.buz) ;; ~> 10

(unuse foo)

(i64.print buz)         ;; ~> 10
;; (i64.print bar.buz)  ;; ~> undefined variable: `bar.buz`
(i64.print foo.bar.buz) ;; ~> 10
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(use LEAF)

(unuse LEAF)
#+END_SRC
*** Semantics
When parsed, the statement =(use PREFIX)= inserts =PREFIX= at the head of the prefix environment, which is a list of prefixes.

When parsed, the statement =(unuse PREFIX)= removes =PREFIX= from the prefix environment. If the =PREFIX= is not contained in the environment, the =unuse= statement does nothing.

The prefix environment modifies [[#upsilon][how the compiler parses a variable]].

** section/end
*** Example
#+BEGIN_SRC neut
(section pohe)

(let foo (i64 10))

(section qux)

(let bar (i64 20))

(i64.print foo)          ;; ~> 10
(i64.print pohe.foo)     ;; ~> 10
(i64.print bar)          ;; ~> 20
(i64.print qux.bar)      ;; ~> 20
(i64.print pohe.qux.bar) ;; ~> 20

(end qux)

(i64.print foo)          ;; ~> 10
(i64.print pohe.foo)     ;; ~> 10
;; (i64.print bar)       ;; ~> undefined variable: `bar`
(i64.print qux.bar)      ;; ~> 20
(i64.print pohe.qux.bar) ;; ~> 20

(end pohe)

;; (i64.print foo)       ;; ~> undefined variable: `foo`
(i64.print pohe.foo)     ;; ~> 10
;; (i64.print bar)       ;; ~> undefined variable: `bar`
;; (i64.print qux.bar)   ;; ~> undefined variable: `qux.bar`
(i64.print pohe.qux.bar) ;; ~> 20
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(section LEAF)

(end LEAF)
#+END_SRC
*** Semantics
The list of statement
#+BEGIN_SRC neut
(section FOO)
(let x1 e1)
...
(let xn en)
(end FOO)
#+END_SRC
is equivalent to:
#+BEGIN_SRC neut
(use FOO)
(let FOO.x1 e1)
...
(let FOO.xn en)
(unuse FOO)
#+END_SRC
In other words, the =section= / =end= statement
- insert the [[#useunuse][use/unuse]] statements at the beginning and the end of the section
- add the name of the section as a prefix of the variables defined by =let= / =define= statements
- keep all the other statements in the section untouched

Each =section= statement must be paired with an =end= statement with the corresponding name.

* Syntax and Semantics of Terms
A term of Neut is a tree of inference rules. Each rule is one of the following rules described in this section.
 # Each statement is one of the following statements described in this section.

** tau
The =tau= term is the type of types.
*** Example
#+BEGIN_SRC neut
(define id ((a tau) (x a)) x)

(id i64 10)

(id tau tau) ;; valid since `tau : tau`
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
tau
#+END_SRC
*** Semantics
The =tau= rule doesn't have any operational semantics.

*** Notes
The =tau= type is the type of types. In other words, a term =e= is defined to be a type if and only if =e : tau=. Obviously, =tau= is also a type since =tau : tau= holds.

The universe hierarchy is intentionally removed from the source language since the source language already contains the =fix= operator.
# The universe hierarchy is intentionally removed from the source language since (1) the source language already contains the =fix= operator, and (2) we can check if a term is subsumed in the weakly-normalizing fragment of the type system, which is consistent, by using the [[#verify][verify]] statement.

** upsilon
The =upsilion= term is a term that represents a variable.
*** Example
#+BEGIN_SRC neut
(let x (i64 10))

;; "explicit" notation
(i64.print (upsilon x)) ;; ~> 10

;; "implicit" notation
(i64.print x)           ;; ~> 10
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(upsilon LEAF)
LEAF
#+END_SRC
*** Semantics
The =upsilon= rule doesn't have any operational semantics.

*** Notes
The =upsilon= term can be interpreted as a variable.

If a leaf is not parsed into any other syntactic construct, the leaf is considered to be wrapped by =upsilon=.

If the name of a variable is "_", the compiler automatically generates a fresh variable so that the variable cannot be referred in the succeeding code.

** pi
The =pi= term is a term that represents the universal quantification.
*** Example
#+BEGIN_SRC neut
;; unary pi-introduction
(let (f2 (pi (x i64) i64))  ;; f2 : Pi (x : i64). i64  (i.e. f2 receives a term of type i64, and returns a term of type i64)
  (pi-introduction ((x i64)) x))

;; "explicit" pi-elimination
(pi-elimination i64.print (pi-elimination f2 2))

;; "automatic" pi-elimination
(i64.print (f2 2))

;; nullary pi-introduction
(let (f1 (pi () i64))
  (lambda () (i64 1))) ;; 'lambda' can be used instead of 'pi-introduction'

;; "explicit" pi-elimination
(pi-elimination i64.print (pi-elimination f1))

;; "automatic" pi-elimination
(i64.print (f1))

;; binary pi-introduction
(let f3
  (lambda ((x i64) (y i64)) (i64.add x y)))

(i64.print (f3 1 2))
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(pi ((x1 A1) ... (xn An)) B)
(pi-introduction ((x1 A1) ... (xn An)) e)
(pi-elimination e e1 ... en)
(e e1 ... en)
#+END_SRC
*** Semantics
#+BEGIN_SRC neut
(pi-elimination e e1 ... en)
~> (pi-elimination v v1 ... vn)  [i.e. reduce e and ei to values v and vi, from left to right]

(pi-elimination (pi-introduction ((x1 A1) ... (xn An)) e) v1 ... vn)
~> e {x1 := v1,
      ...,
      xn := vn}
#+END_SRC
*** Notes
If a tree =(e e1 ... en)= is not parsed into any other terms, the tree is parsed as =(pi-elimination e e1 ... en)=.

Note that the arguments of a lambda abstraction is generalized from unary to n-ary. This enables the compiler to emit more performant code when a lambda abstraction receives multiple arguments; Without that generalization, the argument must be represented as a tuple, discarding the possibility to pass the arguments of a function using multiple registers.

Some additional notations for pi are defined by default:
#+BEGIN_SRC neut
(keyword forall)

(notation forall pi)

(keyword Π)

(notation Π pi)

(keyword lambda)

(notation lambda pi-introduction)

(keyword λ)

(notation λ pi-introduction)

(keyword witness)

(notation (witness t e)
  ((lambda ((x t)) x) e))

(keyword hom)

(notation (hom t) t)

(notation (hom t rest+)
  (pi
    ((_ t))
    (hom rest+)))
#+END_SRC
These are in =core/notation.neut=.

Incidentally, I personally recommend you to use the =witness= notation above when defining a function to write the resulting type of the function explicitly. For example, the code
#+BEGIN_SRC neut
(define fact ((x i64))
  (witness i64
    (if (icmp-sle-i64 x 0)
      1
      (mul-i64 x (fact (sub-i64 x 1))))))
#+END_SRC
is preferred to:
#+BEGIN_SRC neut
(define fact ((x i64))
  (if (icmp-sle-i64 x 0)
    1
    (mul-i64 x (fact (sub-i64 x 1)))))
#+END_SRC

** fix
The =fix= term is a term that realizes recursion.
*** Example
#+BEGIN_SRC neut
(let fact
  (fix self ((x i64))
    (if (icmp-sle-i64 x 0) ;; i.e. if x <= 0
      1
      (mul-i64 x (self (sub-i64 x 1))))))
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(fix LEAFPLUS (LEAFPLUS ... LEAFPLUS) TREE)

LEAFPLUS ::= LEAF | (LEAF TREE)
#+END_SRC
*** Semantics
#+BEGIN_SRC neut
(pi-elimination (fix self ((x1 A1) ... (xn An)) e) v1 ... vn)
~> e {x1 := v1,
      ...,
      xn := vn,
      self := (fix self ((x1 A1) ... (xn An)) e)}
#+END_SRC
** constant
The =constant= rule is for external constants. Proof-theoretically, this can be understood as admitted axioms.
*** Example
#+BEGIN_SRC neut
(constant os.fork)
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(constant LEAF)
LEAF
#+END_SRC
*** Semantics
The =constant= rule doesn't have any operational semantics by itself; Each constant has its own dedicated semantics.
*** Notes
If a leaf is declared to be a constant using the [[#constant][constant]] statement, the leaf is parsed as =(constant LEAF)=.

** int
The =int= term is the one that represents the integer type in LLVM.
*** Example
#+BEGIN_SRC neut
(i64 1)
(i32 10)
(i2 100)
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
;; the integer type i{n}
i{n} [where n is one of 1, 2, ..., 64]

;; an integer of type i{n}
(i{n} LEAF)  [where n is one of 1, 2, ..., 64]

;; an integer without explicit type info
LEAF [where this LEAF can be parsed as integer]
#+END_SRC
*** Semantics
The terms of an integer type doesn't have any operational semantics.
*** Notes
The =int= type in Neut is the same as the one of LLVM, restricted into =i1=, =i2=, ..., =i64=.

If the specified integer literal is out of range of its type =i{n}=, the integer is interpreted modulo =2^n=, just as in the same way of LLVM. For example, =(i2 10)= is the same as =(i2 6)=, =(i2 2)=, =(i2 -2)=, or =(i2 -6)=, since all of these are equivalent modulo =2^2=.

An integer without explicit type information is overloaded; it's type is firstly set to be unknown, and then inferred.

** float
The =float= term is the one that represents the float type in LLVM.
*** Example
#+BEGIN_SRC neut
(f16 3.8)
(f32 9.22888)
(f64 1.23456789)
(fadd-f64 1.23456 7.89)
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
;; the float type f{n}
f{n}   [where n is one of 16, 32, 64]

;; a float of type f{n}
(f{n} LEAF) [where n is one of 16, 32, 64]

LEAF [where this LEAF can be parsed as float]
#+END_SRC
*** Semantics
The terms of a float type doesn't have any operational semantics.
*** Notes
The =float= type in Neut is the same as the one of LLVM. Specifically, LLVM's =half= corresponds to Neut's =f16=, =float= to =f32=, and =double= to =f64=.

An float without explicit type information is overloaded; it's type is firstly set to be unknown, and then inferred.

** enum
The =enum= term represents enumeration as in other language.
*** Example
See the example in [[#enum][the section about the enum statement]].
*** Syntax
#+BEGIN_SRC neut
(enum-introduction LEAF)
LEAF [where this LEAF is already defined to be an enum value]
#+END_SRC
*** Semantics
#+BEGIN_SRC neut
(enum-elimination (enum-introduction c)
  (c1 e1)
  ...
  (cn en))
~> ei [where c = ci]
#+END_SRC
** array
The =array= term represents the array in LLVM.
*** Example
#+BEGIN_SRC neut
;; float array
(let _
  (array-introduction f16 3.28 2.14 2.0 9.82))

(let xs
  (array-introduction i64 1 2 -30 20))

(let k
  (with identity.bind
    (let a (i64.array-access 0 4 &xs))
    (let b (i64.array-access 1 4 &xs))
    (let c (i64.array-access 2 4 &xs))
    (let d (i64.array-access 3 4 &xs))
    (erase xs)
    (i64.add a (i64.add b (i64.add c d)))))

(i64.print k) ;; -7

(i64.print
  (array-elimination i64 (a b c d) xs
    (i64.add a (i64.add b (i64.add c d))))) ;; -7
#+END_SRC
*** Syntax
#+BEGIN_SRC text
;; the array type
(array TREE LOWTYPE)

(array-introduction LOWTYPE TREE ... TREE)

(array-elimination LOWTYPE (LEAFPLUS ... LEAFPLUS) TREE TREE)

LOWTYPE ::= i{n} | f{n}

LEAFPLUS ::= LEAF | (LEAF TREE)
#+END_SRC
*** Semantics
#+BEGIN_SRC neut
(array-elimination _ (x1 ... xn) (array-introduction _ e1 ... en) e)
~> e {x1 := e1,
      ...,
      xn := en}
#+END_SRC
*** Notes
The type of elements of an array must be the integer type, or the float type.

The memory layout of an array is the same as the one of LLVM; For example, an array of type =i8= is aligned as in the array =[0 x i8]= in LLVM.

The array type can be used, for example, to implement strings.

You won't use =array-elimination= in actual code; You would use the constant =array-access= instead.

** struct
The =array= term represents the struct in LLVM.
*** Example
#+BEGIN_SRC neut
(let st
  (struct-introduction
    (f16 3.8)
    (i8 8)
    (i16 -300)
    (f32 33.0)
    (i64 30)
    (i64 10)
    (f64 -329444.4444444)
    (i8 9)))

(i64.print
  (struct-elimination
    ((_ f16) (_ i8) (_ i16) (_ f32) (z i64) (w i64) (_ f64) (_ i8))
    st
    (i64.add z w))) ;; ~> 40
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
;; the struct type
(struct LOWTYPE ... LOWTYPE)

(struct-introduction (LOWTYPE TREE) ... (LOWTYPE TREE))

(struct-elimination ((LEAF LOWTYPE) ... (LEAF LOWTYPE)) TREE TREE)

LOWTYPE ::= i{n} | f{n}
#+END_SRC
*** Semantics
#+BEGIN_SRC text
(struct-elimination (x1 _) ... (xn _) (struct-introduction (_ e1) ... (_ en)) e)
~> e {x1 := e1,
      ...,
      xn := en}
#+END_SRC
*** Notes
The type of elements of a struct must be the integer type, or the float type.

The memory layout of a struct is the same as the one of LLVM; For example, a struct of type =(struct i8 f16 i32)= is aligned as in a struct of type ={i8, f16, f32}= in LLVM.

The struct type is intended to be used for implementation of interfaces of syscalls.

* Auxiliary Syntax
** hole
The =hole= term is a placeholder that should be inferred.
*** Example
#+BEGIN_SRC neut
(define id ((a tau) (x a)) x)

(enum foo value)

;; explicit application
(id foo foo.value) ;; ~> foo.value

;; implicit application
(id hole foo.value) ;; ~> foo.value (the `hole` part is inferred to be `foo`)
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
hole
#+END_SRC
*** Semantics
The =hole= term doesn't have any operational semantics.
*** Notes
The =hole= term can be used as a placeholder that must be resolved by the compiler using the constraints generated in its type inference procedure.

If the type is not determined, the compiler raises an error; For example, the type of =x= in the following code is not determined:
#+BEGIN_SRC neut
(let x 10)
#+END_SRC
since the =10= cannot be determined to be =i32=, =i16=, or =i64=, etc.

** sigma
The =sigma= term is a term that represents the existential quantification.
*** Example
#+BEGIN_SRC neut
;; binary sigma-intro without dependence
(let pair
  (sigma-introduction (i64 2) (lambda ((x tau)) x)))

;; binary sigma-elim without dependence
(sigma-elimination (x _) pair
  (i64.print x))

(let n-pair
  (sigma-introduction (i64 1) (lambda ((x tau)) x) (f32 10.82) top.unit top.unit top tau))

(let 0-pair
  (sigma-introduction)
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(sigma ((x1 A1) ... (xn An)) B)

(sigma-introduction e1 ... en)

(sigma-elimination (LEAFPLUS ... LEAFPLUS) e1 e2)

LEAFPLUS ::= LEAF | (LEAF TREE)
#+END_SRC
*** Semantics
#+BEGIN_SRC text
(sigma ((x1 A1) ... (xn An)) B)
~> (pi ((Z tau)
        (_ (pi ((x1 A1) ... (xn An) (_ B)) Z)))
       Z))

(sigma-introduction e1 ... en)
~> (pi-introduction
     ((Z tau)
      (k (pi ((x1 hole) ... (xn hole)) Z)))
     (k e1 ... en))

(sigma-elimination ((x1 A1) ... (xn An)) e1 e2)
~> (e1 hole (lambda ((x1 A1) ... (xn An)) e2))
#+END_SRC
*** Notes
The sigma-type is just a convenient notation of certain pattern of use of pi-type; This encoding is the ordinary one in CoC.

Sigma-type with dependence can be used, for example, to realize the type of string as follows:
#+BEGIN_SRC text
(define string
  (sigma ((len i64)) (array len i8)))
#+END_SRC

A sigma-type without dependence is the familiar product type; =(sigma ((_ A1) ... (_ An)) B)= is =(product A1 ... An B)=.

** with
=with= is a do-notation with the bind operation made explicit.
*** Example
#+BEGIN_SRC neut
(with identity.bind
  (let str "foo")
  (let _ (string.print &str))
  (string.print &str) ;; the same as (let _ (string.print &str))
  (let x (i64 10))
  (let y (add-i64 100 x))
  (i64.print y))

(with identity.bind
  (let str "foo")
  (let _
    (let _ (i64 100)) ;; each `e` in `(let x e)` is implicitly wrapped by `with`
    (string.print &str)
    (string.print &str))
  (string.print &str)
  (let len (string.print &str))
  len)
#+END_SRC
*** Syntax
#+BEGIN_SRC neut
(with TREE TREE ... TREE)
#+END_SRC
*** Semantics
#+BEGIN_SRC text
(with bind (let x (e e1 ... en)) rest+)
~> (bind hole hole (with (e e1' ... en'))
     (lambda (sig)
       (sigma-elimination (x1 ... xj) sig (with rest+))))
where:
  ei' := if ei == &x then x else ei
  x1, ..., xj := (all the "borrowed" variables in e1, ..., en)
  sig : a fresh variable

(with bind (let x e) rest+)
~> (bind hole hole (with e)
     (lambda (x) (with rest+)))

(with bind e rest+)
~> (with bind (let _ e) rest+)

(with e)
~> e
#+END_SRC
*** Notes
The =with= notation can be understood as a generalization of =begin= in Scheme, or an explicit version of the =do= notation in Haskell.

The "borrowing" is covered by the first rule of the semantics; As you can see from the definition, this realization of borrowing works for any =bind= operation.

Note that the =bind= operator is not restricted to the monadic bind; You can set any term there as long as the resulting term of this syntactic translation is well-typed.

The =e= in =(let x e)= is automatically surrounded by =with=.

* Compiler Subcommands
The =neut= binary provides subcommands in this section.

** archive
*** Example
#+BEGIN_SRC shell
$ neut archive path/to/some/directory # ~> creates a tar.gz archive `directory.tar.gz`
$ neut archive path/to/some/directory -o pohe # ~> creates a tar.gz archive `pohe`
#+END_SRC
*** Notes
The =archive= subcommand creates a tar.gz archive from the specified directory. The [[#ensure][ensure]] statement expects an archive created by this subcommand.

** build
*** Example
#+BEGIN_SRC shell
$ neut build path/to/file.neut             # create an executable ./file
$ neut build -o output path/to/file.neut   # create an executable ./output
$ neut build --emit llvm path/to/file.neut # create a LLVM IR file ./file.ll
$ neut build --emit asm path/to/file.neut  # create an assembly code ./file.s
#+END_SRC
*** Notes
The =build= subcommand builds given source code and emits resulting code.

** check
*** Example
#+BEGIN_SRC shell
$ neut check path/to/file.neut
$ neut check --no-color path/to/file.neut
$ neut check --end-of-entry EOE path/to/file.neut
#+END_SRC
*** Notes
The =check= subcommand type-checks given file.

If =--no-color= option is specified, the result of type checking is printed without console color.

If =--end-of-entry SEPARATOR= is specified, each entry of the result of type checking is followed by =SEPARATOR=.

This subcommand is intended to be used with an editor-side syntax checker like [[https://www.flycheck.org/en/latest/][flycheck]].

# * Where is ...?

# ** Typeclass?

# ** Proof-Related Stuff?

# ** The Universe Hierarchy?

# * Theoretical Notes

# ** Compile-Time Memory Usage Determination
# (to be written later)

# ** Box Modality, Polarity, and Closure Conversion
# (to be written later)

# ** "Unified" Pattern Resolution in Dependent Type Inference
# (to be written later)

* Appendix

** LLVM IR for the First Example
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; <REPETITION 1>
  ;; <memory allocation for the string>
  %_11875 = getelementptr i8, i8* null, i64 1
  %_11876 = ptrtoint i8* %_11875 to i64
  %_11877 = call fastcc i8* @malloc(i64 %_11876)
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  %_11878 = bitcast i8* %_11877 to [1 x i8]*
  %_11879 = inttoptr i8 97 to i8*
  %_11880 = ptrtoint i8* %_11879 to i8
  %_11881 = getelementptr [1 x i8], [1 x i8]* %_11878, i32 0, i64 0
  store i8 %_11880, i8* %_11881
  ;; <write the string into stdout>
  %_11882 = inttoptr i64 1 to i8*
  %_11883 = inttoptr i64 1 to i8*
  %_11884 = call fastcc i8* @write(i8* %_11882, i8* %_11877, i8* %_11883)
  %_11885 = bitcast i8* %_11877 to [1 x i8]*
  %_11886 = getelementptr [1 x i8], [1 x i8]* %_11885, i32 0, i32 0
  %_11887 = load i8, i8* %_11886
  %_11888 = bitcast [1 x i8]* %_11885 to i8*
  ;; <memory deallocation for the string>
  call fastcc void @free(i8* %_11888)
  %_11889 = inttoptr i8 %_11887 to i8*
  ;; <REPETITION 2>
  ;; <memory allocation for the string>
  %_11890 = getelementptr i8, i8* null, i64 1
  %_11891 = ptrtoint i8* %_11890 to i64
  %_11892 = call fastcc i8* @malloc(i64 %_11891)
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  %_11893 = bitcast i8* %_11892 to [1 x i8]*
  %_11894 = inttoptr i8 97 to i8*
  %_11895 = ptrtoint i8* %_11894 to i8
  %_11896 = getelementptr [1 x i8], [1 x i8]* %_11893, i32 0, i64 0
  store i8 %_11895, i8* %_11896
  ;; <write the string into stdout>
  %_11897 = inttoptr i64 1 to i8*
  %_11898 = inttoptr i64 1 to i8*
  %_11899 = call fastcc i8* @write(i8* %_11897, i8* %_11892, i8* %_11898)
  %_11900 = bitcast i8* %_11892 to [1 x i8]*
  %_11901 = getelementptr [1 x i8], [1 x i8]* %_11900, i32 0, i32 0
  %_11902 = load i8, i8* %_11901
  %_11903 = bitcast [1 x i8]* %_11900 to i8*
  ;; <memory deallocation for the string>
  call fastcc void @free(i8* %_11903)
  %_11904 = inttoptr i8 %_11902 to i8*
  ;; <REPETITION 3>
  ;; <memory allocation for the string>
  %_11905 = getelementptr i8, i8* null, i64 1
  %_11906 = ptrtoint i8* %_11905 to i64
  %_11907 = call fastcc i8* @malloc(i64 %_11906)
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  %_11908 = bitcast i8* %_11907 to [1 x i8]*
  %_11909 = inttoptr i8 97 to i8*
  %_11910 = ptrtoint i8* %_11909 to i8
  %_11911 = getelementptr [1 x i8], [1 x i8]* %_11908, i32 0, i64 0
  store i8 %_11910, i8* %_11911
  ;; <write the string into stdout>
  %_11912 = inttoptr i64 1 to i8*
  %_11913 = inttoptr i64 1 to i8*
  %_11914 = call fastcc i8* @write(i8* %_11912, i8* %_11907, i8* %_11913)
  %_11915 = bitcast i8* %_11907 to [1 x i8]*
  %_11916 = getelementptr [1 x i8], [1 x i8]* %_11915, i32 0, i32 0
  %_11917 = load i8, i8* %_11916
  %_11918 = bitcast [1 x i8]* %_11915 to i8*
  ;; <memory deallocation for the string>
  call fastcc void @free(i8* %_11918)
  %_11919 = inttoptr i8 %_11917 to i8*
  ;; <return 0>
  %_11920 = inttoptr i64 0 to i8*
  %_11921 = ptrtoint i8* %_11920 to i64
  ret i64 %_11921
}
#+END_SRC

** LLVM IR for the Second Example
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; memory allocation
  %_12034 = getelementptr i8, i8* null, i64 1
  %_12035 = ptrtoint i8* %_12034 to i64
  %_12036 = call fastcc i8* @malloc(i64 %_12035)
  ;; create the string "a" (i.e. write the character 'a' to the allocated memory)
  %_12037 = bitcast i8* %_12036 to [1 x i8]*
  %_12038 = inttoptr i8 97 to i8* ;; a = 97
  %_12039 = ptrtoint i8* %_12038 to i8
  %_12040 = getelementptr [1 x i8], [1 x i8]* %_12037, i32 0, i64 0 ;; where to write 'a'
  store i8 %_12039, i8* %_12040 ;; write a
  ;; write the string into stdout for the three times
  %_12041 = inttoptr i64 1 to i8* ;; this `1` stands for stdout
  %_12042 = inttoptr i64 1 to i8* ;; this `1` is the length of the string in bytes
  %_12043 = call fastcc i8* @write(i8* %_12041, i8* %_12036, i8* %_12042)
  %_12044 = inttoptr i64 1 to i8*
  %_12045 = inttoptr i64 1 to i8*
  %_12046 = call fastcc i8* @write(i8* %_12044, i8* %_12036, i8* %_12045)
  %_12047 = inttoptr i64 1 to i8*
  %_12048 = inttoptr i64 1 to i8*
  %_12049 = call fastcc i8* @write(i8* %_12047, i8* %_12036, i8* %_12048)
  ;; memory deallocation
  %_12050 = bitcast i8* %_12036 to [1 x i8]*
  %_12051 = getelementptr [1 x i8], [1 x i8]* %_12050, i32 0, i32 0
  %_12052 = load i8, i8* %_12051
  %_12053 = bitcast [1 x i8]* %_12050 to i8*
  call fastcc void @free(i8* %_12053)
  %_12054 = inttoptr i8 %_12052 to i8*
  ;; return 0
  %_12055 = inttoptr i64 0 to i8*
  %_12056 = ptrtoint i8* %_12055 to i64
  ret i64 %_12056
}
#+END_SRC
