#+TITLE: Neut
Neut is a dependently-typed programming language based on [[https://en.wikipedia.org/wiki/Calculus_of_constructions][the Calculus of Constructions (CoC)]]. The interesting point I believe is that this language determines how to allocate/free memory at compile-time, without extra annotations to the source language. In other words, Neut in its source language is an ordinary lambda-calculus after all (imagine something like Haskell, Coq, Agda, Lean), and at the same time it handles memory without using:

- explicit malloc/free,
- garbage collection,
- region-based memory management.

Theoretically, this is made possible by translating the source language into a dependent-and-linear variant of [[https://www.cs.bham.ac.uk/~pbl/papers/thesisqmwphd.pdf][Call-by-Push-Value]]. The crucial point of the translation is to see that knowing the type of a term is knowning how to eta-expand the term, which in turn means knowing how to copy/discard the term. In the translation, a type is not erased, but *translated into a computationally-meaningful term that copies/discards the terms of the type*. Those who are interested in these theoretical things can find further details <yet-to-be-written>.

Practically, this means that you can write your program in the ordinary lambda calculus without any extra restrictions/annotations, and at the same time are allowed to pursue performance in the language via e.g. borrowing or linearity. The source code doesn't need esoteric annotations for the compiler to infer how to use resources. Nor does the world stop all of a sudden by GC. You have full control over resource allocation.

Here I briefly summerize the basic characteristics of Neut before diving into the details:

- Neut is a compiled language
- The output of Neut is LLVM IR / assembly / object binary (the last two are via clang)
- The type system is CoC + recursion + int + float + enum + array + struct
- The evaluation strategy is call-by-value
- The memory management is statically determined at compile time (Can be optimized via borrowing and linearity)
- Has inductive/coinductive type (despite the fact that core logic is not CoIC but CoC)
- Every tail call is optimized into a loop

* Table of Contents                                                    :TOC:
- [[#hopefully-illuminating-examples][Hopefully Illuminating Examples]]
  - [[#automatic-memory-management-with-resulting-x64-assembly][Automatic Memory Management (with resulting x64 assembly)]]
  - [[#borrowing-and-its-resulting-assembly][Borrowing (and its resulting assembly)]]
  - [[#memory-reuse-via-linearity][Memory Reuse via Linearity]]
  - [[#hello-world][Hello World]]
  - [[#inductive-type-algebraic-data-type][Inductive type (algebraic data type)]]
  - [[#summary-or-mental-model-of-memory-management-in-neut][Summary, or Mental Model of Memory Management in Neut]]
- [[#installation][Installation]]
- [[#syntax-and-semantics][Syntax and Semantics]]
  - [[#tau][tau]]
  - [[#pi-forall--lambda--apply][Pi (forall / lambda / apply)]]
  - [[#iterate-recursion][Iterate (recursion)]]
  - [[#int][Int]]
  - [[#float][Float]]
  - [[#enum][Enum]]
  - [[#array][Array]]
  - [[#struct][Struct]]
- [[#inductive-and-coinductive-types][Inductive and Coinductive types]]
- [[#universe-hierarchy-and-the-weakly-normalizing-fragment][Universe Hierarchy and the Weakly-Normalizing Fragment]]
- [[#writing-library][Writing Library]]
- [[#where-is-][Where is ...?]]
  - [[#where-is-typeclass][Where is typeclass?]]
- [[#hacking-the-compiler][Hacking the Compiler]]
- [[#references][References]]

* Hopefully Illuminating Examples

** Automatic Memory Management (with resulting x64 assembly)
Let us move on to the interesting part. Here we will see an "inefficient" version of string printing. After that, we will see an efficient version of that code, and compare resulting assembly code.

Here I will write code in a rather verbose way to make things as explicit as possible to the readers. You don't have to be that verbose in actual code, of course.

The `with identity.bind` is the same as so-called do-notation specilized to the identity monad.
#+BEGIN_SRC scheme
(with identity.bind
  (let str "hello")          ;; define a variable `str : string` with content `"hello"`
  (let _ (string.print str)) ;; you can also write just `(print str)` instead of `(let _ (print str))`
  (let _ (string.print str))
  (string.print str))
#+END_SRC
You may note that the language doesn't require the IO monad. This is because the evaluation strategy of Neut is CBV.

** Borrowing (and its resulting assembly)
#+BEGIN_SRC scheme
(with let-bind
  (let str "hello")
  (let (tuple _ str) (string.print str))
  (let (tuple _ str) (string.print str))
  (string.print str))
#+END_SRC

#+BEGIN_SRC scheme
(with let-bind
  (let str "hello")
  (let _ (string.print &str))
  (let _ (string.print &str))
  (string.print str))
#+END_SRC

We obtain the following LLVM IR by running =$ neut build --emit llvm filename.neut=:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; memory allocation
  %_12034 = getelementptr i8, i8* null, i64 1
  %_12035 = ptrtoint i8* %_12034 to i64
  %_12036 = call fastcc i8* @malloc(i64 %_12035)
  ;; create the string "a" (i.e. write the character 'a' to the allocated memory)
  %_12037 = bitcast i8* %_12036 to [1 x i8]*
  %_12038 = inttoptr i8 97 to i8* ;; a = 97
  %_12039 = ptrtoint i8* %_12038 to i8
  %_12040 = getelementptr [1 x i8], [1 x i8]* %_12037, i32 0, i64 0 ;; where to write 'a'
  store i8 %_12039, i8* %_12040 ;; write a
  ;; write the string into stdout for the three times
  %_12041 = inttoptr i64 1 to i8* ;; this `1` stands for stdout
  %_12042 = inttoptr i64 1 to i8* ;; this `1` is the length of the string in bytes
  %_12043 = call fastcc i8* @write(i8* %_12041, i8* %_12036, i8* %_12042)
  %_12044 = inttoptr i64 1 to i8*
  %_12045 = inttoptr i64 1 to i8*
  %_12046 = call fastcc i8* @write(i8* %_12044, i8* %_12036, i8* %_12045)
  %_12047 = inttoptr i64 1 to i8*
  %_12048 = inttoptr i64 1 to i8*
  %_12049 = call fastcc i8* @write(i8* %_12047, i8* %_12036, i8* %_12048)
  ;; memory deallocation
  %_12050 = bitcast i8* %_12036 to [1 x i8]*
  %_12051 = getelementptr [1 x i8], [1 x i8]* %_12050, i32 0, i32 0
  %_12052 = load i8, i8* %_12051
  %_12053 = bitcast [1 x i8]* %_12050 to i8*
  call fastcc void @free(i8* %_12053)
  %_12054 = inttoptr i8 %_12052 to i8*
  ;; return 0
  %_12055 = inttoptr i64 0 to i8*
  %_12056 = ptrtoint i8* %_12055 to i64
  ret i64 %_12056
}
#+END_SRC
or more schematically:
#+BEGIN_SRC llvm
declare void @free(i8*)
declare i8* @write(i8*, i8*, i8*)
declare i8* @malloc(i64)
define i64 @main() {
  ;; <memory allocation for the string>
  ;; <create the string "a" (i.e. write the character 'a' to the allocated memory)>
  ;; <write the string into stdout for the three times>
  ;; <memory deallocation for the string>
  ;; <return 0>
}
#+END_SRC
The former LLVM IR is the actual output except for the comments like ";; memory allocation", which are inserted after compilation for explanatory purposes. The important point here is that the string stored at =%12036= (the second argument of =@write=) is reused without copying.

** Memory Reuse via Linearity

** Hello World
#+BEGIN_SRC neut
(string.print "Hello, world!\n")
#+END_SRC

** Inductive type (algebraic data type)
You can declare an inductive type as follows:
#+BEGIN_SRC scheme
(inductive list ((a type))
  (nil ()
    (list a))
  (cons ((_ a) (_ (list a)))
    (list a)))
#+END_SRC
where the haskell equivalent of the code above is:
#+BEGIN_SRC haskell
data List a where
  Nil  :: () -> List a
  Cons :: (A, List a) -> List a
#+END_SRC
You can then pattern match on the term of the type:
#+BEGIN_SRC scheme
(define length
  ((a tau)
   (xs (list a)))
  (case xs
    ((nil)
      0)
    ((cons _ ys)
      (add-i64 1 (length a ys))))) ;; this `add-i64` is lowered to LLVM's instruction 'add` over i64
#+END_SRC
and use it as in the expected way:
#+BEGIN_SRC scheme
(let xs (list.cons 1 (list.cons 2 (list.cons 3 (@list.nil i64)))))

(i64.print (length i64 xs)) ;; ~> 3
#+END_SRC
In actual code, you don't have to be that verbose as in the example above, thanks to implicit terms and notations (like Coq, Agda, and Lean). We will see it later.

** Summary, or Mental Model of Memory Management in Neut
- The content of a variable is
  - discarded if and only if the variable isn't used at all.
  - untouched if and only if the variable is used exactly once.
  - copied if and only if the variable is used more than once.
- You can avoid variable copying by borrowing.

* Installation
The currently supported platforms are: Linux (x64), macOS (x64).

Ensure you have already installed =stack= and =clang=. Then, clone the repository and build it:
#+BEGIN_SRC shell
$ git clone https://github.com/u2zv1wx/neut
$ git checkout XXXXXX
$ stack build
$ stack install # installs the binary `neut` into ~/.local/bin
#+END_SRC
Make sure that you have =~/.local/bin= in your =$PATH=.

* Syntax and Semantics

** tau

** Pi (forall / lambda / apply)

** Iterate (recursion)

** Int

** Float

** Enum

** Array

** Struct


* Inductive and Coinductive types
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec eleifend tellus euismod erat accumsan, nec euismod sem placerat. Ut eu lacinia arcu, id imperdiet lacus. Integer feugiat lacus mattis, dictum nunc nec, interdum justo. Fusce sed dui id orci faucibus elementum. Vivamus sit amet sapien a lorem efficitur posuere suscipit in lacus. Praesent eget sagittis nisi, id vehicula elit. Vestibulum laoreet odio ex, a aliquet justo consectetur quis. Aenean laoreet vehicula libero id varius. Vivamus condimentum, sem sed sollicitudin placerat, nulla enim faucibus odio, gravida commodo velit mi ac sapien. Integer feugiat diam in lectus porttitor, sit amet viverra velit malesuada.


* Universe Hierarchy and the Weakly-Normalizing Fragment

* Writing Library

* Where is ...?

** Where is typeclass?

* Hacking the Compiler

* References
- L. de Moura, J. Avigad, S. Kong, and C. Roux, Elaboration in Dependent Type Theory, [[https://arxiv.org/abs/1505.04324]], 2015.
- P. Levy, Call-by-Push-Value: A Subsuming Paradigm, Ph. D. thesis, Queen Mary College, 2001.
